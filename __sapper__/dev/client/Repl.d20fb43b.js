import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, c as create_slot, h as element, k as claim_element, l as children, m as detach_dev, o as attr_dev, p as add_location, q as insert_dev, f as space, w as empty, j as claim_space, v as append_dev, g as get_slot_changes, a as get_slot_context, t as transition_in, b as transition_out, H as binding_callbacks, I as createEventDispatcher, G as getContext, J as toggle_class, E as group_outros, F as check_outros, K as add_render_callback, L as create_in_transition, M as create_out_transition, r as text, u as claim_text, N as listen_dev, x as set_data_dev, n as noop, O as onMount, P as set_style, A as mount_component, D as destroy_component, Q as add_resize_listener, R as prop_dev, e as globals, T as subscribe, U as validate_store, V as component_subscribe, W as svg_element, X as destroy_each, Y as run_all, Z as set_store_value, _ as set_input_value, $ as null_to_empty, a0 as bind, a1 as add_flush_callback, z as setContext } from './index.121aa0ed.js';
import { w as writable } from './index.ab7b6b80.js';

function clamp(num, min, max) {
    return num < min ? min : num > max ? max : num;
}

/* node_modules\@sveltejs\svelte-repl\src\SplitPane.svelte generated by Svelte v3.12.0 */

const file = "node_modules\\@sveltejs\\svelte-repl\\src\\SplitPane.svelte";

const get_b_slot_changes = () => ({});
const get_b_slot_context = () => ({});

const get_a_slot_changes = () => ({});
const get_a_slot_context = () => ({});

// (157:1) {#if !fixed}
function create_if_block_1(ctx) {
	var div, div_class_value, div_style_value, drag_action;

	const block = {
		c: function create() {
			div = element("div");
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true, style: true }, false);
			var div_nodes = children(div);

			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(div, "class", div_class_value = "" + ctx.type + " divider" + " svelte-zr3pp4");
			attr_dev(div, "style", div_style_value = "" + ctx.side + ": calc(" + ctx.pos + "% - 8px)");
			add_location(div, file, 157, 2, 2723);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			drag_action = ctx.drag.call(null, div, ctx.setPos) || {};
		},

		p: function update(changed, ctx) {
			if ((changed.type) && div_class_value !== (div_class_value = "" + ctx.type + " divider" + " svelte-zr3pp4")) {
				attr_dev(div, "class", div_class_value);
			}

			if ((changed.side || changed.pos) && div_style_value !== (div_style_value = "" + ctx.side + ": calc(" + ctx.pos + "% - 8px)")) {
				attr_dev(div, "style", div_style_value);
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			if (drag_action && typeof drag_action.destroy === 'function') drag_action.destroy();
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_1.name, type: "if", source: "(157:1) {#if !fixed}", ctx });
	return block;
}

// (162:0) {#if dragging}
function create_if_block(ctx) {
	var div;

	const block = {
		c: function create() {
			div = element("div");
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true }, false);
			var div_nodes = children(div);

			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(div, "class", "mousecatcher svelte-zr3pp4");
			add_location(div, file, 162, 1, 2842);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block.name, type: "if", source: "(162:0) {#if dragging}", ctx });
	return block;
}

function create_fragment(ctx) {
	var div2, div0, div0_style_value, t0, div1, div1_style_value, t1, t2, if_block1_anchor, current;

	const a_slot_template = ctx.$$slots.a;
	const a_slot = create_slot(a_slot_template, ctx, get_a_slot_context);

	const b_slot_template = ctx.$$slots.b;
	const b_slot = create_slot(b_slot_template, ctx, get_b_slot_context);

	var if_block0 = (!ctx.fixed) && create_if_block_1(ctx);

	var if_block1 = (ctx.dragging) && create_if_block(ctx);

	const block = {
		c: function create() {
			div2 = element("div");
			div0 = element("div");

			if (a_slot) a_slot.c();
			t0 = space();
			div1 = element("div");

			if (b_slot) b_slot.c();
			t1 = space();
			if (if_block0) if_block0.c();
			t2 = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
			this.h();
		},

		l: function claim(nodes) {
			div2 = claim_element(nodes, "DIV", { class: true }, false);
			var div2_nodes = children(div2);

			div0 = claim_element(div2_nodes, "DIV", { class: true, style: true }, false);
			var div0_nodes = children(div0);

			if (a_slot) a_slot.l(div0_nodes);
			div0_nodes.forEach(detach_dev);
			t0 = claim_space(div2_nodes);

			div1 = claim_element(div2_nodes, "DIV", { class: true, style: true }, false);
			var div1_nodes = children(div1);

			if (b_slot) b_slot.l(div1_nodes);
			div1_nodes.forEach(detach_dev);
			t1 = claim_space(div2_nodes);
			if (if_block0) if_block0.l(div2_nodes);
			div2_nodes.forEach(detach_dev);
			t2 = claim_space(nodes);
			if (if_block1) if_block1.l(nodes);
			if_block1_anchor = empty();
			this.h();
		},

		h: function hydrate() {
			attr_dev(div0, "class", "pane svelte-zr3pp4");
			attr_dev(div0, "style", div0_style_value = "" + ctx.dimension + ": " + ctx.pos + "%;");
			add_location(div0, file, 148, 1, 2534);

			attr_dev(div1, "class", "pane svelte-zr3pp4");
			attr_dev(div1, "style", div1_style_value = "" + ctx.dimension + ": " + (100 - (ctx.pos)) + "%;");
			add_location(div1, file, 152, 1, 2617);
			attr_dev(div2, "class", "container svelte-zr3pp4");
			add_location(div2, file, 147, 0, 2482);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, div0);

			if (a_slot) {
				a_slot.m(div0, null);
			}

			append_dev(div2, t0);
			append_dev(div2, div1);

			if (b_slot) {
				b_slot.m(div1, null);
			}

			append_dev(div2, t1);
			if (if_block0) if_block0.m(div2, null);
			ctx.div2_binding(div2);
			insert_dev(target, t2, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert_dev(target, if_block1_anchor, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			if (a_slot && a_slot.p && changed.$$scope) {
				a_slot.p(
					get_slot_changes(a_slot_template, ctx, changed, get_a_slot_changes),
					get_slot_context(a_slot_template, ctx, get_a_slot_context)
				);
			}

			if ((!current || changed.dimension || changed.pos) && div0_style_value !== (div0_style_value = "" + ctx.dimension + ": " + ctx.pos + "%;")) {
				attr_dev(div0, "style", div0_style_value);
			}

			if (b_slot && b_slot.p && changed.$$scope) {
				b_slot.p(
					get_slot_changes(b_slot_template, ctx, changed, get_b_slot_changes),
					get_slot_context(b_slot_template, ctx, get_b_slot_context)
				);
			}

			if ((!current || changed.dimension || changed.pos) && div1_style_value !== (div1_style_value = "" + ctx.dimension + ": " + (100 - (ctx.pos)) + "%;")) {
				attr_dev(div1, "style", div1_style_value);
			}

			if (!ctx.fixed) {
				if (if_block0) {
					if_block0.p(changed, ctx);
				} else {
					if_block0 = create_if_block_1(ctx);
					if_block0.c();
					if_block0.m(div2, null);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (ctx.dragging) {
				if (!if_block1) {
					if_block1 = create_if_block(ctx);
					if_block1.c();
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(a_slot, local);
			transition_in(b_slot, local);
			current = true;
		},

		o: function outro(local) {
			transition_out(a_slot, local);
			transition_out(b_slot, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div2);
			}

			if (a_slot) a_slot.d(detaching);

			if (b_slot) b_slot.d(detaching);
			if (if_block0) if_block0.d();
			ctx.div2_binding(null);

			if (detaching) {
				detach_dev(t2);
			}

			if (if_block1) if_block1.d(detaching);

			if (detaching) {
				detach_dev(if_block1_anchor);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment.name, type: "component", source: "", ctx });
	return block;
}

function instance($$self, $$props, $$invalidate) {
	

	const dispatch = createEventDispatcher();

	let { type, pos = 50, fixed = false, min = 50 } = $$props;
	// export let min1 = min;
	// export let min2 = min;

	const refs = {};

	let dragging = false;

	function setPos(event) {
		const { top, bottom, left, right } = refs.container.getBoundingClientRect();

		const extents = type === 'vertical' ? [top, bottom] : [left, right];

		const px = clamp(
			type === 'vertical' ? event.clientY : event.clientX,
			extents[0] + min,
			extents[1] - min
		);

		$$invalidate('pos', pos = 100 * (px - extents[0]) / (extents[1] - extents[0]));

		dispatch('change');
	}

	function drag(node, callback) {
		const mousedown = event => {
			if (event.which !== 1) return;

			event.preventDefault();

			$$invalidate('dragging', dragging = true);

			const onmouseup = () => {
				$$invalidate('dragging', dragging = false);

				window.removeEventListener('mousemove', callback, false);
				window.removeEventListener('mouseup', onmouseup, false);
			};

			window.addEventListener('mousemove', callback, false);
			window.addEventListener('mouseup', onmouseup, false);
		};

		node.addEventListener('mousedown', mousedown, false);

		return {
			destroy() {
				node.removeEventListener('mousedown', onmousedown, false);
			}
		};
	}

	const writable_props = ['type', 'pos', 'fixed', 'min'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<SplitPane> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;

	function div2_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			refs.container = $$value;
			$$invalidate('refs', refs);
		});
	}

	$$self.$set = $$props => {
		if ('type' in $$props) $$invalidate('type', type = $$props.type);
		if ('pos' in $$props) $$invalidate('pos', pos = $$props.pos);
		if ('fixed' in $$props) $$invalidate('fixed', fixed = $$props.fixed);
		if ('min' in $$props) $$invalidate('min', min = $$props.min);
		if ('$$scope' in $$props) $$invalidate('$$scope', $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => {
		return { type, pos, fixed, min, dragging, side, dimension };
	};

	$$self.$inject_state = $$props => {
		if ('type' in $$props) $$invalidate('type', type = $$props.type);
		if ('pos' in $$props) $$invalidate('pos', pos = $$props.pos);
		if ('fixed' in $$props) $$invalidate('fixed', fixed = $$props.fixed);
		if ('min' in $$props) $$invalidate('min', min = $$props.min);
		if ('dragging' in $$props) $$invalidate('dragging', dragging = $$props.dragging);
		if ('side' in $$props) $$invalidate('side', side = $$props.side);
		if ('dimension' in $$props) $$invalidate('dimension', dimension = $$props.dimension);
	};

	let side, dimension;

	$$self.$$.update = ($$dirty = { type: 1 }) => {
		if ($$dirty.type) { $$invalidate('side', side = type === 'horizontal' ? 'left' : 'top'); }
		if ($$dirty.type) { $$invalidate('dimension', dimension = type === 'horizontal' ? 'width' : 'height'); }
	};

	return {
		type,
		pos,
		fixed,
		min,
		refs,
		dragging,
		setPos,
		drag,
		side,
		dimension,
		div2_binding,
		$$slots,
		$$scope
	};
}

class SplitPane extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, ["type", "pos", "fixed", "min"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "SplitPane", options, id: create_fragment.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.type === undefined && !('type' in props)) {
			console.warn("<SplitPane> was created without expected prop 'type'");
		}
	}

	get type() {
		throw new Error("<SplitPane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set type(value) {
		throw new Error("<SplitPane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get pos() {
		throw new Error("<SplitPane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set pos(value) {
		throw new Error("<SplitPane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fixed() {
		throw new Error("<SplitPane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fixed(value) {
		throw new Error("<SplitPane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get min() {
		throw new Error("<SplitPane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set min(value) {
		throw new Error("<SplitPane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

const is_browser = typeof window !== 'undefined';

function cubicOut(t) {
    const f = t - 1.0;
    return f * f * f + 1.0;
}

function slide(node, { delay = 0, duration = 400, easing = cubicOut }) {
    const style = getComputedStyle(node);
    const opacity = +style.opacity;
    const height = parseFloat(style.height);
    const padding_top = parseFloat(style.paddingTop);
    const padding_bottom = parseFloat(style.paddingBottom);
    const margin_top = parseFloat(style.marginTop);
    const margin_bottom = parseFloat(style.marginBottom);
    const border_top_width = parseFloat(style.borderTopWidth);
    const border_bottom_width = parseFloat(style.borderBottomWidth);
    return {
        delay,
        duration,
        easing,
        css: t => `overflow: hidden;` +
            `opacity: ${Math.min(t * 20, 1) * opacity};` +
            `height: ${t * height}px;` +
            `padding-top: ${t * padding_top}px;` +
            `padding-bottom: ${t * padding_bottom}px;` +
            `margin-top: ${t * margin_top}px;` +
            `margin-bottom: ${t * margin_bottom}px;` +
            `border-top-width: ${t * border_top_width}px;` +
            `border-bottom-width: ${t * border_bottom_width}px;`
    };
}

/* node_modules\@sveltejs\svelte-repl\src\Message.svelte generated by Svelte v3.12.0 */

const file$1 = "node_modules\\@sveltejs\\svelte-repl\\src\\Message.svelte";

// (88:1) {:else}
function create_else_block(ctx) {
	var current;

	const default_slot_template = ctx.$$slots.default;
	const default_slot = create_slot(default_slot_template, ctx, null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},

		l: function claim(nodes) {
			if (default_slot) default_slot.l(nodes);
		},

		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},

		p: function update(changed, ctx) {
			if (default_slot && default_slot.p && changed.$$scope) {
				default_slot.p(
					get_slot_changes(default_slot_template, ctx, changed, null),
					get_slot_context(default_slot_template, ctx, null)
				);
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},

		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_else_block.name, type: "else", source: "(88:1) {:else}", ctx });
	return block;
}

// (83:1) {#if details}
function create_if_block$1(ctx) {
	var p, t_value = ctx.message(ctx.details) + "", t, dispose;

	const block = {
		c: function create() {
			p = element("p");
			t = text(t_value);
			this.h();
		},

		l: function claim(nodes) {
			p = claim_element(nodes, "P", { class: true }, false);
			var p_nodes = children(p);

			t = claim_text(p_nodes, t_value);
			p_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(p, "class", "svelte-1w07di8");
			toggle_class(p, "navigable", ctx.details.filename);
			add_location(p, file$1, 83, 2, 1471);
			dispose = listen_dev(p, "click", ctx.click_handler);
		},

		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},

		p: function update(changed, ctx) {
			if ((changed.details) && t_value !== (t_value = ctx.message(ctx.details) + "")) {
				set_data_dev(t, t_value);
			}

			if (changed.details) {
				toggle_class(p, "navigable", ctx.details.filename);
			}
		},

		i: noop,
		o: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(p);
			}

			dispose();
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block$1.name, type: "if", source: "(83:1) {#if details}", ctx });
	return block;
}

function create_fragment$1(ctx) {
	var div, current_block_type_index, if_block, div_class_value, div_intro, div_outro, current;

	var if_block_creators = [
		create_if_block$1,
		create_else_block
	];

	var if_blocks = [];

	function select_block_type(changed, ctx) {
		if (ctx.details) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(null, ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			div = element("div");
			if_block.c();
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true }, false);
			var div_nodes = children(div);

			if_block.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(div, "class", div_class_value = "message " + ctx.kind + " svelte-1w07di8");
			toggle_class(div, "truncate", ctx.truncate);
			add_location(div, file$1, 81, 0, 1343);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if_blocks[current_block_type_index].m(div, null);
			current = true;
		},

		p: function update(changed, ctx) {
			var previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(changed, ctx);
			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(changed, ctx);
			} else {
				group_outros();
				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});
				check_outros();

				if_block = if_blocks[current_block_type_index];
				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}
				transition_in(if_block, 1);
				if_block.m(div, null);
			}

			if ((!current || changed.kind) && div_class_value !== (div_class_value = "message " + ctx.kind + " svelte-1w07di8")) {
				attr_dev(div, "class", div_class_value);
			}

			if ((changed.kind || changed.truncate)) {
				toggle_class(div, "truncate", ctx.truncate);
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(if_block);

			add_render_callback(() => {
				if (div_outro) div_outro.end(1);
				if (!div_intro) div_intro = create_in_transition(div, slide, {delay: 150, duration: 100});
				div_intro.start();
			});

			current = true;
		},

		o: function outro(local) {
			transition_out(if_block);
			if (div_intro) div_intro.invalidate();

			div_outro = create_out_transition(div, slide, {duration: 100});

			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			if_blocks[current_block_type_index].d();

			if (detaching) {
				if (div_outro) div_outro.end();
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$1.name, type: "component", source: "", ctx });
	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	

	const { navigate } = getContext('REPL');

	let { kind, details = null, filename = null, truncate } = $$props;

	function message(details) {
		let str = details.message || '[missing message]';

		let loc = [];

		if (details.filename && details.filename !== filename) {
			loc.push(details.filename);
		}

		if (details.start) loc.push(details.start.line, details.start.column);

		return str + (loc.length ? ` (${loc.join(':')})` : ``);
	}
	const writable_props = ['kind', 'details', 'filename', 'truncate'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Message> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;

	const click_handler = () => navigate(details);

	$$self.$set = $$props => {
		if ('kind' in $$props) $$invalidate('kind', kind = $$props.kind);
		if ('details' in $$props) $$invalidate('details', details = $$props.details);
		if ('filename' in $$props) $$invalidate('filename', filename = $$props.filename);
		if ('truncate' in $$props) $$invalidate('truncate', truncate = $$props.truncate);
		if ('$$scope' in $$props) $$invalidate('$$scope', $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => {
		return { kind, details, filename, truncate };
	};

	$$self.$inject_state = $$props => {
		if ('kind' in $$props) $$invalidate('kind', kind = $$props.kind);
		if ('details' in $$props) $$invalidate('details', details = $$props.details);
		if ('filename' in $$props) $$invalidate('filename', filename = $$props.filename);
		if ('truncate' in $$props) $$invalidate('truncate', truncate = $$props.truncate);
	};

	return {
		navigate,
		kind,
		details,
		filename,
		truncate,
		message,
		click_handler,
		$$slots,
		$$scope
	};
}

class Message extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, ["kind", "details", "filename", "truncate"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "Message", options, id: create_fragment$1.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.kind === undefined && !('kind' in props)) {
			console.warn("<Message> was created without expected prop 'kind'");
		}
		if (ctx.truncate === undefined && !('truncate' in props)) {
			console.warn("<Message> was created without expected prop 'truncate'");
		}
	}

	get kind() {
		throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set kind(value) {
		throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get details() {
		throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set details(value) {
		throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get filename() {
		throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set filename(value) {
		throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get truncate() {
		throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set truncate(value) {
		throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\@sveltejs\svelte-repl\src\CodeMirror.svelte generated by Svelte v3.12.0 */

const file$2 = "node_modules\\@sveltejs\\svelte-repl\\src\\CodeMirror.svelte";

// (273:1) {#if !CodeMirror}
function create_if_block$2(ctx) {
	var pre, t0, t1, div, current;

	var message = new Message({
		props: {
		kind: "info",
		$$slots: { default: [create_default_slot] },
		$$scope: { ctx }
	},
		$$inline: true
	});

	const block = {
		c: function create() {
			pre = element("pre");
			t0 = text(ctx.code);
			t1 = space();
			div = element("div");
			message.$$.fragment.c();
			this.h();
		},

		l: function claim(nodes) {
			pre = claim_element(nodes, "PRE", { style: true, class: true }, false);
			var pre_nodes = children(pre);

			t0 = claim_text(pre_nodes, ctx.code);
			pre_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);

			div = claim_element(nodes, "DIV", { style: true }, false);
			var div_nodes = children(div);

			message.$$.fragment.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			set_style(pre, "position", "absolute");
			set_style(pre, "left", "0");
			set_style(pre, "top", "0");
			attr_dev(pre, "class", "svelte-s9cc8a");
			add_location(pre, file$2, 273, 2, 5262);
			set_style(div, "position", "absolute");
			set_style(div, "width", "100%");
			set_style(div, "bottom", "0");
			add_location(div, file$2, 276, 2, 5330);
		},

		m: function mount(target, anchor) {
			insert_dev(target, pre, anchor);
			append_dev(pre, t0);
			insert_dev(target, t1, anchor);
			insert_dev(target, div, anchor);
			mount_component(message, div, null);
			current = true;
		},

		p: function update_1(changed, ctx) {
			if (!current || changed.code) {
				set_data_dev(t0, ctx.code);
			}

			var message_changes = {};
			if (changed.$$scope) message_changes.$$scope = { changed, ctx };
			message.$set(message_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(message.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(message.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(pre);
				detach_dev(t1);
				detach_dev(div);
			}

			destroy_component(message);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block$2.name, type: "if", source: "(273:1) {#if !CodeMirror}", ctx });
	return block;
}

// (278:3) <Message kind='info'>
function create_default_slot(ctx) {
	var t;

	const block = {
		c: function create() {
			t = text("loading editor...");
		},

		l: function claim(nodes) {
			t = claim_text(nodes, "loading editor...");
		},

		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_default_slot.name, type: "slot", source: "(278:3) <Message kind='info'>", ctx });
	return block;
}

function create_fragment$2(ctx) {
	var div, textarea, t, div_resize_listener, current;

	var if_block = (!ctx.CodeMirror) && create_if_block$2(ctx);

	const block = {
		c: function create() {
			div = element("div");
			textarea = element("textarea");
			t = space();
			if (if_block) if_block.c();
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true }, false);
			var div_nodes = children(div);

			textarea = claim_element(div_nodes, "TEXTAREA", { tabindex: true, readonly: true, value: true, class: true }, false);
			var textarea_nodes = children(textarea);

			textarea_nodes.forEach(detach_dev);
			t = claim_space(div_nodes);
			if (if_block) if_block.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(textarea, "tabindex", "2");
			textarea.readOnly = true;
			textarea.value = ctx.code;
			attr_dev(textarea, "class", "svelte-s9cc8a");
			add_location(textarea, file$2, 265, 1, 5149);
			add_render_callback(() => ctx.div_resize_handler.call(div));
			attr_dev(div, "class", "codemirror-container svelte-s9cc8a");
			toggle_class(div, "flex", ctx.flex);
			add_location(div, file$2, 263, 0, 5012);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, textarea);
			ctx.textarea_binding(textarea);
			append_dev(div, t);
			if (if_block) if_block.m(div, null);
			div_resize_listener = add_resize_listener(div, ctx.div_resize_handler.bind(div));
			current = true;
		},

		p: function update_1(changed, ctx) {
			if (!current || changed.code) {
				prop_dev(textarea, "value", ctx.code);
			}

			if (!ctx.CodeMirror) {
				if (if_block) {
					if_block.p(changed, ctx);
					transition_in(if_block, 1);
				} else {
					if_block = create_if_block$2(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div, null);
				}
			} else if (if_block) {
				group_outros();
				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});
				check_outros();
			}

			if (changed.flex) {
				toggle_class(div, "flex", ctx.flex);
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},

		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			ctx.textarea_binding(null);
			if (if_block) if_block.d();
			div_resize_listener.cancel();
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$2.name, type: "component", source: "", ctx });
	return block;
}

let codemirror_promise;
let _CodeMirror;

if (is_browser) {
	codemirror_promise = import(/* webpackChunkName: "codemirror" */ './codemirror.5ce01cfa.js');

	codemirror_promise.then(mod => {
		_CodeMirror = mod.default;
	});
}

function sleep(ms) {
	return new Promise(fulfil => setTimeout(fulfil, ms));
}

function instance$2($$self, $$props, $$invalidate) {
	

	const dispatch = createEventDispatcher();
	const { navigate } = getContext('REPL');

	let { readonly = false, errorLoc = null, flex = false, lineNumbers = true, tab = true } = $$props;

	let w;
	let h;
	let code = '';
	let mode;

	// We have to expose set and update methods, rather
	// than making this state-driven through props,
	// because it's difficult to update an editor
	// without resetting scroll otherwise
	async function set(new_code, new_mode) {
		if (new_mode !== mode) {
			await createEditor(mode = new_mode);
		}

		$$invalidate('code', code = new_code);
		updating_externally = true;
		if (editor) editor.setValue(code);
		updating_externally = false;
	}

	function update(new_code) {
		$$invalidate('code', code = new_code);

		if (editor) {
			const { left, top } = editor.getScrollInfo();
			editor.setValue($$invalidate('code', code = new_code));
			editor.scrollTo(left, top);
		}
	}

	function resize() {
		editor.refresh();
	}

	function focus() {
		editor.focus();
	}

	const modes = {
		js: {
			name: 'javascript',
			json: false
		},
		json: {
			name: 'javascript',
			json: true
		},
		svelte: {
			name: 'handlebars',
			base: 'text/html'
		}
	};

	const refs = {};
	let editor;
	let updating_externally = false;
	let marker;
	let error_line;
	let destroyed = false;
	let CodeMirror;

	let previous_error_line;

	onMount(() => {
		if (_CodeMirror) {
			$$invalidate('CodeMirror', CodeMirror = _CodeMirror);
			createEditor(mode || 'svelte').then(() => {
				if (editor) editor.setValue(code || '');
			});
		} else {
			codemirror_promise.then(async mod => {
				$$invalidate('CodeMirror', CodeMirror = mod.default);
				await createEditor(mode || 'svelte');
				if (editor) editor.setValue(code || '');
			});
		}

		return () => {
			destroyed = true;
			if (editor) editor.toTextArea();
		}
	});

	let first = true;

	async function createEditor(mode) {
		if (destroyed || !CodeMirror) return;

		if (editor) editor.toTextArea();

		const opts = {
			lineNumbers,
			lineWrapping: true,
			indentWithTabs: true,
			indentUnit: 2,
			tabSize: 2,
			value: '',
			mode: modes[mode] || {
				name: mode
			},
			readOnly: readonly,
			autoCloseBrackets: true,
			autoCloseTags: true
		};

		if (!tab) opts.extraKeys = {
			Tab: tab,
			'Shift-Tab': tab
		};

		// Creating a text editor is a lot of work, so we yield
		// the main thread for a moment. This helps reduce jank
		if (first) await sleep(50);

		if (destroyed) return;

		$$invalidate('editor', editor = CodeMirror.fromTextArea(refs.editor, opts));

		editor.on('change', instance => {
			if (!updating_externally) {
				const value = instance.getValue();
				dispatch('change', { value });
			}
		});

		if (first) await sleep(50);
		editor.refresh();

		first = false;
	}

	const writable_props = ['readonly', 'errorLoc', 'flex', 'lineNumbers', 'tab'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<CodeMirror> was created with unknown prop '${key}'`);
	});

	function textarea_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			refs.editor = $$value;
			$$invalidate('refs', refs);
		});
	}

	function div_resize_handler() {
		w = this.offsetWidth;
		h = this.offsetHeight;
		$$invalidate('w', w);
		$$invalidate('h', h);
	}

	$$self.$set = $$props => {
		if ('readonly' in $$props) $$invalidate('readonly', readonly = $$props.readonly);
		if ('errorLoc' in $$props) $$invalidate('errorLoc', errorLoc = $$props.errorLoc);
		if ('flex' in $$props) $$invalidate('flex', flex = $$props.flex);
		if ('lineNumbers' in $$props) $$invalidate('lineNumbers', lineNumbers = $$props.lineNumbers);
		if ('tab' in $$props) $$invalidate('tab', tab = $$props.tab);
	};

	$$self.$capture_state = () => {
		return { codemirror_promise, _CodeMirror, readonly, errorLoc, flex, lineNumbers, tab, w, h, code, mode, editor, updating_externally, marker, error_line, destroyed, CodeMirror, previous_error_line, first };
	};

	$$self.$inject_state = $$props => {
		if ('readonly' in $$props) $$invalidate('readonly', readonly = $$props.readonly);
		if ('errorLoc' in $$props) $$invalidate('errorLoc', errorLoc = $$props.errorLoc);
		if ('flex' in $$props) $$invalidate('flex', flex = $$props.flex);
		if ('lineNumbers' in $$props) $$invalidate('lineNumbers', lineNumbers = $$props.lineNumbers);
		if ('tab' in $$props) $$invalidate('tab', tab = $$props.tab);
		if ('w' in $$props) $$invalidate('w', w = $$props.w);
		if ('h' in $$props) $$invalidate('h', h = $$props.h);
		if ('code' in $$props) $$invalidate('code', code = $$props.code);
		if ('mode' in $$props) mode = $$props.mode;
		if ('editor' in $$props) $$invalidate('editor', editor = $$props.editor);
		if ('updating_externally' in $$props) updating_externally = $$props.updating_externally;
		if ('marker' in $$props) $$invalidate('marker', marker = $$props.marker);
		if ('error_line' in $$props) $$invalidate('error_line', error_line = $$props.error_line);
		if ('destroyed' in $$props) destroyed = $$props.destroyed;
		if ('CodeMirror' in $$props) $$invalidate('CodeMirror', CodeMirror = $$props.CodeMirror);
		if ('previous_error_line' in $$props) $$invalidate('previous_error_line', previous_error_line = $$props.previous_error_line);
		if ('first' in $$props) first = $$props.first;
	};

	$$self.$$.update = ($$dirty = { editor: 1, w: 1, h: 1, marker: 1, errorLoc: 1, previous_error_line: 1, error_line: 1 }) => {
		if ($$dirty.editor || $$dirty.w || $$dirty.h) { if (editor && w && h) {
				editor.refresh();
			} }
		if ($$dirty.marker || $$dirty.errorLoc || $$dirty.editor) { {
				if (marker) marker.clear();
		
				if (errorLoc) {
					const line = errorLoc.line - 1;
					const ch = errorLoc.column;
		
					$$invalidate('marker', marker = editor.markText({ line, ch }, { line, ch: ch + 1 }, {
						className: 'error-loc'
					}));
		
					$$invalidate('error_line', error_line = line);
				} else {
					$$invalidate('error_line', error_line = null);
				}
			} }
		if ($$dirty.editor || $$dirty.previous_error_line || $$dirty.error_line) { if (editor) {
				if (previous_error_line != null) {
					editor.removeLineClass(previous_error_line, 'wrap', 'error-line');
				}
		
				if (error_line && (error_line !== previous_error_line)) {
					editor.addLineClass(error_line, 'wrap', 'error-line');
					$$invalidate('previous_error_line', previous_error_line = error_line);
				}
			} }
	};

	return {
		readonly,
		errorLoc,
		flex,
		lineNumbers,
		tab,
		w,
		h,
		code,
		set,
		update,
		resize,
		focus,
		refs,
		CodeMirror,
		textarea_binding,
		div_resize_handler
	};
}

class CodeMirror_1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, ["readonly", "errorLoc", "flex", "lineNumbers", "tab", "set", "update", "resize", "focus"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "CodeMirror_1", options, id: create_fragment$2.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.set === undefined && !('set' in props)) {
			console.warn("<CodeMirror> was created without expected prop 'set'");
		}
		if (ctx.update === undefined && !('update' in props)) {
			console.warn("<CodeMirror> was created without expected prop 'update'");
		}
		if (ctx.resize === undefined && !('resize' in props)) {
			console.warn("<CodeMirror> was created without expected prop 'resize'");
		}
		if (ctx.focus === undefined && !('focus' in props)) {
			console.warn("<CodeMirror> was created without expected prop 'focus'");
		}
	}

	get readonly() {
		throw new Error("<CodeMirror>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set readonly(value) {
		throw new Error("<CodeMirror>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get errorLoc() {
		throw new Error("<CodeMirror>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set errorLoc(value) {
		throw new Error("<CodeMirror>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get flex() {
		throw new Error("<CodeMirror>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set flex(value) {
		throw new Error("<CodeMirror>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get lineNumbers() {
		throw new Error("<CodeMirror>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set lineNumbers(value) {
		throw new Error("<CodeMirror>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tab() {
		throw new Error("<CodeMirror>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tab(value) {
		throw new Error("<CodeMirror>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get set() {
		return this.$$.ctx.set;
	}

	set set(value) {
		throw new Error("<CodeMirror>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get update() {
		return this.$$.ctx.update;
	}

	set update(value) {
		throw new Error("<CodeMirror>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get resize() {
		return this.$$.ctx.resize;
	}

	set resize(value) {
		throw new Error("<CodeMirror>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get focus() {
		return this.$$.ctx.focus;
	}

	set focus(value) {
		throw new Error("<CodeMirror>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\@sveltejs\svelte-repl\src\Input\ComponentSelector.svelte generated by Svelte v3.12.0 */
const { console: console_1 } = globals;

const file$3 = "node_modules\\@sveltejs\\svelte-repl\\src\\Input\\ComponentSelector.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.component = list[i];
	return child_ctx;
}

// (200:1) {#if $components.length}
function create_if_block$3(ctx) {
	var div, t, button, svg, line0, line1, dispose;

	let each_value = ctx.$components;

	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space();
			button = element("button");
			svg = svg_element("svg");
			line0 = svg_element("line");
			line1 = svg_element("line");
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true }, false);
			var div_nodes = children(div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div_nodes);
			}

			t = claim_space(div_nodes);

			button = claim_element(div_nodes, "BUTTON", { class: true, title: true }, false);
			var button_nodes = children(button);

			svg = claim_element(button_nodes, "svg", { width: true, height: true, viewBox: true, class: true }, true);
			var svg_nodes = children(svg);

			line0 = claim_element(svg_nodes, "line", { stroke: true, x1: true, y1: true, x2: true, y2: true }, true);
			var line0_nodes = children(line0);

			line0_nodes.forEach(detach_dev);

			line1 = claim_element(svg_nodes, "line", { stroke: true, x1: true, y1: true, x2: true, y2: true }, true);
			var line1_nodes = children(line1);

			line1_nodes.forEach(detach_dev);
			svg_nodes.forEach(detach_dev);
			button_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(line0, "stroke", "#999");
			attr_dev(line0, "x1", "12");
			attr_dev(line0, "y1", "5");
			attr_dev(line0, "x2", "12");
			attr_dev(line0, "y2", "19");
			add_location(line0, file$3, 249, 5, 5304);
			attr_dev(line1, "stroke", "#999");
			attr_dev(line1, "x1", "5");
			attr_dev(line1, "y1", "12");
			attr_dev(line1, "x2", "19");
			attr_dev(line1, "y2", "12");
			add_location(line1, file$3, 250, 5, 5363);
			attr_dev(svg, "width", "12");
			attr_dev(svg, "height", "12");
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "class", "svelte-1wzo3es");
			add_location(svg, file$3, 248, 4, 5250);
			attr_dev(button, "class", "add-new svelte-1wzo3es");
			attr_dev(button, "title", "add new component");
			add_location(button, file$3, 247, 3, 5177);
			attr_dev(div, "class", "file-tabs svelte-1wzo3es");
			add_location(div, file$3, 200, 2, 3827);

			dispose = [
				listen_dev(button, "click", ctx.addNew),
				listen_dev(div, "dblclick", ctx.addNew)
			];
		},

		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			append_dev(div, t);
			append_dev(div, button);
			append_dev(button, svg);
			append_dev(svg, line0);
			append_dev(svg, line1);
		},

		p: function update(changed, ctx) {
			if (changed.$components || changed.$selected || changed.editing) {
				each_value = ctx.$components;

				let i;
				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(changed, child_ctx);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, t);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}
				each_blocks.length = each_value.length;
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			destroy_each(each_blocks, detaching);

			run_all(dispose);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block$3.name, type: "if", source: "(200:1) {#if $components.length}", ctx });
	return block;
}

// (228:6) {:else}
function create_else_block$1(ctx) {
	var div, t0_value = ctx.component.name + "", t0, t1, t2_value = ctx.component.type + "", t2, t3, span, svg, line0, line1, dispose;

	function click_handler() {
		return ctx.click_handler(ctx);
	}

	function click_handler_1() {
		return ctx.click_handler_1(ctx);
	}

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = text(".");
			t2 = text(t2_value);
			t3 = space();
			span = element("span");
			svg = svg_element("svg");
			line0 = svg_element("line");
			line1 = svg_element("line");
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true, title: true }, false);
			var div_nodes = children(div);

			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_text(div_nodes, ".");
			t2 = claim_text(div_nodes, t2_value);
			div_nodes.forEach(detach_dev);
			t3 = claim_space(nodes);

			span = claim_element(nodes, "SPAN", { class: true }, false);
			var span_nodes = children(span);

			svg = claim_element(span_nodes, "svg", { width: true, height: true, viewBox: true, class: true }, true);
			var svg_nodes = children(svg);

			line0 = claim_element(svg_nodes, "line", { stroke: true, x1: true, y1: true, x2: true, y2: true }, true);
			var line0_nodes = children(line0);

			line0_nodes.forEach(detach_dev);

			line1 = claim_element(svg_nodes, "line", { stroke: true, x1: true, y1: true, x2: true, y2: true }, true);
			var line1_nodes = children(line1);

			line1_nodes.forEach(detach_dev);
			svg_nodes.forEach(detach_dev);
			span_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(div, "class", "editable svelte-1wzo3es");
			attr_dev(div, "title", "edit component name");
			add_location(div, file$3, 228, 7, 4673);
			attr_dev(line0, "stroke", "#999");
			attr_dev(line0, "x1", "18");
			attr_dev(line0, "y1", "6");
			attr_dev(line0, "x2", "6");
			attr_dev(line0, "y2", "18");
			add_location(line0, file$3, 238, 9, 4983);
			attr_dev(line1, "stroke", "#999");
			attr_dev(line1, "x1", "6");
			attr_dev(line1, "y1", "6");
			attr_dev(line1, "x2", "18");
			attr_dev(line1, "y2", "18");
			add_location(line1, file$3, 239, 9, 5045);
			attr_dev(svg, "width", "12");
			attr_dev(svg, "height", "12");
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "class", "svelte-1wzo3es");
			add_location(svg, file$3, 237, 8, 4925);
			attr_dev(span, "class", "remove svelte-1wzo3es");
			add_location(span, file$3, 236, 7, 4858);

			dispose = [
				listen_dev(div, "click", click_handler),
				listen_dev(span, "click", click_handler_1)
			];
		},

		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);
			append_dev(div, t2);
			insert_dev(target, t3, anchor);
			insert_dev(target, span, anchor);
			append_dev(span, svg);
			append_dev(svg, line0);
			append_dev(svg, line1);
		},

		p: function update(changed, new_ctx) {
			ctx = new_ctx;
			if ((changed.$components) && t0_value !== (t0_value = ctx.component.name + "")) {
				set_data_dev(t0, t0_value);
			}

			if ((changed.$components) && t2_value !== (t2_value = ctx.component.type + "")) {
				set_data_dev(t2, t2_value);
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
				detach_dev(t3);
				detach_dev(span);
			}

			run_all(dispose);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_else_block$1.name, type: "else", source: "(228:6) {:else}", ctx });
	return block;
}

// (216:6) {#if component === editing}
function create_if_block_2(ctx) {
	var span, t0_value = ctx.editing.name + (/\./.test(ctx.editing.name) ? '' : `.${ctx.editing.type}`) + "", t0, t1, input, dispose;

	const block = {
		c: function create() {
			span = element("span");
			t0 = text(t0_value);
			t1 = space();
			input = element("input");
			this.h();
		},

		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true }, false);
			var span_nodes = children(span);

			t0 = claim_text(span_nodes, t0_value);
			span_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);

			input = claim_element(nodes, "INPUT", { autofocus: true, spellcheck: true, class: true }, false);
			var input_nodes = children(input);

			input_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(span, "class", "input-sizer svelte-1wzo3es");
			add_location(span, file$3, 216, 7, 4283);
			input.autofocus = true;
			attr_dev(input, "spellcheck", false);
			attr_dev(input, "class", "svelte-1wzo3es");
			add_location(input, file$3, 219, 7, 4438);

			dispose = [
				listen_dev(input, "input", ctx.input_input_handler),
				listen_dev(input, "focus", selectInput),
				listen_dev(input, "blur", ctx.closeEdit),
				listen_dev(input, "keydown", keydown_handler)
			];
		},

		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t0);
			insert_dev(target, t1, anchor);
			insert_dev(target, input, anchor);

			set_input_value(input, ctx.editing.name);

			input.focus();
		},

		p: function update(changed, ctx) {
			if ((changed.editing) && t0_value !== (t0_value = ctx.editing.name + (/\./.test(ctx.editing.name) ? '' : `.${ctx.editing.type}`) + "")) {
				set_data_dev(t0, t0_value);
			}

			if (changed.editing && (input.value !== ctx.editing.name)) set_input_value(input, ctx.editing.name);
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(span);
				detach_dev(t1);
				detach_dev(input);
			}

			run_all(dispose);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_2.name, type: "if", source: "(216:6) {#if component === editing}", ctx });
	return block;
}

// (211:5) {#if component.name == 'App'}
function create_if_block_1$1(ctx) {
	var div, t;

	const block = {
		c: function create() {
			div = element("div");
			t = text("App.svelte");
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true }, false);
			var div_nodes = children(div);

			t = claim_text(div_nodes, "App.svelte");
			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(div, "class", "uneditable svelte-1wzo3es");
			add_location(div, file$3, 211, 6, 4173);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t);
		},

		p: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_1$1.name, type: "if", source: "(211:5) {#if component.name == 'App'}", ctx });
	return block;
}

// (202:3) {#each $components as component}
function create_each_block(ctx) {
	var div, div_id_value, dispose;

	function select_block_type(changed, ctx) {
		if (ctx.component.name == 'App') return create_if_block_1$1;
		if (ctx.component === ctx.editing) return create_if_block_2;
		return create_else_block$1;
	}

	var current_block_type = select_block_type(null, ctx);
	var if_block = current_block_type(ctx);

	function click_handler_2() {
		return ctx.click_handler_2(ctx);
	}

	const block = {
		c: function create() {
			div = element("div");
			if_block.c();
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { id: true, class: true, role: true }, false);
			var div_nodes = children(div);

			if_block.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(div, "id", div_id_value = ctx.component.name);
			attr_dev(div, "class", "button svelte-1wzo3es");
			attr_dev(div, "role", "button");
			toggle_class(div, "active", ctx.component === ctx.$selected);
			add_location(div, file$3, 202, 4, 3914);

			dispose = [
				listen_dev(div, "click", click_handler_2),
				listen_dev(div, "dblclick", dblclick_handler)
			];
		},

		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if_block.m(div, null);
		},

		p: function update(changed, new_ctx) {
			ctx = new_ctx;
			if (current_block_type === (current_block_type = select_block_type(changed, ctx)) && if_block) {
				if_block.p(changed, ctx);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);
				if (if_block) {
					if_block.c();
					if_block.m(div, null);
				}
			}

			if ((changed.$components) && div_id_value !== (div_id_value = ctx.component.name)) {
				attr_dev(div, "id", div_id_value);
			}

			if ((changed.$components || changed.$selected)) {
				toggle_class(div, "active", ctx.component === ctx.$selected);
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			if_block.d();
			run_all(dispose);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_each_block.name, type: "each", source: "(202:3) {#each $components as component}", ctx });
	return block;
}

function create_fragment$3(ctx) {
	var div;

	var if_block = (ctx.$components.length) && create_if_block$3(ctx);

	const block = {
		c: function create() {
			div = element("div");
			if (if_block) if_block.c();
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true }, false);
			var div_nodes = children(div);

			if (if_block) if_block.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(div, "class", "component-selector svelte-1wzo3es");
			add_location(div, file$3, 198, 0, 3766);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block) if_block.m(div, null);
		},

		p: function update(changed, ctx) {
			if (ctx.$components.length) {
				if (if_block) {
					if_block.p(changed, ctx);
				} else {
					if_block = create_if_block$3(ctx);
					if_block.c();
					if_block.m(div, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},

		i: noop,
		o: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			if (if_block) if_block.d();
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$3.name, type: "component", source: "", ctx });
	return block;
}

function selectInput(event) {
	setTimeout(() => {
		event.target.select();
	});
}

const keydown_handler = (e) => e.which === 13 && e.target.blur();

const dblclick_handler = (e) => e.stopPropagation();

function instance$3($$self, $$props, $$invalidate) {
	let $selected, $components, $$unsubscribe_components = noop, $$subscribe_components = () => ($$unsubscribe_components(), $$unsubscribe_components = subscribe(components, $$value => { $components = $$value; $$invalidate('$components', $components); }), components);

	$$self.$$.on_destroy.push(() => $$unsubscribe_components());

	let { handle_select } = $$props;

	const { components, selected, request_focus, rebundle } = getContext('REPL'); $$subscribe_components(); validate_store(selected, 'selected'); component_subscribe($$self, selected, $$value => { $selected = $$value; $$invalidate('$selected', $selected); });

	let editing = null;

	function selectComponent(component) {
		if ($selected !== component) {
			$$invalidate('editing', editing = null);
			handle_select(component);
		}
	}

	function editTab(component) {
		if ($selected === component) {
			$$invalidate('editing', editing = $selected);
		}
	}

	function closeEdit() {
		const match = /(.+)\.(svelte|js)$/.exec($selected.name);
		set_store_value(selected, $selected.name = match ? match[1] : $selected.name, $selected);
		if (match && match[2]) set_store_value(selected, $selected.type = match[2], $selected);
		$$invalidate('editing', editing = null);

		// re-select, in case the type changed
		handle_select($selected);

		$$subscribe_components($$invalidate('components', components)); // TODO necessary?

		// focus the editor, but wait a beat (so key events aren't misdirected)
		setTimeout(request_focus);

		rebundle();
	}

	function remove(component) {
		let result = confirm(`Are you sure you want to delete ${component.name}.${component.type}?`);

		if (result) {
			const index = $components.indexOf(component);

			if (~index) {
				components.set($components.slice(0, index).concat($components.slice(index + 1)));
			} else {
				console.error(`Could not find component! That's... odd`);
			}

			handle_select($components[index] || $components[$components.length - 1]);
		}
	}

	let uid = 1;

	function addNew() {
		const component = {
			name: uid++ ? `Component${uid}` : 'Component1',
			type: 'svelte',
			source: ''
		};

		$$invalidate('editing', editing = component);

		setTimeout(() => {
			// TODO we can do this without IDs
			document.getElementById(component.name).scrollIntoView(false);
		});

		components.update(components => components.concat(component));
		handle_select(component);
	}

	const writable_props = ['handle_select'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console_1.warn(`<ComponentSelector> was created with unknown prop '${key}'`);
	});

	function input_input_handler() {
		editing.name = this.value;
		$$invalidate('editing', editing);
	}

	const click_handler = ({ component }) => editTab(component);

	const click_handler_1 = ({ component }) => remove(component);

	const click_handler_2 = ({ component }) => selectComponent(component);

	$$self.$set = $$props => {
		if ('handle_select' in $$props) $$invalidate('handle_select', handle_select = $$props.handle_select);
	};

	$$self.$capture_state = () => {
		return { handle_select, editing, uid, $selected, $components };
	};

	$$self.$inject_state = $$props => {
		if ('handle_select' in $$props) $$invalidate('handle_select', handle_select = $$props.handle_select);
		if ('editing' in $$props) $$invalidate('editing', editing = $$props.editing);
		if ('uid' in $$props) uid = $$props.uid;
		if ('$selected' in $$props) selected.set($selected);
		if ('$components' in $$props) components.set($components);
	};

	return {
		handle_select,
		components,
		selected,
		editing,
		selectComponent,
		editTab,
		closeEdit,
		remove,
		addNew,
		$selected,
		$components,
		input_input_handler,
		click_handler,
		click_handler_1,
		click_handler_2
	};
}

class ComponentSelector extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$3, safe_not_equal, ["handle_select"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "ComponentSelector", options, id: create_fragment$3.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.handle_select === undefined && !('handle_select' in props)) {
			console_1.warn("<ComponentSelector> was created without expected prop 'handle_select'");
		}
	}

	get handle_select() {
		throw new Error("<ComponentSelector>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set handle_select(value) {
		throw new Error("<ComponentSelector>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\@sveltejs\svelte-repl\src\Input\ModuleEditor.svelte generated by Svelte v3.12.0 */

const file$4 = "node_modules\\@sveltejs\\svelte-repl\\src\\Input\\ModuleEditor.svelte";

function get_each_context$1(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.warning = list[i];
	return child_ctx;
}

// (51:2) {#if $bundle}
function create_if_block$4(ctx) {
	var current_block_type_index, if_block, if_block_anchor, current;

	var if_block_creators = [
		create_if_block_1$2,
		create_if_block_2$1
	];

	var if_blocks = [];

	function select_block_type(changed, ctx) {
		if (ctx.$bundle.error) return 0;
		if (ctx.$bundle.warnings.length > 0) return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(null, ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},

		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},

		m: function mount(target, anchor) {
			if (~current_block_type_index) if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(changed, ctx);
			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) if_blocks[current_block_type_index].p(changed, ctx);
			} else {
				if (if_block) {
					group_outros();
					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});
					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];
					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					}
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				} else {
					if_block = null;
				}
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},

		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},

		d: function destroy(detaching) {
			if (~current_block_type_index) if_blocks[current_block_type_index].d(detaching);

			if (detaching) {
				detach_dev(if_block_anchor);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block$4.name, type: "if", source: "(51:2) {#if $bundle}", ctx });
	return block;
}

// (54:41) 
function create_if_block_2$1(ctx) {
	var each_1_anchor, current;

	let each_value = ctx.$bundle.warnings;

	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},

		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},

		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			if (changed.$bundle || changed.$selected) {
				each_value = ctx.$bundle.warnings;

				let i;
				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(changed, child_ctx);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();
				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}
				check_outros();
			}
		},

		i: function intro(local) {
			if (current) return;
			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},

		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},

		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);

			if (detaching) {
				detach_dev(each_1_anchor);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_2$1.name, type: "if", source: "(54:41) ", ctx });
	return block;
}

// (52:3) {#if $bundle.error}
function create_if_block_1$2(ctx) {
	var current;

	var message = new Message({
		props: {
		kind: "error",
		details: ctx.$bundle.error,
		filename: "" + ctx.$selected.name + "." + ctx.$selected.type
	},
		$$inline: true
	});

	const block = {
		c: function create() {
			message.$$.fragment.c();
		},

		l: function claim(nodes) {
			message.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(message, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var message_changes = {};
			if (changed.$bundle) message_changes.details = ctx.$bundle.error;
			if (changed.$selected) message_changes.filename = "" + ctx.$selected.name + "." + ctx.$selected.type;
			message.$set(message_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(message.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(message.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(message, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_1$2.name, type: "if", source: "(52:3) {#if $bundle.error}", ctx });
	return block;
}

// (55:4) {#each $bundle.warnings as warning}
function create_each_block$1(ctx) {
	var current;

	var message = new Message({
		props: {
		kind: "warning",
		details: ctx.warning,
		filename: "" + ctx.$selected.name + "." + ctx.$selected.type
	},
		$$inline: true
	});

	const block = {
		c: function create() {
			message.$$.fragment.c();
		},

		l: function claim(nodes) {
			message.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(message, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var message_changes = {};
			if (changed.$bundle) message_changes.details = ctx.warning;
			if (changed.$selected) message_changes.filename = "" + ctx.$selected.name + "." + ctx.$selected.type;
			message.$set(message_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(message.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(message.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(message, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_each_block$1.name, type: "each", source: "(55:4) {#each $bundle.warnings as warning}", ctx });
	return block;
}

function create_fragment$4(ctx) {
	var div2, div0, t, div1, current;

	let codemirror_props = { errorLoc: ctx.errorLoc };
	var codemirror = new CodeMirror_1({ props: codemirror_props, $$inline: true });

	ctx.codemirror_binding(codemirror);
	codemirror.$on("change", ctx.handle_change);

	var if_block = (ctx.$bundle) && create_if_block$4(ctx);

	const block = {
		c: function create() {
			div2 = element("div");
			div0 = element("div");
			codemirror.$$.fragment.c();
			t = space();
			div1 = element("div");
			if (if_block) if_block.c();
			this.h();
		},

		l: function claim(nodes) {
			div2 = claim_element(nodes, "DIV", { class: true }, false);
			var div2_nodes = children(div2);

			div0 = claim_element(div2_nodes, "DIV", { class: true }, false);
			var div0_nodes = children(div0);

			codemirror.$$.fragment.l(div0_nodes);
			div0_nodes.forEach(detach_dev);
			t = claim_space(div2_nodes);

			div1 = claim_element(div2_nodes, "DIV", { class: true }, false);
			var div1_nodes = children(div1);

			if (if_block) if_block.l(div1_nodes);
			div1_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(div0, "class", "editor svelte-jozebv");
			add_location(div0, file$4, 41, 1, 756);
			attr_dev(div1, "class", "info");
			add_location(div1, file$4, 49, 1, 871);
			attr_dev(div2, "class", "editor-wrapper svelte-jozebv");
			add_location(div2, file$4, 40, 0, 726);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, div0);
			mount_component(codemirror, div0, null);
			append_dev(div2, t);
			append_dev(div2, div1);
			if (if_block) if_block.m(div1, null);
			current = true;
		},

		p: function update(changed, ctx) {
			var codemirror_changes = {};
			if (changed.errorLoc) codemirror_changes.errorLoc = ctx.errorLoc;
			codemirror.$set(codemirror_changes);

			if (ctx.$bundle) {
				if (if_block) {
					if_block.p(changed, ctx);
					transition_in(if_block, 1);
				} else {
					if_block = create_if_block$4(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div1, null);
				}
			} else if (if_block) {
				group_outros();
				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});
				check_outros();
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(codemirror.$$.fragment, local);

			transition_in(if_block);
			current = true;
		},

		o: function outro(local) {
			transition_out(codemirror.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div2);
			}

			ctx.codemirror_binding(null);

			destroy_component(codemirror);

			if (if_block) if_block.d();
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$4.name, type: "component", source: "", ctx });
	return block;
}

function instance$4($$self, $$props, $$invalidate) {
	let $bundle, $selected;

	

	const { bundle, selected, handle_change, navigate, register_module_editor } = getContext('REPL'); validate_store(bundle, 'bundle'); component_subscribe($$self, bundle, $$value => { $bundle = $$value; $$invalidate('$bundle', $bundle); }); validate_store(selected, 'selected'); component_subscribe($$self, selected, $$value => { $selected = $$value; $$invalidate('$selected', $selected); });

	let { errorLoc } = $$props;

	let editor;
	onMount(() => {
		register_module_editor(editor);
	});

	function focus() {
		editor.focus();
	}

	const writable_props = ['errorLoc'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<ModuleEditor> was created with unknown prop '${key}'`);
	});

	function codemirror_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			$$invalidate('editor', editor = $$value);
		});
	}

	$$self.$set = $$props => {
		if ('errorLoc' in $$props) $$invalidate('errorLoc', errorLoc = $$props.errorLoc);
	};

	$$self.$capture_state = () => {
		return { errorLoc, editor, $bundle, $selected };
	};

	$$self.$inject_state = $$props => {
		if ('errorLoc' in $$props) $$invalidate('errorLoc', errorLoc = $$props.errorLoc);
		if ('editor' in $$props) $$invalidate('editor', editor = $$props.editor);
		if ('$bundle' in $$props) bundle.set($bundle);
		if ('$selected' in $$props) selected.set($selected);
	};

	return {
		bundle,
		selected,
		handle_change,
		errorLoc,
		editor,
		focus,
		$bundle,
		$selected,
		codemirror_binding
	};
}

class ModuleEditor extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4, create_fragment$4, safe_not_equal, ["errorLoc", "focus"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "ModuleEditor", options, id: create_fragment$4.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.errorLoc === undefined && !('errorLoc' in props)) {
			console.warn("<ModuleEditor> was created without expected prop 'errorLoc'");
		}
		if (ctx.focus === undefined && !('focus' in props)) {
			console.warn("<ModuleEditor> was created without expected prop 'focus'");
		}
	}

	get errorLoc() {
		throw new Error("<ModuleEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set errorLoc(value) {
		throw new Error("<ModuleEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get focus() {
		return this.$$.ctx.focus;
	}

	set focus(value) {
		throw new Error("<ModuleEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

var charToInteger = {};
var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
for (var i = 0; i < chars.length; i++) {
    charToInteger[chars.charCodeAt(i)] = i;
}
function decode(mappings) {
    var generatedCodeColumn = 0; // first field
    var sourceFileIndex = 0; // second field
    var sourceCodeLine = 0; // third field
    var sourceCodeColumn = 0; // fourth field
    var nameIndex = 0; // fifth field
    var decoded = [];
    var line = [];
    var segment = [];
    for (var i = 0, j = 0, shift = 0, value = 0, len = mappings.length; i < len; i++) {
        var c = mappings.charCodeAt(i);
        if (c === 44) { // ","
            if (segment.length)
                line.push(segment);
            segment = [];
            j = 0;
        }
        else if (c === 59) { // ";"
            if (segment.length)
                line.push(segment);
            segment = [];
            j = 0;
            decoded.push(line);
            line = [];
            generatedCodeColumn = 0;
        }
        else {
            var integer = charToInteger[c];
            if (integer === undefined) {
                throw new Error('Invalid character (' + String.fromCharCode(c) + ')');
            }
            var hasContinuationBit = integer & 32;
            integer &= 31;
            value += integer << shift;
            if (hasContinuationBit) {
                shift += 5;
            }
            else {
                var shouldNegate = value & 1;
                value >>>= 1;
                if (shouldNegate) {
                    value = -value;
                    if (value === 0)
                        value = -0x80000000;
                }
                if (j == 0) {
                    generatedCodeColumn += value;
                    segment.push(generatedCodeColumn);
                }
                else if (j === 1) {
                    sourceFileIndex += value;
                    segment.push(sourceFileIndex);
                }
                else if (j === 2) {
                    sourceCodeLine += value;
                    segment.push(sourceCodeLine);
                }
                else if (j === 3) {
                    sourceCodeColumn += value;
                    segment.push(sourceCodeColumn);
                }
                else if (j === 4) {
                    nameIndex += value;
                    segment.push(nameIndex);
                }
                j++;
                value = shift = 0; // reset
            }
        }
    }
    if (segment.length)
        line.push(segment);
    decoded.push(line);
    return decoded;
}

function getLocationFromStack(stack, map) {
	if (!stack) return;
	const last = stack.split('\n')[1];
	const match = /<anonymous>:(\d+):(\d+)\)$/.exec(last);

	if (!match) return null;

	const line = +match[1];
	const column = +match[2];

	return trace({ line, column }, map);
}

function trace(loc, map) {
	const mappings = decode(map.mappings);
	const segments = mappings[loc.line - 1];

	for (let i = 0; i < segments.length; i += 1) {
		const segment = segments[i];
		if (segment[0] === loc.column) {
			const [, sourceIndex, line, column] = segment;
			const source = map.sources[sourceIndex].slice(2);

			return { source, line: line + 1, column };
		}
	}

	return null;
}

let uid = 1;

class ReplProxy {
	constructor(iframe, handlers) {
		this.iframe = iframe;
		this.handlers = handlers;

		this.pending_cmds = new Map();

		this.handle_event = e => this.handle_repl_message(e);
		window.addEventListener('message', this.handle_event, false);
	}

	destroy() {
		window.removeEventListener('message', this.handle_event);
	}

	iframe_command(action, args) {
		return new Promise((resolve, reject) => {
			const cmd_id = uid++;

			this.pending_cmds.set(cmd_id, { resolve, reject });

			this.iframe.contentWindow.postMessage({ action, cmd_id, args }, '*');
		});
	}

	handle_command_message(cmd_data) {
		let action = cmd_data.action;
		let id = cmd_data.cmd_id;
		let handler = this.pending_cmds.get(id);

		if (handler) {
			this.pending_cmds.delete(id);
			if (action === 'cmd_error') {
				let { message, stack } = cmd_data;
				let e = new Error(message);
				e.stack = stack;
				handler.reject(e);
			}

			if (action === 'cmd_ok') {
				handler.resolve(cmd_data.args);
			}
		} else {
			console.error('command not found', id, cmd_data, [...this.pending_cmds.keys()]);
		}
	}

	handle_repl_message(event) {
		if (event.source !== this.iframe.contentWindow) return;

		const { action, args } = event.data;

		if (action === 'cmd_error' || action === 'cmd_ok') {
			this.handle_command_message(event.data);
		}

		if (action === 'fetch_progress') {
			this.handlers.on_fetch_progress(args.remaining);
		}
	}

	eval(script) {
		return this.iframe_command('eval', { script });
	}

	handle_links() {
		return this.iframe_command('catch_clicks', {});
	}
}

var srcdoc = "<!doctype html>\n<html>\n\t<head>\n\t\t<style>\n\t\t\thtml, body {\n\tposition: relative;\n\twidth: 100%;\n\theight: 100%;\n}\n\nbody {\n\tcolor: #333;\n\tmargin: 0;\n\tpadding: 8px;\n\tbox-sizing: border-box;\n\tfont-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Oxygen-Sans, Ubuntu, Cantarell, \"Helvetica Neue\", sans-serif;\n}\n\na {\n\tcolor: rgb(0,100,200);\n\ttext-decoration: none;\n}\n\na:hover {\n\ttext-decoration: underline;\n}\n\na:visited {\n\tcolor: rgb(0,80,160);\n}\n\nlabel {\n\tdisplay: block;\n}\n\ninput, button, select, textarea {\n\tfont-family: inherit;\n\tfont-size: inherit;\n\tpadding: 0.4em;\n\tmargin: 0 0 0.5em 0;\n\tbox-sizing: border-box;\n\tborder: 1px solid #ccc;\n\tborder-radius: 2px;\n}\n\ninput:disabled {\n\tcolor: #ccc;\n}\n\ninput[type=\"range\"] {\n\theight: 0;\n}\n\nbutton {\n\tbackground-color: #f4f4f4;\n\toutline: none;\n}\n\nbutton:active {\n\tbackground-color: #ddd;\n}\n\nbutton:focus {\n\tborder-color: #666;\n}\n\t\t</style>\n\n\t\t<script>\n\t\t\t(function(){\n\t\t\t\tfunction handle_message(ev) {\n\t\t\t\t\tlet { action, cmd_id } = ev.data;\n\t\t\t\t\tconst send_message = (payload) => parent.postMessage( { ...payload }, ev.origin);\n\t\t\t\t\tconst send_reply = (payload) => send_message({ ...payload, cmd_id });\n\t\t\t\t\tconst send_ok = () => send_reply({ action: 'cmd_ok' });\n\t\t\t\t\tconst send_error = (message, stack) => send_reply({ action: 'cmd_error', message, stack });\n\n\t\t\t\t\tif (action === 'eval') {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst { script } = ev.data.args;\n\t\t\t\t\t\t\teval(script);\n\t\t\t\t\t\t\tsend_ok();\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tsend_error(e.message, e.stack);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (action === 'catch_clicks') {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst top_origin = ev.origin;\n\t\t\t\t\t\t\tdocument.body.addEventListener('click', event => {\n\t\t\t\t\t\t\t\tif (event.which !== 1) return;\n\t\t\t\t\t\t\t\tif (event.metaKey || event.ctrlKey || event.shiftKey) return;\n\t\t\t\t\t\t\t\tif (event.defaultPrevented) return;\n\n\t\t\t\t\t\t\t\t// ensure target is a link\n\t\t\t\t\t\t\t\tlet el = event.target;\n\t\t\t\t\t\t\t\twhile (el && el.nodeName !== 'A') el = el.parentNode;\n\t\t\t\t\t\t\t\tif (!el || el.nodeName !== 'A') return;\n\n\t\t\t\t\t\t\t\tif (el.hasAttribute('download') || el.getAttribute('rel') === 'external' || el.target) return;\n\n\t\t\t\t\t\t\t\tevent.preventDefault();\n\n\t\t\t\t\t\t\t\tif (el.href.startsWith(top_origin)) {\n\t\t\t\t\t\t\t\t\tconst url = new URL(el.href);\n\t\t\t\t\t\t\t\t\tif (url.hash[0] === '#') {\n\t\t\t\t\t\t\t\t\t\twindow.location.hash = url.hash;\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\twindow.open(el.href, '_blank');\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tsend_ok();\n\t\t\t\t\t\t} catch(e) {\n\t\t\t\t\t\t\tsend_error(e.message, e.stack);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\twindow.addEventListener('message', handle_message, false);\n\t\t\t}).call(this);\n\t\t</script>\n\t</head>\n\t<body></body>\n</html>";

/* node_modules\@sveltejs\svelte-repl\src\Output\Viewer.svelte generated by Svelte v3.12.0 */

const file$5 = "node_modules\\@sveltejs\\svelte-repl\\src\\Output\\Viewer.svelte";

// (148:31) 
function create_if_block_1$3(ctx) {
	var current;

	var message = new Message({
		props: {
		kind: "info",
		truncate: true,
		$$slots: { default: [create_default_slot$1] },
		$$scope: { ctx }
	},
		$$inline: true
	});

	const block = {
		c: function create() {
			message.$$.fragment.c();
		},

		l: function claim(nodes) {
			message.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(message, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var message_changes = {};
			if (changed.$$scope || changed.status) message_changes.$$scope = { changed, ctx };
			message.$set(message_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(message.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(message.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(message, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_1$3.name, type: "if", source: "(148:31) ", ctx });
	return block;
}

// (146:2) {#if error}
function create_if_block$5(ctx) {
	var current;

	var message = new Message({
		props: { kind: "error", details: ctx.error },
		$$inline: true
	});

	const block = {
		c: function create() {
			message.$$.fragment.c();
		},

		l: function claim(nodes) {
			message.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(message, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var message_changes = {};
			if (changed.error) message_changes.details = ctx.error;
			message.$set(message_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(message.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(message.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(message, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block$5.name, type: "if", source: "(146:2) {#if error}", ctx });
	return block;
}

// (149:3) <Message kind="info" truncate>
function create_default_slot$1(ctx) {
	var t_value = ctx.status || 'loading Svelte compiler...' + "", t;

	const block = {
		c: function create() {
			t = text(t_value);
		},

		l: function claim(nodes) {
			t = claim_text(nodes, t_value);
		},

		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},

		p: function update(changed, ctx) {
			if ((changed.status) && t_value !== (t_value = ctx.status || 'loading Svelte compiler...' + "")) {
				set_data_dev(t, t_value);
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_default_slot$1.name, type: "slot", source: "(149:3) <Message kind=\"info\" truncate>", ctx });
	return block;
}

function create_fragment$5(ctx) {
	var div1, iframe_1, iframe_1_sandbox_value, iframe_1_class_value, t, div0, current_block_type_index, if_block, current;

	var if_block_creators = [
		create_if_block$5,
		create_if_block_1$3
	];

	var if_blocks = [];

	function select_block_type(changed, ctx) {
		if (ctx.error) return 0;
		if (ctx.status || !ctx.$bundle) return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(null, ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	const block = {
		c: function create() {
			div1 = element("div");
			iframe_1 = element("iframe");
			t = space();
			div0 = element("div");
			if (if_block) if_block.c();
			this.h();
		},

		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true }, false);
			var div1_nodes = children(div1);

			iframe_1 = claim_element(div1_nodes, "IFRAME", { title: true, sandbox: true, class: true, srcdoc: true }, false);
			var iframe_1_nodes = children(iframe_1);

			iframe_1_nodes.forEach(detach_dev);
			t = claim_space(div1_nodes);

			div0 = claim_element(div1_nodes, "DIV", { class: true }, false);
			var div0_nodes = children(div0);

			if (if_block) if_block.l(div0_nodes);
			div0_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(iframe_1, "title", "Result");
			attr_dev(iframe_1, "sandbox", iframe_1_sandbox_value = "allow-popups-to-escape-sandbox allow-scripts allow-popups allow-forms allow-pointer-lock allow-top-navigation allow-modals " + (ctx.relaxed ? 'allow-same-origin' : ''));
			attr_dev(iframe_1, "class", iframe_1_class_value = "" + null_to_empty((ctx.error || pending || ctx.pending_imports ? 'greyed-out' : '')) + " svelte-16cfj92");
			attr_dev(iframe_1, "srcdoc", srcdoc);
			toggle_class(iframe_1, "inited", ctx.inited);
			add_location(iframe_1, file$5, 135, 1, 2626);
			attr_dev(div0, "class", "overlay svelte-16cfj92");
			add_location(div0, file$5, 144, 1, 2952);
			attr_dev(div1, "class", "iframe-container svelte-16cfj92");
			add_location(div1, file$5, 134, 0, 2594);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, iframe_1);
			ctx.iframe_1_binding(iframe_1);
			append_dev(div1, t);
			append_dev(div1, div0);
			if (~current_block_type_index) if_blocks[current_block_type_index].m(div0, null);
			current = true;
		},

		p: function update(changed, ctx) {
			if ((!current || changed.relaxed) && iframe_1_sandbox_value !== (iframe_1_sandbox_value = "allow-popups-to-escape-sandbox allow-scripts allow-popups allow-forms allow-pointer-lock allow-top-navigation allow-modals " + (ctx.relaxed ? 'allow-same-origin' : ''))) {
				attr_dev(iframe_1, "sandbox", iframe_1_sandbox_value);
			}

			if ((!current || changed.error || changed.pending_imports) && iframe_1_class_value !== (iframe_1_class_value = "" + null_to_empty((ctx.error || pending || ctx.pending_imports ? 'greyed-out' : '')) + " svelte-16cfj92")) {
				attr_dev(iframe_1, "class", iframe_1_class_value);
			}

			if ((changed.error || changed.pending_imports || changed.inited)) {
				toggle_class(iframe_1, "inited", ctx.inited);
			}

			var previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(changed, ctx);
			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) if_blocks[current_block_type_index].p(changed, ctx);
			} else {
				if (if_block) {
					group_outros();
					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});
					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];
					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					}
					transition_in(if_block, 1);
					if_block.m(div0, null);
				} else {
					if_block = null;
				}
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},

		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div1);
			}

			ctx.iframe_1_binding(null);
			if (~current_block_type_index) if_blocks[current_block_type_index].d();
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$5.name, type: "component", source: "", ctx });
	return block;
}

let pending = false;

function instance$5($$self, $$props, $$invalidate) {
	let $bundle;
	const { bundle, navigate } = getContext('REPL'); validate_store(bundle, 'bundle'); component_subscribe($$self, bundle, $$value => { $bundle = $$value; $$invalidate('$bundle', $bundle); });

	let { error } = $$props; // TODO should this be exposed as a prop?

	function setProp(prop, value) {
		if (!proxy) return;
		proxy.setProp(prop, value);
	}

	let { status, relaxed = false, injectedJS = '', injectedCSS = '' } = $$props;

	let iframe;
	let pending_imports = 0;

	let proxy = null;

	let ready = false;
	let inited = false;

	onMount(() => {
		proxy = new ReplProxy(iframe, {
			on_fetch_progress: progress => {
				$$invalidate('pending_imports', pending_imports = progress);
			}
		});

		iframe.addEventListener('load', () => {
			proxy.handle_links();
			$$invalidate('ready', ready = true);
		});

		return () => {
			proxy.destroy();
		}
	});

	async function apply_bundle($bundle) {
		if (!$bundle || $bundle.error) return;

		try {
			await proxy.eval(`
				${injectedJS}

				${styles}

				const styles = document.querySelectorAll('style[id^=svelte-]');

				${$bundle.dom.code}

				let i = styles.length;
				while (i--) styles[i].parentNode.removeChild(styles[i]);

				if (window.component) {
					try {
						window.component.$destroy();
					} catch (err) {
						console.error(err);
					}
				}

				document.body.innerHTML = '';
				window.location.hash = '';
				window._svelteTransitionManager = null;

				window.component = new SvelteComponent.default({
					target: document.body
				});
			`);

			$$invalidate('error', error = null);
		} catch (e) {
			const loc = getLocationFromStack(e.stack, $bundle.dom.map);
			if (loc) {
				e.filename = loc.source;
				e.loc = { line: loc.line, column: loc.column };
			}

			$$invalidate('error', error = e);
		}

		$$invalidate('inited', inited = true);
	}

	const writable_props = ['error', 'status', 'relaxed', 'injectedJS', 'injectedCSS'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Viewer> was created with unknown prop '${key}'`);
	});

	function iframe_1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			$$invalidate('iframe', iframe = $$value);
		});
	}

	$$self.$set = $$props => {
		if ('error' in $$props) $$invalidate('error', error = $$props.error);
		if ('status' in $$props) $$invalidate('status', status = $$props.status);
		if ('relaxed' in $$props) $$invalidate('relaxed', relaxed = $$props.relaxed);
		if ('injectedJS' in $$props) $$invalidate('injectedJS', injectedJS = $$props.injectedJS);
		if ('injectedCSS' in $$props) $$invalidate('injectedCSS', injectedCSS = $$props.injectedCSS);
	};

	$$self.$capture_state = () => {
		return { error, status, relaxed, injectedJS, injectedCSS, iframe, pending_imports, pending, proxy, ready, inited, styles, $bundle };
	};

	$$self.$inject_state = $$props => {
		if ('error' in $$props) $$invalidate('error', error = $$props.error);
		if ('status' in $$props) $$invalidate('status', status = $$props.status);
		if ('relaxed' in $$props) $$invalidate('relaxed', relaxed = $$props.relaxed);
		if ('injectedJS' in $$props) $$invalidate('injectedJS', injectedJS = $$props.injectedJS);
		if ('injectedCSS' in $$props) $$invalidate('injectedCSS', injectedCSS = $$props.injectedCSS);
		if ('iframe' in $$props) $$invalidate('iframe', iframe = $$props.iframe);
		if ('pending_imports' in $$props) $$invalidate('pending_imports', pending_imports = $$props.pending_imports);
		if ('pending' in $$props) $$invalidate('pending', pending = $$props.pending);
		if ('proxy' in $$props) proxy = $$props.proxy;
		if ('ready' in $$props) $$invalidate('ready', ready = $$props.ready);
		if ('inited' in $$props) $$invalidate('inited', inited = $$props.inited);
		if ('styles' in $$props) styles = $$props.styles;
		if ('$bundle' in $$props) bundle.set($bundle);
	};

	let styles;

	$$self.$$.update = ($$dirty = { ready: 1, $bundle: 1, injectedCSS: 1 }) => {
		if ($$dirty.ready || $$dirty.$bundle) { if (ready) apply_bundle($bundle); }
		if ($$dirty.injectedCSS) { styles = injectedCSS && `{
		const style = document.createElement('style');
		style.textContent = ${JSON.stringify(injectedCSS)};
		document.head.appendChild(style);
	}`; }
	};

	return {
		bundle,
		error,
		setProp,
		status,
		relaxed,
		injectedJS,
		injectedCSS,
		iframe,
		pending_imports,
		inited,
		$bundle,
		iframe_1_binding
	};
}

class Viewer extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$5, create_fragment$5, safe_not_equal, ["error", "setProp", "status", "relaxed", "injectedJS", "injectedCSS"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "Viewer", options, id: create_fragment$5.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.error === undefined && !('error' in props)) {
			console.warn("<Viewer> was created without expected prop 'error'");
		}
		if (ctx.setProp === undefined && !('setProp' in props)) {
			console.warn("<Viewer> was created without expected prop 'setProp'");
		}
		if (ctx.status === undefined && !('status' in props)) {
			console.warn("<Viewer> was created without expected prop 'status'");
		}
	}

	get error() {
		throw new Error("<Viewer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set error(value) {
		throw new Error("<Viewer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get setProp() {
		return this.$$.ctx.setProp;
	}

	set setProp(value) {
		throw new Error("<Viewer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get status() {
		throw new Error("<Viewer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set status(value) {
		throw new Error("<Viewer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get relaxed() {
		throw new Error("<Viewer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set relaxed(value) {
		throw new Error("<Viewer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get injectedJS() {
		throw new Error("<Viewer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set injectedJS(value) {
		throw new Error("<Viewer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get injectedCSS() {
		throw new Error("<Viewer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set injectedCSS(value) {
		throw new Error("<Viewer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\@sveltejs\svelte-repl\src\Output\CompilerOptions.svelte generated by Svelte v3.12.0 */

const file$6 = "node_modules\\@sveltejs\\svelte-repl\\src\\Output\\CompilerOptions.svelte";

function create_fragment$6(ctx) {
	var div1, t0, div0, span0, t1, t2, input0, t3, label0, span1, t4, t5, input1, t6, label1, span2, t7, t8, t9, label2, span3, t10, t11, input2, t12, span4, t13_value = ctx.$compile_options.dev + "", t13, t14, t15, label3, span5, t16, t17, input3, t18, span6, t19_value = ctx.$compile_options.css + "", t19, t20, t21, label4, span7, t22, t23, input4, t24, span8, t25_value = ctx.$compile_options.hydratable + "", t25, t26, t27, label5, span9, t28, t29, input5, t30, span10, t31_value = ctx.$compile_options.customElement + "", t31, t32, t33, label6, span11, t34, t35, input6, t36, span12, t37_value = ctx.$compile_options.immutable + "", t37, t38, t39, label7, span13, t40, t41, input7, t42, span14, t43_value = ctx.$compile_options.legacy + "", t43, t44, dispose;

	const block = {
		c: function create() {
			div1 = element("div");
			t0 = text("result = svelte.compile(source, {\n\t");
			div0 = element("div");
			span0 = element("span");
			t1 = text("generate:");
			t2 = space();
			input0 = element("input");
			t3 = space();
			label0 = element("label");
			span1 = element("span");
			t4 = text("\"dom\"");
			t5 = space();
			input1 = element("input");
			t6 = space();
			label1 = element("label");
			span2 = element("span");
			t7 = text("\"ssr\"");
			t8 = text(",");
			t9 = space();
			label2 = element("label");
			span3 = element("span");
			t10 = text("dev:");
			t11 = space();
			input2 = element("input");
			t12 = space();
			span4 = element("span");
			t13 = text(t13_value);
			t14 = text(",");
			t15 = space();
			label3 = element("label");
			span5 = element("span");
			t16 = text("css:");
			t17 = space();
			input3 = element("input");
			t18 = space();
			span6 = element("span");
			t19 = text(t19_value);
			t20 = text(",");
			t21 = space();
			label4 = element("label");
			span7 = element("span");
			t22 = text("hydratable:");
			t23 = space();
			input4 = element("input");
			t24 = space();
			span8 = element("span");
			t25 = text(t25_value);
			t26 = text(",");
			t27 = space();
			label5 = element("label");
			span9 = element("span");
			t28 = text("customElement:");
			t29 = space();
			input5 = element("input");
			t30 = space();
			span10 = element("span");
			t31 = text(t31_value);
			t32 = text(",");
			t33 = space();
			label6 = element("label");
			span11 = element("span");
			t34 = text("immutable:");
			t35 = space();
			input6 = element("input");
			t36 = space();
			span12 = element("span");
			t37 = text(t37_value);
			t38 = text(",");
			t39 = space();
			label7 = element("label");
			span13 = element("span");
			t40 = text("legacy:");
			t41 = space();
			input7 = element("input");
			t42 = space();
			span14 = element("span");
			t43 = text(t43_value);
			t44 = text("\n\t});");
			this.h();
		},

		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true }, false);
			var div1_nodes = children(div1);

			t0 = claim_text(div1_nodes, "result = svelte.compile(source, {\n\t");

			div0 = claim_element(div1_nodes, "DIV", { class: true }, false);
			var div0_nodes = children(div0);

			span0 = claim_element(div0_nodes, "SPAN", { class: true }, false);
			var span0_nodes = children(span0);

			t1 = claim_text(span0_nodes, "generate:");
			span0_nodes.forEach(detach_dev);
			t2 = claim_space(div0_nodes);

			input0 = claim_element(div0_nodes, "INPUT", { id: true, type: true, value: true, class: true }, false);
			var input0_nodes = children(input0);

			input0_nodes.forEach(detach_dev);
			t3 = claim_space(div0_nodes);

			label0 = claim_element(div0_nodes, "LABEL", { for: true, class: true }, false);
			var label0_nodes = children(label0);

			span1 = claim_element(label0_nodes, "SPAN", { class: true }, false);
			var span1_nodes = children(span1);

			t4 = claim_text(span1_nodes, "\"dom\"");
			span1_nodes.forEach(detach_dev);
			label0_nodes.forEach(detach_dev);
			t5 = claim_space(div0_nodes);

			input1 = claim_element(div0_nodes, "INPUT", { id: true, type: true, value: true, class: true }, false);
			var input1_nodes = children(input1);

			input1_nodes.forEach(detach_dev);
			t6 = claim_space(div0_nodes);

			label1 = claim_element(div0_nodes, "LABEL", { for: true, class: true }, false);
			var label1_nodes = children(label1);

			span2 = claim_element(label1_nodes, "SPAN", { class: true }, false);
			var span2_nodes = children(span2);

			t7 = claim_text(span2_nodes, "\"ssr\"");
			span2_nodes.forEach(detach_dev);
			t8 = claim_text(label1_nodes, ",");
			label1_nodes.forEach(detach_dev);
			div0_nodes.forEach(detach_dev);
			t9 = claim_space(div1_nodes);

			label2 = claim_element(div1_nodes, "LABEL", { class: true }, false);
			var label2_nodes = children(label2);

			span3 = claim_element(label2_nodes, "SPAN", { class: true }, false);
			var span3_nodes = children(span3);

			t10 = claim_text(span3_nodes, "dev:");
			span3_nodes.forEach(detach_dev);
			t11 = claim_space(label2_nodes);

			input2 = claim_element(label2_nodes, "INPUT", { type: true, class: true }, false);
			var input2_nodes = children(input2);

			input2_nodes.forEach(detach_dev);
			t12 = claim_space(label2_nodes);

			span4 = claim_element(label2_nodes, "SPAN", { class: true }, false);
			var span4_nodes = children(span4);

			t13 = claim_text(span4_nodes, t13_value);
			span4_nodes.forEach(detach_dev);
			t14 = claim_text(label2_nodes, ",");
			label2_nodes.forEach(detach_dev);
			t15 = claim_space(div1_nodes);

			label3 = claim_element(div1_nodes, "LABEL", { class: true }, false);
			var label3_nodes = children(label3);

			span5 = claim_element(label3_nodes, "SPAN", { class: true }, false);
			var span5_nodes = children(span5);

			t16 = claim_text(span5_nodes, "css:");
			span5_nodes.forEach(detach_dev);
			t17 = claim_space(label3_nodes);

			input3 = claim_element(label3_nodes, "INPUT", { type: true, class: true }, false);
			var input3_nodes = children(input3);

			input3_nodes.forEach(detach_dev);
			t18 = claim_space(label3_nodes);

			span6 = claim_element(label3_nodes, "SPAN", { class: true }, false);
			var span6_nodes = children(span6);

			t19 = claim_text(span6_nodes, t19_value);
			span6_nodes.forEach(detach_dev);
			t20 = claim_text(label3_nodes, ",");
			label3_nodes.forEach(detach_dev);
			t21 = claim_space(div1_nodes);

			label4 = claim_element(div1_nodes, "LABEL", { class: true }, false);
			var label4_nodes = children(label4);

			span7 = claim_element(label4_nodes, "SPAN", { class: true }, false);
			var span7_nodes = children(span7);

			t22 = claim_text(span7_nodes, "hydratable:");
			span7_nodes.forEach(detach_dev);
			t23 = claim_space(label4_nodes);

			input4 = claim_element(label4_nodes, "INPUT", { type: true, class: true }, false);
			var input4_nodes = children(input4);

			input4_nodes.forEach(detach_dev);
			t24 = claim_space(label4_nodes);

			span8 = claim_element(label4_nodes, "SPAN", { class: true }, false);
			var span8_nodes = children(span8);

			t25 = claim_text(span8_nodes, t25_value);
			span8_nodes.forEach(detach_dev);
			t26 = claim_text(label4_nodes, ",");
			label4_nodes.forEach(detach_dev);
			t27 = claim_space(div1_nodes);

			label5 = claim_element(div1_nodes, "LABEL", { class: true }, false);
			var label5_nodes = children(label5);

			span9 = claim_element(label5_nodes, "SPAN", { class: true }, false);
			var span9_nodes = children(span9);

			t28 = claim_text(span9_nodes, "customElement:");
			span9_nodes.forEach(detach_dev);
			t29 = claim_space(label5_nodes);

			input5 = claim_element(label5_nodes, "INPUT", { type: true, class: true }, false);
			var input5_nodes = children(input5);

			input5_nodes.forEach(detach_dev);
			t30 = claim_space(label5_nodes);

			span10 = claim_element(label5_nodes, "SPAN", { class: true }, false);
			var span10_nodes = children(span10);

			t31 = claim_text(span10_nodes, t31_value);
			span10_nodes.forEach(detach_dev);
			t32 = claim_text(label5_nodes, ",");
			label5_nodes.forEach(detach_dev);
			t33 = claim_space(div1_nodes);

			label6 = claim_element(div1_nodes, "LABEL", { class: true }, false);
			var label6_nodes = children(label6);

			span11 = claim_element(label6_nodes, "SPAN", { class: true }, false);
			var span11_nodes = children(span11);

			t34 = claim_text(span11_nodes, "immutable:");
			span11_nodes.forEach(detach_dev);
			t35 = claim_space(label6_nodes);

			input6 = claim_element(label6_nodes, "INPUT", { type: true, class: true }, false);
			var input6_nodes = children(input6);

			input6_nodes.forEach(detach_dev);
			t36 = claim_space(label6_nodes);

			span12 = claim_element(label6_nodes, "SPAN", { class: true }, false);
			var span12_nodes = children(span12);

			t37 = claim_text(span12_nodes, t37_value);
			span12_nodes.forEach(detach_dev);
			t38 = claim_text(label6_nodes, ",");
			label6_nodes.forEach(detach_dev);
			t39 = claim_space(div1_nodes);

			label7 = claim_element(div1_nodes, "LABEL", { class: true }, false);
			var label7_nodes = children(label7);

			span13 = claim_element(label7_nodes, "SPAN", { class: true }, false);
			var span13_nodes = children(span13);

			t40 = claim_text(span13_nodes, "legacy:");
			span13_nodes.forEach(detach_dev);
			t41 = claim_space(label7_nodes);

			input7 = claim_element(label7_nodes, "INPUT", { type: true, class: true }, false);
			var input7_nodes = children(input7);

			input7_nodes.forEach(detach_dev);
			t42 = claim_space(label7_nodes);

			span14 = claim_element(label7_nodes, "SPAN", { class: true }, false);
			var span14_nodes = children(span14);

			t43 = claim_text(span14_nodes, t43_value);
			span14_nodes.forEach(detach_dev);
			label7_nodes.forEach(detach_dev);
			t44 = claim_text(div1_nodes, "\n\t});");
			div1_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(span0, "class", "key svelte-159cly1");
			add_location(span0, file$6, 107, 2, 1829);
			ctx.$$binding_groups[0].push(input0);
			attr_dev(input0, "id", "dom-input");
			attr_dev(input0, "type", "radio");
			input0.__value = "dom";
			input0.value = input0.__value;
			attr_dev(input0, "class", "svelte-159cly1");
			add_location(input0, file$6, 109, 2, 1867);
			attr_dev(span1, "class", "string svelte-159cly1");
			add_location(span1, file$6, 110, 25, 1979);
			attr_dev(label0, "for", "dom-input");
			attr_dev(label0, "class", "svelte-159cly1");
			add_location(label0, file$6, 110, 2, 1956);
			ctx.$$binding_groups[0].push(input1);
			attr_dev(input1, "id", "ssr-input");
			attr_dev(input1, "type", "radio");
			input1.__value = "ssr";
			input1.value = input1.__value;
			attr_dev(input1, "class", "svelte-159cly1");
			add_location(input1, file$6, 112, 2, 2024);
			attr_dev(span2, "class", "string svelte-159cly1");
			add_location(span2, file$6, 113, 25, 2136);
			attr_dev(label1, "for", "ssr-input");
			attr_dev(label1, "class", "svelte-159cly1");
			add_location(label1, file$6, 113, 2, 2113);
			attr_dev(div0, "class", "option svelte-159cly1");
			add_location(div0, file$6, 106, 1, 1806);
			attr_dev(span3, "class", "key svelte-159cly1");
			add_location(span3, file$6, 117, 2, 2214);
			attr_dev(input2, "type", "checkbox");
			attr_dev(input2, "class", "svelte-159cly1");
			add_location(input2, file$6, 118, 2, 2246);
			attr_dev(span4, "class", "boolean svelte-159cly1");
			add_location(span4, file$6, 118, 62, 2306);
			attr_dev(label2, "class", "option svelte-159cly1");
			add_location(label2, file$6, 116, 1, 2189);
			attr_dev(span5, "class", "key svelte-159cly1");
			add_location(span5, file$6, 122, 2, 2396);
			attr_dev(input3, "type", "checkbox");
			attr_dev(input3, "class", "svelte-159cly1");
			add_location(input3, file$6, 123, 2, 2428);
			attr_dev(span6, "class", "boolean svelte-159cly1");
			add_location(span6, file$6, 123, 62, 2488);
			attr_dev(label3, "class", "option svelte-159cly1");
			add_location(label3, file$6, 121, 1, 2371);
			attr_dev(span7, "class", "key svelte-159cly1");
			add_location(span7, file$6, 127, 2, 2578);
			attr_dev(input4, "type", "checkbox");
			attr_dev(input4, "class", "svelte-159cly1");
			add_location(input4, file$6, 128, 2, 2617);
			attr_dev(span8, "class", "boolean svelte-159cly1");
			add_location(span8, file$6, 128, 69, 2684);
			attr_dev(label4, "class", "option svelte-159cly1");
			add_location(label4, file$6, 126, 1, 2553);
			attr_dev(span9, "class", "key svelte-159cly1");
			add_location(span9, file$6, 132, 2, 2781);
			attr_dev(input5, "type", "checkbox");
			attr_dev(input5, "class", "svelte-159cly1");
			add_location(input5, file$6, 133, 2, 2823);
			attr_dev(span10, "class", "boolean svelte-159cly1");
			add_location(span10, file$6, 133, 72, 2893);
			attr_dev(label5, "class", "option svelte-159cly1");
			add_location(label5, file$6, 131, 1, 2756);
			attr_dev(span11, "class", "key svelte-159cly1");
			add_location(span11, file$6, 137, 2, 2993);
			attr_dev(input6, "type", "checkbox");
			attr_dev(input6, "class", "svelte-159cly1");
			add_location(input6, file$6, 138, 2, 3031);
			attr_dev(span12, "class", "boolean svelte-159cly1");
			add_location(span12, file$6, 138, 68, 3097);
			attr_dev(label6, "class", "option svelte-159cly1");
			add_location(label6, file$6, 136, 1, 2968);
			attr_dev(span13, "class", "key svelte-159cly1");
			add_location(span13, file$6, 142, 2, 3193);
			attr_dev(input7, "type", "checkbox");
			attr_dev(input7, "class", "svelte-159cly1");
			add_location(input7, file$6, 143, 2, 3228);
			attr_dev(span14, "class", "boolean svelte-159cly1");
			add_location(span14, file$6, 143, 65, 3291);
			attr_dev(label7, "class", "option svelte-159cly1");
			add_location(label7, file$6, 141, 1, 3168);
			attr_dev(div1, "class", "options svelte-159cly1");
			add_location(div1, file$6, 104, 0, 1743);

			dispose = [
				listen_dev(input0, "change", ctx.input0_change_handler),
				listen_dev(input1, "change", ctx.input1_change_handler),
				listen_dev(input2, "change", ctx.input2_change_handler),
				listen_dev(input3, "change", ctx.input3_change_handler),
				listen_dev(input4, "change", ctx.input4_change_handler),
				listen_dev(input5, "change", ctx.input5_change_handler),
				listen_dev(input6, "change", ctx.input6_change_handler),
				listen_dev(input7, "change", ctx.input7_change_handler)
			];
		},

		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, t0);
			append_dev(div1, div0);
			append_dev(div0, span0);
			append_dev(span0, t1);
			append_dev(div0, t2);
			append_dev(div0, input0);

			input0.checked = input0.__value === ctx.$compile_options.generate;

			append_dev(div0, t3);
			append_dev(div0, label0);
			append_dev(label0, span1);
			append_dev(span1, t4);
			append_dev(div0, t5);
			append_dev(div0, input1);

			input1.checked = input1.__value === ctx.$compile_options.generate;

			append_dev(div0, t6);
			append_dev(div0, label1);
			append_dev(label1, span2);
			append_dev(span2, t7);
			append_dev(label1, t8);
			append_dev(div1, t9);
			append_dev(div1, label2);
			append_dev(label2, span3);
			append_dev(span3, t10);
			append_dev(label2, t11);
			append_dev(label2, input2);

			input2.checked = ctx.$compile_options.dev;

			append_dev(label2, t12);
			append_dev(label2, span4);
			append_dev(span4, t13);
			append_dev(label2, t14);
			append_dev(div1, t15);
			append_dev(div1, label3);
			append_dev(label3, span5);
			append_dev(span5, t16);
			append_dev(label3, t17);
			append_dev(label3, input3);

			input3.checked = ctx.$compile_options.css;

			append_dev(label3, t18);
			append_dev(label3, span6);
			append_dev(span6, t19);
			append_dev(label3, t20);
			append_dev(div1, t21);
			append_dev(div1, label4);
			append_dev(label4, span7);
			append_dev(span7, t22);
			append_dev(label4, t23);
			append_dev(label4, input4);

			input4.checked = ctx.$compile_options.hydratable;

			append_dev(label4, t24);
			append_dev(label4, span8);
			append_dev(span8, t25);
			append_dev(label4, t26);
			append_dev(div1, t27);
			append_dev(div1, label5);
			append_dev(label5, span9);
			append_dev(span9, t28);
			append_dev(label5, t29);
			append_dev(label5, input5);

			input5.checked = ctx.$compile_options.customElement;

			append_dev(label5, t30);
			append_dev(label5, span10);
			append_dev(span10, t31);
			append_dev(label5, t32);
			append_dev(div1, t33);
			append_dev(div1, label6);
			append_dev(label6, span11);
			append_dev(span11, t34);
			append_dev(label6, t35);
			append_dev(label6, input6);

			input6.checked = ctx.$compile_options.immutable;

			append_dev(label6, t36);
			append_dev(label6, span12);
			append_dev(span12, t37);
			append_dev(label6, t38);
			append_dev(div1, t39);
			append_dev(div1, label7);
			append_dev(label7, span13);
			append_dev(span13, t40);
			append_dev(label7, t41);
			append_dev(label7, input7);

			input7.checked = ctx.$compile_options.legacy;

			append_dev(label7, t42);
			append_dev(label7, span14);
			append_dev(span14, t43);
			append_dev(div1, t44);
		},

		p: function update(changed, ctx) {
			if (changed.$compile_options) input0.checked = input0.__value === ctx.$compile_options.generate;
			if (changed.$compile_options) input1.checked = input1.__value === ctx.$compile_options.generate;
			if (changed.$compile_options) input2.checked = ctx.$compile_options.dev;

			if ((changed.$compile_options) && t13_value !== (t13_value = ctx.$compile_options.dev + "")) {
				set_data_dev(t13, t13_value);
			}

			if (changed.$compile_options) input3.checked = ctx.$compile_options.css;

			if ((changed.$compile_options) && t19_value !== (t19_value = ctx.$compile_options.css + "")) {
				set_data_dev(t19, t19_value);
			}

			if (changed.$compile_options) input4.checked = ctx.$compile_options.hydratable;

			if ((changed.$compile_options) && t25_value !== (t25_value = ctx.$compile_options.hydratable + "")) {
				set_data_dev(t25, t25_value);
			}

			if (changed.$compile_options) input5.checked = ctx.$compile_options.customElement;

			if ((changed.$compile_options) && t31_value !== (t31_value = ctx.$compile_options.customElement + "")) {
				set_data_dev(t31, t31_value);
			}

			if (changed.$compile_options) input6.checked = ctx.$compile_options.immutable;

			if ((changed.$compile_options) && t37_value !== (t37_value = ctx.$compile_options.immutable + "")) {
				set_data_dev(t37, t37_value);
			}

			if (changed.$compile_options) input7.checked = ctx.$compile_options.legacy;

			if ((changed.$compile_options) && t43_value !== (t43_value = ctx.$compile_options.legacy + "")) {
				set_data_dev(t43, t43_value);
			}
		},

		i: noop,
		o: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div1);
			}

			ctx.$$binding_groups[0].splice(ctx.$$binding_groups[0].indexOf(input0), 1);
			ctx.$$binding_groups[0].splice(ctx.$$binding_groups[0].indexOf(input1), 1);
			run_all(dispose);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$6.name, type: "component", source: "", ctx });
	return block;
}

function instance$6($$self, $$props, $$invalidate) {
	let $compile_options;

	const { compile_options } = getContext('REPL'); validate_store(compile_options, 'compile_options'); component_subscribe($$self, compile_options, $$value => { $compile_options = $$value; $$invalidate('$compile_options', $compile_options); });

	const $$binding_groups = [[]];

	function input0_change_handler() {
		compile_options.update($$value => ($$value.generate = this.__value, $$value));
	}

	function input1_change_handler() {
		compile_options.update($$value => ($$value.generate = this.__value, $$value));
	}

	function input2_change_handler() {
		compile_options.update($$value => ($$value.dev = this.checked, $$value));
	}

	function input3_change_handler() {
		compile_options.update($$value => ($$value.css = this.checked, $$value));
	}

	function input4_change_handler() {
		compile_options.update($$value => ($$value.hydratable = this.checked, $$value));
	}

	function input5_change_handler() {
		compile_options.update($$value => ($$value.customElement = this.checked, $$value));
	}

	function input6_change_handler() {
		compile_options.update($$value => ($$value.immutable = this.checked, $$value));
	}

	function input7_change_handler() {
		compile_options.update($$value => ($$value.legacy = this.checked, $$value));
	}

	$$self.$capture_state = () => {
		return {};
	};

	$$self.$inject_state = $$props => {
		if ('$compile_options' in $$props) compile_options.set($compile_options);
	};

	return {
		compile_options,
		$compile_options,
		input0_change_handler,
		input1_change_handler,
		input2_change_handler,
		input3_change_handler,
		input4_change_handler,
		input5_change_handler,
		input6_change_handler,
		input7_change_handler,
		$$binding_groups
	};
}

class CompilerOptions extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$6, create_fragment$6, safe_not_equal, []);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "CompilerOptions", options, id: create_fragment$6.name });
	}
}

const workers = new Map();

let uid$1 = 1;

class Compiler {
	constructor(workersUrl, svelteUrl) {
		if (!workers.has(svelteUrl)) {
			const worker = new Worker(`${workersUrl}/compiler.js`);
			worker.postMessage({ type: 'init', svelteUrl });
			workers.set(svelteUrl, worker);
		}

		this.worker = workers.get(svelteUrl);

		this.handlers = new Map();

		this.worker.addEventListener('message', event => {
			const handler = this.handlers.get(event.data.id);

			if (handler) { // if no handler, was meant for a different REPL
				handler(event.data.result);
				this.handlers.delete(event.data.id);
			}
		});
	}

	compile(component, options) {
		return new Promise(fulfil => {
			const id = uid$1++;

			this.handlers.set(id, fulfil);

			this.worker.postMessage({
				id,
				type: 'compile',
				source: component.source,
				options: Object.assign({
					name: component.name,
					filename: `${component.name}.svelte`
				}, options),
				entry: component.name === 'App'
			});
		});
	}

	destroy() {
		this.worker.terminate();
	}
}

/* node_modules\@sveltejs\svelte-repl\src\Output\index.svelte generated by Svelte v3.12.0 */

const file$7 = "node_modules\\@sveltejs\\svelte-repl\\src\\Output\\index.svelte";

// (156:1) {:else}
function create_else_block$2(ctx) {
	var current;

	var splitpane = new SplitPane({
		props: {
		type: "vertical",
		pos: 67,
		$$slots: {
		default: [create_default_slot$2],
		b: [create_b_slot],
		a: [create_a_slot]
	},
		$$scope: { ctx }
	},
		$$inline: true
	});

	const block = {
		c: function create() {
			splitpane.$$.fragment.c();
		},

		l: function claim(nodes) {
			splitpane.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(splitpane, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var splitpane_changes = {};
			if (changed.$$scope || changed.foo || changed.sourceErrorLoc || changed.js_editor) splitpane_changes.$$scope = { changed, ctx };
			splitpane.$set(splitpane_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(splitpane.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(splitpane.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(splitpane, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_else_block$2.name, type: "else", source: "(156:1) {:else}", ctx });
	return block;
}

// (149:1) {#if embedded}
function create_if_block$6(ctx) {
	var current;

	let codemirror_props = {
		mode: "js",
		errorLoc: ctx.sourceErrorLoc,
		readonly: true
	};
	var codemirror = new CodeMirror_1({ props: codemirror_props, $$inline: true });

	ctx.codemirror_binding(codemirror);

	const block = {
		c: function create() {
			codemirror.$$.fragment.c();
		},

		l: function claim(nodes) {
			codemirror.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(codemirror, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var codemirror_changes = {};
			if (changed.sourceErrorLoc) codemirror_changes.errorLoc = ctx.sourceErrorLoc;
			codemirror.$set(codemirror_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(codemirror.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(codemirror.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			ctx.codemirror_binding(null);

			destroy_component(codemirror, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block$6.name, type: "if", source: "(149:1) {#if embedded}", ctx });
	return block;
}

// (158:3) <div slot="a">
function create_a_slot(ctx) {
	var div, current;

	let codemirror_props = {
		mode: "js",
		errorLoc: ctx.sourceErrorLoc,
		readonly: true
	};
	var codemirror = new CodeMirror_1({ props: codemirror_props, $$inline: true });

	ctx.codemirror_binding_1(codemirror);

	const block = {
		c: function create() {
			div = element("div");
			codemirror.$$.fragment.c();
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { slot: true, class: true }, false);
			var div_nodes = children(div);

			codemirror.$$.fragment.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(div, "slot", "a");
			attr_dev(div, "class", "svelte-1p3b02q");
			add_location(div, file$7, 157, 3, 3315);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(codemirror, div, null);
			current = true;
		},

		p: function update(changed, ctx) {
			var codemirror_changes = {};
			if (changed.sourceErrorLoc) codemirror_changes.errorLoc = ctx.sourceErrorLoc;
			codemirror.$set(codemirror_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(codemirror.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(codemirror.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			ctx.codemirror_binding_1(null);

			destroy_component(codemirror);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_a_slot.name, type: "slot", source: "(158:3) <div slot=\"a\">", ctx });
	return block;
}

// (167:3) <section slot="b">
function create_b_slot(ctx) {
	var section, h3, t0, t1, updating_foo, current;

	function compileroptions_foo_binding(value) {
		ctx.compileroptions_foo_binding.call(null, value);
		updating_foo = true;
		add_flush_callback(() => updating_foo = false);
	}

	let compileroptions_props = {};
	if (ctx.foo !== void 0) {
		compileroptions_props.foo = ctx.foo;
	}
	var compileroptions = new CompilerOptions({
		props: compileroptions_props,
		$$inline: true
	});

	binding_callbacks.push(() => bind(compileroptions, 'foo', compileroptions_foo_binding));

	const block = {
		c: function create() {
			section = element("section");
			h3 = element("h3");
			t0 = text("Compiler options");
			t1 = space();
			compileroptions.$$.fragment.c();
			this.h();
		},

		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { slot: true, class: true }, false);
			var section_nodes = children(section);

			h3 = claim_element(section_nodes, "H3", { class: true }, false);
			var h3_nodes = children(h3);

			t0 = claim_text(h3_nodes, "Compiler options");
			h3_nodes.forEach(detach_dev);
			t1 = claim_space(section_nodes);
			compileroptions.$$.fragment.l(section_nodes);
			section_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(h3, "class", "svelte-1p3b02q");
			add_location(h3, file$7, 167, 4, 3477);
			attr_dev(section, "slot", "b");
			attr_dev(section, "class", "svelte-1p3b02q");
			add_location(section, file$7, 166, 3, 3454);
		},

		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			append_dev(section, h3);
			append_dev(h3, t0);
			append_dev(section, t1);
			mount_component(compileroptions, section, null);
			current = true;
		},

		p: function update(changed, ctx) {
			var compileroptions_changes = {};
			if (!updating_foo && changed.foo) {
				compileroptions_changes.foo = ctx.foo;
			}
			compileroptions.$set(compileroptions_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(compileroptions.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(compileroptions.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(section);
			}

			destroy_component(compileroptions);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_b_slot.name, type: "slot", source: "(167:3) <section slot=\"b\">", ctx });
	return block;
}

// (157:2) <SplitPane type="vertical" pos={67}>
function create_default_slot$2(ctx) {
	var t;

	const block = {
		c: function create() {
			t = space();
		},

		l: function claim(nodes) {
			t = claim_space(nodes);
		},

		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},

		p: noop,
		i: noop,
		o: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_default_slot$2.name, type: "slot", source: "(157:2) <SplitPane type=\"vertical\" pos={67}>", ctx });
	return block;
}

function create_fragment$7(ctx) {
	var div0, button0, t0, t1, button1, t2, t3, button2, t4, t5, div1, updating_error, t6, div2, current_block_type_index, if_block, t7, div3, current, dispose;

	function viewer_1_error_binding(value) {
		ctx.viewer_1_error_binding.call(null, value);
		updating_error = true;
		add_flush_callback(() => updating_error = false);
	}

	let viewer_1_props = {
		status: ctx.status,
		relaxed: ctx.relaxed,
		injectedJS: ctx.injectedJS,
		injectedCSS: ctx.injectedCSS
	};
	if (ctx.runtimeError !== void 0) {
		viewer_1_props.error = ctx.runtimeError;
	}
	var viewer_1 = new Viewer({ props: viewer_1_props, $$inline: true });

	ctx.viewer_1_binding(viewer_1);
	binding_callbacks.push(() => bind(viewer_1, 'error', viewer_1_error_binding));

	var if_block_creators = [
		create_if_block$6,
		create_else_block$2
	];

	var if_blocks = [];

	function select_block_type(changed, ctx) {
		if (ctx.embedded) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(null, ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	let codemirror_props = {
		mode: "css",
		errorLoc: ctx.sourceErrorLoc,
		readonly: true
	};
	var codemirror = new CodeMirror_1({ props: codemirror_props, $$inline: true });

	ctx.codemirror_binding_2(codemirror);

	const block = {
		c: function create() {
			div0 = element("div");
			button0 = element("button");
			t0 = text("Result");
			t1 = space();
			button1 = element("button");
			t2 = text("JS output");
			t3 = space();
			button2 = element("button");
			t4 = text("CSS output");
			t5 = space();
			div1 = element("div");
			viewer_1.$$.fragment.c();
			t6 = space();
			div2 = element("div");
			if_block.c();
			t7 = space();
			div3 = element("div");
			codemirror.$$.fragment.c();
			this.h();
		},

		l: function claim(nodes) {
			div0 = claim_element(nodes, "DIV", { class: true }, false);
			var div0_nodes = children(div0);

			button0 = claim_element(div0_nodes, "BUTTON", { class: true }, false);
			var button0_nodes = children(button0);

			t0 = claim_text(button0_nodes, "Result");
			button0_nodes.forEach(detach_dev);
			t1 = claim_space(div0_nodes);

			button1 = claim_element(div0_nodes, "BUTTON", { class: true }, false);
			var button1_nodes = children(button1);

			t2 = claim_text(button1_nodes, "JS output");
			button1_nodes.forEach(detach_dev);
			t3 = claim_space(div0_nodes);

			button2 = claim_element(div0_nodes, "BUTTON", { class: true }, false);
			var button2_nodes = children(button2);

			t4 = claim_text(button2_nodes, "CSS output");
			button2_nodes.forEach(detach_dev);
			div0_nodes.forEach(detach_dev);
			t5 = claim_space(nodes);

			div1 = claim_element(nodes, "DIV", { class: true }, false);
			var div1_nodes = children(div1);

			viewer_1.$$.fragment.l(div1_nodes);
			div1_nodes.forEach(detach_dev);
			t6 = claim_space(nodes);

			div2 = claim_element(nodes, "DIV", { class: true }, false);
			var div2_nodes = children(div2);

			if_block.l(div2_nodes);
			div2_nodes.forEach(detach_dev);
			t7 = claim_space(nodes);

			div3 = claim_element(nodes, "DIV", { class: true }, false);
			var div3_nodes = children(div3);

			codemirror.$$.fragment.l(div3_nodes);
			div3_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(button0, "class", "svelte-1p3b02q");
			toggle_class(button0, "active", ctx.view === 'result');
			add_location(button0, file$7, 118, 1, 2556);
			attr_dev(button1, "class", "svelte-1p3b02q");
			toggle_class(button1, "active", ctx.view === 'js');
			add_location(button1, file$7, 123, 1, 2658);
			attr_dev(button2, "class", "svelte-1p3b02q");
			toggle_class(button2, "active", ctx.view === 'css');
			add_location(button2, file$7, 128, 1, 2755);
			attr_dev(div0, "class", "view-toggle svelte-1p3b02q");
			add_location(div0, file$7, 117, 0, 2529);
			attr_dev(div1, "class", "tab-content svelte-1p3b02q");
			toggle_class(div1, "visible", ctx.view === 'result');
			add_location(div1, file$7, 135, 0, 2887);
			attr_dev(div2, "class", "tab-content svelte-1p3b02q");
			toggle_class(div2, "visible", ctx.view === 'js');
			add_location(div2, file$7, 147, 0, 3092);
			attr_dev(div3, "class", "tab-content svelte-1p3b02q");
			toggle_class(div3, "visible", ctx.view === 'css');
			add_location(div3, file$7, 176, 0, 3606);

			dispose = [
				listen_dev(button0, "click", ctx.click_handler),
				listen_dev(button1, "click", ctx.click_handler_1),
				listen_dev(button2, "click", ctx.click_handler_2)
			];
		},

		m: function mount(target, anchor) {
			insert_dev(target, div0, anchor);
			append_dev(div0, button0);
			append_dev(button0, t0);
			append_dev(div0, t1);
			append_dev(div0, button1);
			append_dev(button1, t2);
			append_dev(div0, t3);
			append_dev(div0, button2);
			append_dev(button2, t4);
			insert_dev(target, t5, anchor);
			insert_dev(target, div1, anchor);
			mount_component(viewer_1, div1, null);
			insert_dev(target, t6, anchor);
			insert_dev(target, div2, anchor);
			if_blocks[current_block_type_index].m(div2, null);
			insert_dev(target, t7, anchor);
			insert_dev(target, div3, anchor);
			mount_component(codemirror, div3, null);
			current = true;
		},

		p: function update(changed, ctx) {
			if (changed.view) {
				toggle_class(button0, "active", ctx.view === 'result');
				toggle_class(button1, "active", ctx.view === 'js');
				toggle_class(button2, "active", ctx.view === 'css');
			}

			var viewer_1_changes = {};
			if (changed.status) viewer_1_changes.status = ctx.status;
			if (changed.relaxed) viewer_1_changes.relaxed = ctx.relaxed;
			if (changed.injectedJS) viewer_1_changes.injectedJS = ctx.injectedJS;
			if (changed.injectedCSS) viewer_1_changes.injectedCSS = ctx.injectedCSS;
			if (!updating_error && changed.runtimeError) {
				viewer_1_changes.error = ctx.runtimeError;
			}
			viewer_1.$set(viewer_1_changes);

			if (changed.view) {
				toggle_class(div1, "visible", ctx.view === 'result');
			}

			var previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(changed, ctx);
			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(changed, ctx);
			} else {
				group_outros();
				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});
				check_outros();

				if_block = if_blocks[current_block_type_index];
				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}
				transition_in(if_block, 1);
				if_block.m(div2, null);
			}

			if (changed.view) {
				toggle_class(div2, "visible", ctx.view === 'js');
			}

			var codemirror_changes = {};
			if (changed.sourceErrorLoc) codemirror_changes.errorLoc = ctx.sourceErrorLoc;
			codemirror.$set(codemirror_changes);

			if (changed.view) {
				toggle_class(div3, "visible", ctx.view === 'css');
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(viewer_1.$$.fragment, local);

			transition_in(if_block);

			transition_in(codemirror.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(viewer_1.$$.fragment, local);
			transition_out(if_block);
			transition_out(codemirror.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div0);
				detach_dev(t5);
				detach_dev(div1);
			}

			ctx.viewer_1_binding(null);

			destroy_component(viewer_1);

			if (detaching) {
				detach_dev(t6);
				detach_dev(div2);
			}

			if_blocks[current_block_type_index].d();

			if (detaching) {
				detach_dev(t7);
				detach_dev(div3);
			}

			ctx.codemirror_binding_2(null);

			destroy_component(codemirror);

			run_all(dispose);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$7.name, type: "component", source: "", ctx });
	return block;
}

function instance$7($$self, $$props, $$invalidate) {
	

	const { register_output } = getContext('REPL');

	let { svelteUrl, workersUrl, status, sourceErrorLoc = null, runtimeError = null, embedded = false, relaxed = false, injectedJS, injectedCSS } = $$props;

	let foo; // TODO workaround for https://github.com/sveltejs/svelte/issues/2122

	register_output({
		set: async (selected, options) => {
			if (selected.type === 'js') {
				js_editor.set(`/* Select a component to see its compiled code */`);
				css_editor.set(`/* Select a component to see its compiled code */`);
				return;
			}

			const compiled = await compiler.compile(selected, options);
			if (!js_editor) return; // unmounted

			js_editor.set(compiled.js, 'js');
			css_editor.set(compiled.css, 'css');
		},

		update: async (selected, options) => {
			if (selected.type === 'js') return;

			const compiled = await compiler.compile(selected, options);
			if (!js_editor) return; // unmounted

			js_editor.update(compiled.js);
			css_editor.update(compiled.css);
		}
	});

	const compiler = is_browser && new Compiler(workersUrl, svelteUrl);

	// refs
	let viewer;
	let js_editor;
	let css_editor;

	let view = 'result';

	const writable_props = ['svelteUrl', 'workersUrl', 'status', 'sourceErrorLoc', 'runtimeError', 'embedded', 'relaxed', 'injectedJS', 'injectedCSS'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Index> was created with unknown prop '${key}'`);
	});

	const click_handler = () => $$invalidate('view', view = 'result');

	const click_handler_1 = () => $$invalidate('view', view = 'js');

	const click_handler_2 = () => $$invalidate('view', view = 'css');

	function viewer_1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			$$invalidate('viewer', viewer = $$value);
		});
	}

	function viewer_1_error_binding(value) {
		runtimeError = value;
		$$invalidate('runtimeError', runtimeError);
	}

	function codemirror_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			$$invalidate('js_editor', js_editor = $$value);
		});
	}

	function codemirror_binding_1($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			$$invalidate('js_editor', js_editor = $$value);
		});
	}

	function compileroptions_foo_binding(value) {
		foo = value;
		$$invalidate('foo', foo);
	}

	function codemirror_binding_2($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			$$invalidate('css_editor', css_editor = $$value);
		});
	}

	$$self.$set = $$props => {
		if ('svelteUrl' in $$props) $$invalidate('svelteUrl', svelteUrl = $$props.svelteUrl);
		if ('workersUrl' in $$props) $$invalidate('workersUrl', workersUrl = $$props.workersUrl);
		if ('status' in $$props) $$invalidate('status', status = $$props.status);
		if ('sourceErrorLoc' in $$props) $$invalidate('sourceErrorLoc', sourceErrorLoc = $$props.sourceErrorLoc);
		if ('runtimeError' in $$props) $$invalidate('runtimeError', runtimeError = $$props.runtimeError);
		if ('embedded' in $$props) $$invalidate('embedded', embedded = $$props.embedded);
		if ('relaxed' in $$props) $$invalidate('relaxed', relaxed = $$props.relaxed);
		if ('injectedJS' in $$props) $$invalidate('injectedJS', injectedJS = $$props.injectedJS);
		if ('injectedCSS' in $$props) $$invalidate('injectedCSS', injectedCSS = $$props.injectedCSS);
	};

	$$self.$capture_state = () => {
		return { svelteUrl, workersUrl, status, sourceErrorLoc, runtimeError, embedded, relaxed, injectedJS, injectedCSS, foo, viewer, js_editor, css_editor, view };
	};

	$$self.$inject_state = $$props => {
		if ('svelteUrl' in $$props) $$invalidate('svelteUrl', svelteUrl = $$props.svelteUrl);
		if ('workersUrl' in $$props) $$invalidate('workersUrl', workersUrl = $$props.workersUrl);
		if ('status' in $$props) $$invalidate('status', status = $$props.status);
		if ('sourceErrorLoc' in $$props) $$invalidate('sourceErrorLoc', sourceErrorLoc = $$props.sourceErrorLoc);
		if ('runtimeError' in $$props) $$invalidate('runtimeError', runtimeError = $$props.runtimeError);
		if ('embedded' in $$props) $$invalidate('embedded', embedded = $$props.embedded);
		if ('relaxed' in $$props) $$invalidate('relaxed', relaxed = $$props.relaxed);
		if ('injectedJS' in $$props) $$invalidate('injectedJS', injectedJS = $$props.injectedJS);
		if ('injectedCSS' in $$props) $$invalidate('injectedCSS', injectedCSS = $$props.injectedCSS);
		if ('foo' in $$props) $$invalidate('foo', foo = $$props.foo);
		if ('viewer' in $$props) $$invalidate('viewer', viewer = $$props.viewer);
		if ('js_editor' in $$props) $$invalidate('js_editor', js_editor = $$props.js_editor);
		if ('css_editor' in $$props) $$invalidate('css_editor', css_editor = $$props.css_editor);
		if ('view' in $$props) $$invalidate('view', view = $$props.view);
	};

	return {
		svelteUrl,
		workersUrl,
		status,
		sourceErrorLoc,
		runtimeError,
		embedded,
		relaxed,
		injectedJS,
		injectedCSS,
		foo,
		viewer,
		js_editor,
		css_editor,
		view,
		click_handler,
		click_handler_1,
		click_handler_2,
		viewer_1_binding,
		viewer_1_error_binding,
		codemirror_binding,
		codemirror_binding_1,
		compileroptions_foo_binding,
		codemirror_binding_2
	};
}

class Index extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$7, create_fragment$7, safe_not_equal, ["svelteUrl", "workersUrl", "status", "sourceErrorLoc", "runtimeError", "embedded", "relaxed", "injectedJS", "injectedCSS"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "Index", options, id: create_fragment$7.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.svelteUrl === undefined && !('svelteUrl' in props)) {
			console.warn("<Index> was created without expected prop 'svelteUrl'");
		}
		if (ctx.workersUrl === undefined && !('workersUrl' in props)) {
			console.warn("<Index> was created without expected prop 'workersUrl'");
		}
		if (ctx.status === undefined && !('status' in props)) {
			console.warn("<Index> was created without expected prop 'status'");
		}
		if (ctx.injectedJS === undefined && !('injectedJS' in props)) {
			console.warn("<Index> was created without expected prop 'injectedJS'");
		}
		if (ctx.injectedCSS === undefined && !('injectedCSS' in props)) {
			console.warn("<Index> was created without expected prop 'injectedCSS'");
		}
	}

	get svelteUrl() {
		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set svelteUrl(value) {
		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get workersUrl() {
		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set workersUrl(value) {
		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get status() {
		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set status(value) {
		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sourceErrorLoc() {
		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sourceErrorLoc(value) {
		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get runtimeError() {
		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set runtimeError(value) {
		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get embedded() {
		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set embedded(value) {
		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get relaxed() {
		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set relaxed(value) {
		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get injectedJS() {
		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set injectedJS(value) {
		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get injectedCSS() {
		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set injectedCSS(value) {
		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

const workers$1 = new Map();

let uid$2 = 1;

class Bundler {
	constructor({ workersUrl, packagesUrl, svelteUrl, onstatus }) {
		const hash = `${packagesUrl}:${svelteUrl}`;

		if (!workers$1.has(hash)) {
			const worker = new Worker(`${workersUrl}/bundler.js`);
			worker.postMessage({ type: 'init', packagesUrl, svelteUrl });
			workers$1.set(hash, worker);
		}

		this.worker = workers$1.get(hash);

		this.handlers = new Map();

		this.worker.addEventListener('message', event => {
			const handler = this.handlers.get(event.data.uid);

			if (handler) { // if no handler, was meant for a different REPL
				if (event.data.type === 'status') {
					onstatus(event.data.message);
					return;
				}

				onstatus(null);
				handler(event.data);
				this.handlers.delete(event.data.uid);
			}
		});
	}

	bundle(components) {
		return new Promise(fulfil => {
			this.handlers.set(uid$2, fulfil);

			this.worker.postMessage({
				uid: uid$2,
				type: 'bundle',
				components
			});

			uid$2 += 1;
		});
	}

	destroy() {
		this.worker.terminate();
	}
}

/* node_modules\@sveltejs\svelte-repl\src\Repl.svelte generated by Svelte v3.12.0 */
const { Error: Error_1 } = globals;

const file$8 = "node_modules\\@sveltejs\\svelte-repl\\src\\Repl.svelte";

// (224:2) <section slot=a>
function create_a_slot$1(ctx) {
	var section, t, current;

	var componentselector = new ComponentSelector({
		props: { handle_select: ctx.handle_select },
		$$inline: true
	});

	let moduleeditor_props = { errorLoc: ctx.sourceErrorLoc || ctx.runtimeErrorLoc };
	var moduleeditor = new ModuleEditor({
		props: moduleeditor_props,
		$$inline: true
	});

	ctx.moduleeditor_binding(moduleeditor);

	const block = {
		c: function create() {
			section = element("section");
			componentselector.$$.fragment.c();
			t = space();
			moduleeditor.$$.fragment.c();
			this.h();
		},

		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { slot: true }, false);
			var section_nodes = children(section);

			componentselector.$$.fragment.l(section_nodes);
			t = claim_space(section_nodes);
			moduleeditor.$$.fragment.l(section_nodes);
			section_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(section, "slot", "a");
			add_location(section, file$8, 223, 2, 5336);
		},

		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			mount_component(componentselector, section, null);
			append_dev(section, t);
			mount_component(moduleeditor, section, null);
			current = true;
		},

		p: function update_1(changed, ctx) {
			var moduleeditor_changes = {};
			moduleeditor.$set(moduleeditor_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(componentselector.$$.fragment, local);

			transition_in(moduleeditor.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(componentselector.$$.fragment, local);
			transition_out(moduleeditor.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(section);
			}

			destroy_component(componentselector);

			ctx.moduleeditor_binding(null);

			destroy_component(moduleeditor);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_a_slot$1.name, type: "slot", source: "(224:2) <section slot=a>", ctx });
	return block;
}

// (229:2) <section slot=b style='height: 100%;'>
function create_b_slot$1(ctx) {
	var section, current;

	var output_1 = new Index({
		props: {
		svelteUrl: ctx.svelteUrl,
		workersUrl: ctx.workersUrl,
		status: ctx.status,
		embedded: ctx.embedded,
		relaxed: ctx.relaxed,
		injectedJS: ctx.injectedJS,
		injectedCSS: ctx.injectedCSS
	},
		$$inline: true
	});

	const block = {
		c: function create() {
			section = element("section");
			output_1.$$.fragment.c();
			this.h();
		},

		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { slot: true, style: true }, false);
			var section_nodes = children(section);

			output_1.$$.fragment.l(section_nodes);
			section_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(section, "slot", "b");
			set_style(section, "height", "100%");
			add_location(section, file$8, 228, 2, 5493);
		},

		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			mount_component(output_1, section, null);
			current = true;
		},

		p: function update_1(changed, ctx) {
			var output_1_changes = {};
			if (changed.svelteUrl) output_1_changes.svelteUrl = ctx.svelteUrl;
			if (changed.workersUrl) output_1_changes.workersUrl = ctx.workersUrl;
			if (changed.status) output_1_changes.status = ctx.status;
			if (changed.embedded) output_1_changes.embedded = ctx.embedded;
			if (changed.relaxed) output_1_changes.relaxed = ctx.relaxed;
			if (changed.injectedJS) output_1_changes.injectedJS = ctx.injectedJS;
			if (changed.injectedCSS) output_1_changes.injectedCSS = ctx.injectedCSS;
			output_1.$set(output_1_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(output_1.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(output_1.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(section);
			}

			destroy_component(output_1);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_b_slot$1.name, type: "slot", source: "(229:2) <section slot=b style='height: 100%;'>", ctx });
	return block;
}

// (219:1) <SplitPane   type="{orientation === 'rows' ? 'vertical' : 'horizontal'}"   pos="{fixed ? fixedPos : orientation === 'rows' ? 50 : 60}"   {fixed}  >
function create_default_slot$3(ctx) {
	var t;

	const block = {
		c: function create() {
			t = space();
		},

		l: function claim(nodes) {
			t = claim_space(nodes);
		},

		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},

		p: noop,
		i: noop,
		o: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_default_slot$3.name, type: "slot", source: "(219:1) <SplitPane   type=\"{orientation === 'rows' ? 'vertical' : 'horizontal'}\"   pos=\"{fixed ? fixedPos : orientation === 'rows' ? 50 : 60}\"   {fixed}  >", ctx });
	return block;
}

function create_fragment$8(ctx) {
	var div, current;

	var splitpane = new SplitPane({
		props: {
		type: ctx.orientation === 'rows' ? 'vertical' : 'horizontal',
		pos: ctx.fixed ? ctx.fixedPos : ctx.orientation === 'rows' ? 50 : 60,
		fixed: ctx.fixed,
		$$slots: {
		default: [create_default_slot$3],
		b: [create_b_slot$1],
		a: [create_a_slot$1]
	},
		$$scope: { ctx }
	},
		$$inline: true
	});

	const block = {
		c: function create() {
			div = element("div");
			splitpane.$$.fragment.c();
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true }, false);
			var div_nodes = children(div);

			splitpane.$$.fragment.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(div, "class", "container svelte-177xqak");
			toggle_class(div, "orientation", ctx.orientation);
			add_location(div, file$8, 217, 0, 5143);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(splitpane, div, null);
			current = true;
		},

		p: function update_1(changed, ctx) {
			var splitpane_changes = {};
			if (changed.orientation) splitpane_changes.type = ctx.orientation === 'rows' ? 'vertical' : 'horizontal';
			if (changed.fixed || changed.fixedPos || changed.orientation) splitpane_changes.pos = ctx.fixed ? ctx.fixedPos : ctx.orientation === 'rows' ? 50 : 60;
			if (changed.fixed) splitpane_changes.fixed = ctx.fixed;
			if (changed.$$scope || changed.svelteUrl || changed.workersUrl || changed.status || changed.embedded || changed.relaxed || changed.injectedJS || changed.injectedCSS || changed.input) splitpane_changes.$$scope = { changed, ctx };
			splitpane.$set(splitpane_changes);

			if (changed.orientation) {
				toggle_class(div, "orientation", ctx.orientation);
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(splitpane.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(splitpane.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			destroy_component(splitpane);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$8.name, type: "component", source: "", ctx });
	return block;
}

function instance$8($$self, $$props, $$invalidate) {
	let $bundle, $components, $selected, $compile_options;

	

	let { workersUrl, packagesUrl = 'https://unpkg.com', svelteUrl = `${packagesUrl}/svelte`, embedded = false, orientation = 'columns', relaxed = false, fixed = false, fixedPos = 50, injectedJS = '', injectedCSS = '' } = $$props;

	function toJSON() {

		return {
			imports: $bundle.imports,
			components: $components
		};
	}

	async function set(data) {
		components.set(data.components);
		selected.set(data.components[0]);

		rebundle();

		await module_editor_ready;
		await output_ready;

		$$invalidate('injectedCSS', injectedCSS = data.css || '');
		module_editor.set($selected.source, $selected.type);
		output.set($selected, $compile_options);
	}

	function update(data) {
		const { name, type } = $selected || {};

		components.set(data.components);

		const matched_component = data.components.find(file => file.name === name && file.type === type);
		selected.set(matched_component || data.components[0]);

		$$invalidate('injectedCSS', injectedCSS = data.css || '');

		if (matched_component) {
			module_editor.update(matched_component.source);
			output.update(matched_component, $compile_options);
		} else {
			module_editor.set(matched_component.source, matched_component.type);
			output.set(matched_component, $compile_options);
		}
	}

	if (!workersUrl) {
		throw new Error(`You must supply workersUrl prop to <Repl>`);
	}

	const dispatch = createEventDispatcher();

	const components = writable([]); validate_store(components, 'components'); component_subscribe($$self, components, $$value => { $components = $$value; $$invalidate('$components', $components); });
	const selected = writable(null); validate_store(selected, 'selected'); component_subscribe($$self, selected, $$value => { $selected = $$value; $$invalidate('$selected', $selected); });
	const bundle = writable(null); validate_store(bundle, 'bundle'); component_subscribe($$self, bundle, $$value => { $bundle = $$value; $$invalidate('$bundle', $bundle); });

	const compile_options = writable({
		generate: 'dom',
		dev: false,
		css: false,
		hydratable: false,
		customElement: false,
		immutable: false,
		legacy: false
	}); validate_store(compile_options, 'compile_options'); component_subscribe($$self, compile_options, $$value => { $compile_options = $$value; $$invalidate('$compile_options', $compile_options); });

	let module_editor;
	let output;

	let current_token;
	async function rebundle() {
		const token = current_token = {};
		const result = await bundler.bundle($components);
		if (result && token === current_token) bundle.set(result);
	}

	// TODO this is a horrible kludge, written in a panic. fix it
	let fulfil_module_editor_ready;
	let module_editor_ready = new Promise(f => fulfil_module_editor_ready = f);

	let fulfil_output_ready;
	let output_ready = new Promise(f => fulfil_output_ready = f);


	setContext('REPL', {
		components,
		selected,
		bundle,
		compile_options,

		rebundle,

		navigate: item => {
			const match = /^(.+)\.(\w+)$/.exec(item.filename);
			if (!match) return; // ???

			const [, name, type] = match;
			const component = $components.find(c => c.name === name && c.type === type);
			handle_select(component);

			// TODO select the line/column in question
		},

		handle_change: event => {
			selected.update(component => {
				// TODO this is a bit hacky — we're relying on mutability
				// so that updating components works... might be better
				// if a) components had unique IDs, b) we tracked selected
				// *index* rather than component, and c) `selected` was
				// derived from `components` and `index`
				component.source = event.detail.value;
				return component;
			});

			components.update(c => c);

			// recompile selected component
			output.update($selected, $compile_options);

			rebundle();

			dispatch('change', {
				components: $components
			});
		},

		register_module_editor(editor) {
			module_editor = editor;
			fulfil_module_editor_ready();
		},

		register_output(handlers) {
			$$invalidate('output', output = handlers);
			fulfil_output_ready();
		},

		request_focus() {
			module_editor.focus();
		}
	});

	function handle_select(component) {
		selected.set(component);
		module_editor.set(component.source, component.type);
		output.set($selected, $compile_options);
	}

	let input;
	let sourceErrorLoc;
	let runtimeErrorLoc; // TODO refactor this stuff — runtimeErrorLoc is unused
	let status = null;

	const bundler = is_browser && new Bundler({
		workersUrl,
		packagesUrl,
		svelteUrl,
		onstatus: message => {
			$$invalidate('status', status = message);
		}
	});

	const writable_props = ['workersUrl', 'packagesUrl', 'svelteUrl', 'embedded', 'orientation', 'relaxed', 'fixed', 'fixedPos', 'injectedJS', 'injectedCSS'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Repl> was created with unknown prop '${key}'`);
	});

	function moduleeditor_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			$$invalidate('input', input = $$value);
		});
	}

	$$self.$set = $$props => {
		if ('workersUrl' in $$props) $$invalidate('workersUrl', workersUrl = $$props.workersUrl);
		if ('packagesUrl' in $$props) $$invalidate('packagesUrl', packagesUrl = $$props.packagesUrl);
		if ('svelteUrl' in $$props) $$invalidate('svelteUrl', svelteUrl = $$props.svelteUrl);
		if ('embedded' in $$props) $$invalidate('embedded', embedded = $$props.embedded);
		if ('orientation' in $$props) $$invalidate('orientation', orientation = $$props.orientation);
		if ('relaxed' in $$props) $$invalidate('relaxed', relaxed = $$props.relaxed);
		if ('fixed' in $$props) $$invalidate('fixed', fixed = $$props.fixed);
		if ('fixedPos' in $$props) $$invalidate('fixedPos', fixedPos = $$props.fixedPos);
		if ('injectedJS' in $$props) $$invalidate('injectedJS', injectedJS = $$props.injectedJS);
		if ('injectedCSS' in $$props) $$invalidate('injectedCSS', injectedCSS = $$props.injectedCSS);
	};

	$$self.$capture_state = () => {
		return { workersUrl, packagesUrl, svelteUrl, embedded, orientation, relaxed, fixed, fixedPos, injectedJS, injectedCSS, module_editor, output, current_token, fulfil_module_editor_ready, module_editor_ready, fulfil_output_ready, output_ready, input, sourceErrorLoc, runtimeErrorLoc, status, $bundle, $components, $selected, $compile_options };
	};

	$$self.$inject_state = $$props => {
		if ('workersUrl' in $$props) $$invalidate('workersUrl', workersUrl = $$props.workersUrl);
		if ('packagesUrl' in $$props) $$invalidate('packagesUrl', packagesUrl = $$props.packagesUrl);
		if ('svelteUrl' in $$props) $$invalidate('svelteUrl', svelteUrl = $$props.svelteUrl);
		if ('embedded' in $$props) $$invalidate('embedded', embedded = $$props.embedded);
		if ('orientation' in $$props) $$invalidate('orientation', orientation = $$props.orientation);
		if ('relaxed' in $$props) $$invalidate('relaxed', relaxed = $$props.relaxed);
		if ('fixed' in $$props) $$invalidate('fixed', fixed = $$props.fixed);
		if ('fixedPos' in $$props) $$invalidate('fixedPos', fixedPos = $$props.fixedPos);
		if ('injectedJS' in $$props) $$invalidate('injectedJS', injectedJS = $$props.injectedJS);
		if ('injectedCSS' in $$props) $$invalidate('injectedCSS', injectedCSS = $$props.injectedCSS);
		if ('module_editor' in $$props) module_editor = $$props.module_editor;
		if ('output' in $$props) $$invalidate('output', output = $$props.output);
		if ('current_token' in $$props) current_token = $$props.current_token;
		if ('fulfil_module_editor_ready' in $$props) fulfil_module_editor_ready = $$props.fulfil_module_editor_ready;
		if ('module_editor_ready' in $$props) module_editor_ready = $$props.module_editor_ready;
		if ('fulfil_output_ready' in $$props) fulfil_output_ready = $$props.fulfil_output_ready;
		if ('output_ready' in $$props) output_ready = $$props.output_ready;
		if ('input' in $$props) $$invalidate('input', input = $$props.input);
		if ('sourceErrorLoc' in $$props) $$invalidate('sourceErrorLoc', sourceErrorLoc = $$props.sourceErrorLoc);
		if ('runtimeErrorLoc' in $$props) $$invalidate('runtimeErrorLoc', runtimeErrorLoc = $$props.runtimeErrorLoc);
		if ('status' in $$props) $$invalidate('status', status = $$props.status);
		if ('$bundle' in $$props) bundle.set($bundle);
		if ('$components' in $$props) components.set($components);
		if ('$selected' in $$props) selected.set($selected);
		if ('$compile_options' in $$props) compile_options.set($compile_options);
	};

	$$self.$$.update = ($$dirty = { output: 1, $selected: 1, $compile_options: 1 }) => {
		if ($$dirty.output || $$dirty.$selected || $$dirty.$compile_options) { if (output && $selected) {
				output.update($selected, $compile_options);
			} }
	};

	return {
		workersUrl,
		packagesUrl,
		svelteUrl,
		embedded,
		orientation,
		relaxed,
		fixed,
		fixedPos,
		injectedJS,
		injectedCSS,
		toJSON,
		set,
		update,
		components,
		selected,
		bundle,
		compile_options,
		handle_select,
		input,
		sourceErrorLoc,
		runtimeErrorLoc,
		status,
		moduleeditor_binding
	};
}

class Repl extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$8, create_fragment$8, safe_not_equal, ["workersUrl", "packagesUrl", "svelteUrl", "embedded", "orientation", "relaxed", "fixed", "fixedPos", "injectedJS", "injectedCSS", "toJSON", "set", "update"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "Repl", options, id: create_fragment$8.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.workersUrl === undefined && !('workersUrl' in props)) {
			console.warn("<Repl> was created without expected prop 'workersUrl'");
		}
		if (ctx.toJSON === undefined && !('toJSON' in props)) {
			console.warn("<Repl> was created without expected prop 'toJSON'");
		}
		if (ctx.set === undefined && !('set' in props)) {
			console.warn("<Repl> was created without expected prop 'set'");
		}
		if (ctx.update === undefined && !('update' in props)) {
			console.warn("<Repl> was created without expected prop 'update'");
		}
	}

	get workersUrl() {
		throw new Error_1("<Repl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set workersUrl(value) {
		throw new Error_1("<Repl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get packagesUrl() {
		throw new Error_1("<Repl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set packagesUrl(value) {
		throw new Error_1("<Repl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get svelteUrl() {
		throw new Error_1("<Repl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set svelteUrl(value) {
		throw new Error_1("<Repl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get embedded() {
		throw new Error_1("<Repl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set embedded(value) {
		throw new Error_1("<Repl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get orientation() {
		throw new Error_1("<Repl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set orientation(value) {
		throw new Error_1("<Repl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get relaxed() {
		throw new Error_1("<Repl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set relaxed(value) {
		throw new Error_1("<Repl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fixed() {
		throw new Error_1("<Repl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fixed(value) {
		throw new Error_1("<Repl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fixedPos() {
		throw new Error_1("<Repl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fixedPos(value) {
		throw new Error_1("<Repl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get injectedJS() {
		throw new Error_1("<Repl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set injectedJS(value) {
		throw new Error_1("<Repl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get injectedCSS() {
		throw new Error_1("<Repl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set injectedCSS(value) {
		throw new Error_1("<Repl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get toJSON() {
		return this.$$.ctx.toJSON;
	}

	set toJSON(value) {
		throw new Error_1("<Repl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get set() {
		return this.$$.ctx.set;
	}

	set set(value) {
		throw new Error_1("<Repl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get update() {
		return this.$$.ctx.update;
	}

	set update(value) {
		throw new Error_1("<Repl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export { Repl as R };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUmVwbC5kMjBmYjQzYi5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3lvb3RpbHMveW9vdGlscy5lcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9Ac3ZlbHRlanMvc3ZlbHRlLXJlcGwvc3JjL1NwbGl0UGFuZS5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHN2ZWx0ZWpzL3N2ZWx0ZS1yZXBsL3NyYy9lbnYuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlL2Vhc2luZy9pbmRleC5tanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3RyYW5zaXRpb24vaW5kZXgubWpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BzdmVsdGVqcy9zdmVsdGUtcmVwbC9zcmMvTWVzc2FnZS5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHN2ZWx0ZWpzL3N2ZWx0ZS1yZXBsL3NyYy9Db2RlTWlycm9yLnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9Ac3ZlbHRlanMvc3ZlbHRlLXJlcGwvc3JjL0lucHV0L0NvbXBvbmVudFNlbGVjdG9yLnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9Ac3ZlbHRlanMvc3ZlbHRlLXJlcGwvc3JjL0lucHV0L01vZHVsZUVkaXRvci5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHN2ZWx0ZWpzL3N2ZWx0ZS1yZXBsL25vZGVfbW9kdWxlcy9zb3VyY2VtYXAtY29kZWMvZGlzdC9zb3VyY2VtYXAtY29kZWMuZXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHN2ZWx0ZWpzL3N2ZWx0ZS1yZXBsL3NyYy9PdXRwdXQvZ2V0TG9jYXRpb25Gcm9tU3RhY2suanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHN2ZWx0ZWpzL3N2ZWx0ZS1yZXBsL3NyYy9PdXRwdXQvUmVwbFByb3h5LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BzdmVsdGVqcy9zdmVsdGUtcmVwbC9zcmMvT3V0cHV0L3NyY2RvYy9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9Ac3ZlbHRlanMvc3ZlbHRlLXJlcGwvc3JjL091dHB1dC9WaWV3ZXIuc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BzdmVsdGVqcy9zdmVsdGUtcmVwbC9zcmMvT3V0cHV0L0NvbXBpbGVyT3B0aW9ucy5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHN2ZWx0ZWpzL3N2ZWx0ZS1yZXBsL3NyYy9PdXRwdXQvQ29tcGlsZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHN2ZWx0ZWpzL3N2ZWx0ZS1yZXBsL3NyYy9PdXRwdXQvaW5kZXguc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BzdmVsdGVqcy9zdmVsdGUtcmVwbC9zcmMvQnVuZGxlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9Ac3ZlbHRlanMvc3ZlbHRlLXJlcGwvc3JjL1JlcGwuc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBkZWZhdWx0X3NvcnQgPSBmdW5jdGlvbiAoaXRlbSwgbmVlZGxlKSB7IHJldHVybiBpdGVtIC0gbmVlZGxlOyB9O1xuZnVuY3Rpb24gYmluYXJ5U2VhcmNoKGFycmF5LCBzZWFyY2gsIGZuKSB7XG4gICAgaWYgKGZuID09PSB2b2lkIDApIHsgZm4gPSBkZWZhdWx0X3NvcnQ7IH1cbiAgICB2YXIgbG93ID0gMDtcbiAgICB2YXIgaGlnaCA9IGFycmF5Lmxlbmd0aCAtIDE7XG4gICAgdmFyIHNvcnQgPSBmbi5sZW5ndGggPT09IDFcbiAgICAgICAgPyBmdW5jdGlvbiAoaXRlbSwgbmVlZGxlKSB7IHJldHVybiBmbihpdGVtKSAtIHNlYXJjaDsgfVxuICAgICAgICA6IGZuO1xuICAgIHdoaWxlIChsb3cgPD0gaGlnaCkge1xuICAgICAgICB2YXIgaSA9IChoaWdoICsgbG93KSA+PiAxO1xuICAgICAgICB2YXIgZCA9IHNvcnQoYXJyYXlbaV0sIHNlYXJjaCk7XG4gICAgICAgIGlmIChkIDwgMCkge1xuICAgICAgICAgICAgbG93ID0gaSArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZCA+IDApIHtcbiAgICAgICAgICAgIGhpZ2ggPSBpIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtbG93IC0gMTtcbn1cblxuZnVuY3Rpb24gcGlja1JhbmRvbShhcnJheSkge1xuICAgIHZhciBpID0gfn4oTWF0aC5yYW5kb20oKSAqIGFycmF5Lmxlbmd0aCk7XG4gICAgcmV0dXJuIGFycmF5W2ldO1xufVxuXG4vLyBodHRwOi8vYm9zdC5vY2tzLm9yZy9taWtlL3NodWZmbGUvXG5mdW5jdGlvbiBzaHVmZmxlKGFycmF5KSB7XG4gICAgdmFyIG0gPSBhcnJheS5sZW5ndGg7XG4gICAgLy8gV2hpbGUgdGhlcmUgcmVtYWluIGVsZW1lbnRzIHRvIHNodWZmbGXigKZcbiAgICB3aGlsZSAobSA+IDApIHtcbiAgICAgICAgLy8gUGljayBhIHJlbWFpbmluZyBlbGVtZW504oCmXG4gICAgICAgIHZhciBpID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbS0tKTtcbiAgICAgICAgLy8gQW5kIHN3YXAgaXQgd2l0aCB0aGUgY3VycmVudCBlbGVtZW50LlxuICAgICAgICB2YXIgdCA9IGFycmF5W21dO1xuICAgICAgICBhcnJheVttXSA9IGFycmF5W2ldO1xuICAgICAgICBhcnJheVtpXSA9IHQ7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cblxuZnVuY3Rpb24gcXVldWUobWF4KSB7XG4gICAgaWYgKG1heCA9PT0gdm9pZCAwKSB7IG1heCA9IDQ7IH1cbiAgICB2YXIgaXRlbXMgPSBbXTsgLy8gVE9ET1xuICAgIHZhciBwZW5kaW5nID0gMDtcbiAgICB2YXIgY2xvc2VkID0gZmFsc2U7XG4gICAgdmFyIGZ1bGZpbF9jbG9zZWQ7XG4gICAgZnVuY3Rpb24gZGVxdWV1ZSgpIHtcbiAgICAgICAgaWYgKHBlbmRpbmcgPT09IDAgJiYgaXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoZnVsZmlsX2Nsb3NlZClcbiAgICAgICAgICAgICAgICBmdWxmaWxfY2xvc2VkKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBlbmRpbmcgPj0gbWF4KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoaXRlbXMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBwZW5kaW5nICs9IDE7XG4gICAgICAgIHZhciBfYSA9IGl0ZW1zLnNoaWZ0KCksIGZuID0gX2EuZm4sIGZ1bGZpbCA9IF9hLmZ1bGZpbCwgcmVqZWN0ID0gX2EucmVqZWN0O1xuICAgICAgICB2YXIgcHJvbWlzZSA9IGZuKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwcm9taXNlLnRoZW4oZnVsZmlsLCByZWplY3QpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHBlbmRpbmcgLT0gMTtcbiAgICAgICAgICAgICAgICBkZXF1ZXVlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIHBlbmRpbmcgLT0gMTtcbiAgICAgICAgICAgIGRlcXVldWUoKTtcbiAgICAgICAgfVxuICAgICAgICBkZXF1ZXVlKCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGFkZDogZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICBpZiAoY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFkZCB0byBhIGNsb3NlZCBxdWV1ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKHsgZm46IGZuLCBmdWxmaWw6IGZ1bGZpbCwgcmVqZWN0OiByZWplY3QgfSk7XG4gICAgICAgICAgICAgICAgZGVxdWV1ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjbG9zZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWwsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIGlmIChwZW5kaW5nID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bGZpbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZnVsZmlsX2Nsb3NlZCA9IGZ1bGZpbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNwcml0ZSh3aWR0aCwgaGVpZ2h0LCBmbikge1xuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBmbihjdHgsIGNhbnZhcyk7XG4gICAgcmV0dXJuIGNhbnZhcztcbn1cblxuZnVuY3Rpb24gY2xhbXAobnVtLCBtaW4sIG1heCkge1xuICAgIHJldHVybiBudW0gPCBtaW4gPyBtaW4gOiBudW0gPiBtYXggPyBtYXggOiBudW07XG59XG5cbmZ1bmN0aW9uIHJhbmRvbShhLCBiKSB7XG4gICAgaWYgKGIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIE1hdGgucmFuZG9tKCkgKiBhO1xuICAgIHJldHVybiBhICsgTWF0aC5yYW5kb20oKSAqIChiIC0gYSk7XG59XG5cbmZ1bmN0aW9uIGxpbmVhcihkb21haW4sIHJhbmdlKSB7XG4gICAgdmFyIGQwID0gZG9tYWluWzBdO1xuICAgIHZhciByMCA9IHJhbmdlWzBdO1xuICAgIHZhciBtID0gKHJhbmdlWzFdIC0gcjApIC8gKGRvbWFpblsxXSAtIGQwKTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihmdW5jdGlvbiAobnVtKSB7XG4gICAgICAgIHJldHVybiByMCArIChudW0gLSBkMCkgKiBtO1xuICAgIH0sIHtcbiAgICAgICAgaW52ZXJzZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGluZWFyKHJhbmdlLCBkb21haW4pOyB9XG4gICAgfSk7XG59XG5cbi8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzI5MDExMDIvaG93LXRvLXByaW50LWEtbnVtYmVyLXdpdGgtY29tbWFzLWFzLXRob3VzYW5kcy1zZXBhcmF0b3JzLWluLWphdmFzY3JpcHRcbmZ1bmN0aW9uIGNvbW1hcyhudW0pIHtcbiAgICB2YXIgcGFydHMgPSBTdHJpbmcobnVtKS5zcGxpdCgnLicpO1xuICAgIHBhcnRzWzBdID0gcGFydHNbMF0ucmVwbGFjZSgvXFxCKD89KFxcZHszfSkrKD8hXFxkKSkvZywgJywnKTtcbiAgICByZXR1cm4gcGFydHMuam9pbignLicpO1xufVxuXG4vLyBhcnJheVxuXG5leHBvcnQgeyBiaW5hcnlTZWFyY2gsIHBpY2tSYW5kb20sIHNodWZmbGUsIHF1ZXVlLCBjcmVhdGVTcHJpdGUsIGNsYW1wLCByYW5kb20sIGxpbmVhciBhcyBsaW5lYXJTY2FsZSwgY29tbWFzIH07XG4iLCI8c2NyaXB0PlxuXHRpbXBvcnQgKiBhcyB5b290aWxzIGZyb20gJ3lvb3RpbHMnO1xuXHRpbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tICdzdmVsdGUnO1xuXG5cdGNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCk7XG5cblx0ZXhwb3J0IGxldCB0eXBlO1xuXHRleHBvcnQgbGV0IHBvcyA9IDUwO1xuXHRleHBvcnQgbGV0IGZpeGVkID0gZmFsc2U7XG5cdGV4cG9ydCBsZXQgbWluID0gNTA7XG5cdC8vIGV4cG9ydCBsZXQgbWluMSA9IG1pbjtcblx0Ly8gZXhwb3J0IGxldCBtaW4yID0gbWluO1xuXG5cdGNvbnN0IHJlZnMgPSB7fTtcblxuXHRsZXQgZHJhZ2dpbmcgPSBmYWxzZTtcblxuXHRmdW5jdGlvbiBzZXRQb3MoZXZlbnQpIHtcblx0XHRjb25zdCB7IHRvcCwgYm90dG9tLCBsZWZ0LCByaWdodCB9ID0gcmVmcy5jb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHRjb25zdCBleHRlbnRzID0gdHlwZSA9PT0gJ3ZlcnRpY2FsJyA/IFt0b3AsIGJvdHRvbV0gOiBbbGVmdCwgcmlnaHRdO1xuXG5cdFx0Y29uc3QgcHggPSB5b290aWxzLmNsYW1wKFxuXHRcdFx0dHlwZSA9PT0gJ3ZlcnRpY2FsJyA/IGV2ZW50LmNsaWVudFkgOiBldmVudC5jbGllbnRYLFxuXHRcdFx0ZXh0ZW50c1swXSArIG1pbixcblx0XHRcdGV4dGVudHNbMV0gLSBtaW5cblx0XHQpO1xuXG5cdFx0cG9zID0gMTAwICogKHB4IC0gZXh0ZW50c1swXSkgLyAoZXh0ZW50c1sxXSAtIGV4dGVudHNbMF0pO1xuXG5cdFx0ZGlzcGF0Y2goJ2NoYW5nZScpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZHJhZyhub2RlLCBjYWxsYmFjaykge1xuXHRcdGNvbnN0IG1vdXNlZG93biA9IGV2ZW50ID0+IHtcblx0XHRcdGlmIChldmVudC53aGljaCAhPT0gMSkgcmV0dXJuO1xuXG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0XHRkcmFnZ2luZyA9IHRydWU7XG5cblx0XHRcdGNvbnN0IG9ubW91c2V1cCA9ICgpID0+IHtcblx0XHRcdFx0ZHJhZ2dpbmcgPSBmYWxzZTtcblxuXHRcdFx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgY2FsbGJhY2ssIGZhbHNlKTtcblx0XHRcdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBvbm1vdXNldXAsIGZhbHNlKTtcblx0XHRcdH07XG5cblx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBjYWxsYmFjaywgZmFsc2UpO1xuXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBvbm1vdXNldXAsIGZhbHNlKTtcblx0XHR9XG5cblx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG1vdXNlZG93biwgZmFsc2UpO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGRlc3Ryb3koKSB7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgb25tb3VzZWRvd24sIGZhbHNlKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblx0JDogc2lkZSA9IHR5cGUgPT09ICdob3Jpem9udGFsJyA/ICdsZWZ0JyA6ICd0b3AnO1xuXHQkOiBkaW1lbnNpb24gPSB0eXBlID09PSAnaG9yaXpvbnRhbCcgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuXHQuY29udGFpbmVyIHtcblx0XHRwb3NpdGlvbjogcmVsYXRpdmU7XG5cdFx0d2lkdGg6IDEwMCU7XG5cdFx0aGVpZ2h0OiAxMDAlO1xuXHR9XG5cblx0LnBhbmUge1xuXHRcdHBvc2l0aW9uOiByZWxhdGl2ZTtcblx0XHRmbG9hdDogbGVmdDtcblx0XHR3aWR0aDogMTAwJTtcblx0XHRoZWlnaHQ6IDEwMCU7XG5cdH1cblxuXHQubW91c2VjYXRjaGVyIHtcblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0bGVmdDogMDtcblx0XHR0b3A6IDA7XG5cdFx0d2lkdGg6IDEwMCU7XG5cdFx0aGVpZ2h0OiAxMDAlO1xuXHRcdGJhY2tncm91bmQ6IHJnYmEoMjU1LDI1NSwyNTUsLjAxKTtcblx0fVxuXG5cdC5kaXZpZGVyIHtcblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0ei1pbmRleDogMTA7XG5cdFx0ZGlzcGxheTogbm9uZTtcblx0fVxuXG5cdC5kaXZpZGVyOjphZnRlciB7XG5cdFx0Y29udGVudDogJyc7XG5cdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdC8qIGJhY2tncm91bmQtY29sb3I6ICNlZWU7ICovXG5cdFx0YmFja2dyb3VuZC1jb2xvcjogdmFyKC0tc2Vjb25kKTtcblx0fVxuXG5cdC5ob3Jpem9udGFsIHtcblx0XHRwYWRkaW5nOiAwIDhweDtcblx0XHR3aWR0aDogMDtcblx0XHRoZWlnaHQ6IDEwMCU7XG5cdFx0Y3Vyc29yOiBldy1yZXNpemU7XG5cdH1cblxuXHQuaG9yaXpvbnRhbDo6YWZ0ZXIge1xuXHRcdGxlZnQ6IDhweDtcblx0XHR0b3A6IDA7XG5cdFx0d2lkdGg6IDFweDtcblx0XHRoZWlnaHQ6IDEwMCU7XG5cdH1cblxuXHQudmVydGljYWwge1xuXHRcdHBhZGRpbmc6IDhweCAwO1xuXHRcdHdpZHRoOiAxMDAlO1xuXHRcdGhlaWdodDogMDtcblx0XHRjdXJzb3I6IG5zLXJlc2l6ZTtcblx0fVxuXG5cdC52ZXJ0aWNhbDo6YWZ0ZXIge1xuXHRcdHRvcDogOHB4O1xuXHRcdGxlZnQ6IDA7XG5cdFx0d2lkdGg6IDEwMCU7XG5cdFx0aGVpZ2h0OiAxcHg7XG5cdH1cblxuXHQubGVmdCwgLnJpZ2h0LCAuZGl2aWRlciB7XG5cdFx0ZGlzcGxheTogYmxvY2s7XG5cdH1cblxuXHQubGVmdCwgLnJpZ2h0IHtcblx0XHRoZWlnaHQ6IDEwMCU7XG5cdFx0ZmxvYXQ6IGxlZnQ7XG5cdH1cblxuXHQudG9wLCAuYm90dG9tIHtcblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0d2lkdGg6IDEwMCU7XG5cdH1cblxuXHQudG9wIHsgdG9wOiAwOyB9XG5cdC5ib3R0b20geyBib3R0b206IDA7IH1cbjwvc3R5bGU+XG5cbjxkaXYgY2xhc3M9XCJjb250YWluZXJcIiBiaW5kOnRoaXM9e3JlZnMuY29udGFpbmVyfT5cblx0PGRpdiBjbGFzcz1cInBhbmVcIiBzdHlsZT1cIntkaW1lbnNpb259OiB7cG9zfSU7XCI+XG5cdFx0PHNsb3QgbmFtZT1cImFcIj48L3Nsb3Q+XG5cdDwvZGl2PlxuXG5cdDxkaXYgY2xhc3M9XCJwYW5lXCIgc3R5bGU9XCJ7ZGltZW5zaW9ufTogezEwMCAtIChwb3MpfSU7XCI+XG5cdFx0PHNsb3QgbmFtZT1cImJcIj48L3Nsb3Q+XG5cdDwvZGl2PlxuXG5cdHsjaWYgIWZpeGVkfVxuXHRcdDxkaXYgY2xhc3M9XCJ7dHlwZX0gZGl2aWRlclwiIHN0eWxlPVwie3NpZGV9OiBjYWxjKHtwb3N9JSAtIDhweClcIiB1c2U6ZHJhZz17c2V0UG9zfT48L2Rpdj5cblx0ey9pZn1cbjwvZGl2PlxuXG57I2lmIGRyYWdnaW5nfVxuXHQ8ZGl2IGNsYXNzPVwibW91c2VjYXRjaGVyXCI+PC9kaXY+XG57L2lmfSIsImV4cG9ydCBjb25zdCBpc19icm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7IiwiZXhwb3J0IHsgaWRlbnRpdHkgYXMgbGluZWFyIH0gZnJvbSAnLi4vaW50ZXJuYWwnO1xuXG4vKlxuQWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXR0ZGVzbFxuRGlzdHJpYnV0ZWQgdW5kZXIgTUlUIExpY2Vuc2UgaHR0cHM6Ly9naXRodWIuY29tL21hdHRkZXNsL2Vhc2VzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWRcbiovXG5mdW5jdGlvbiBiYWNrSW5PdXQodCkge1xuICAgIGNvbnN0IHMgPSAxLjcwMTU4ICogMS41MjU7XG4gICAgaWYgKCh0ICo9IDIpIDwgMSlcbiAgICAgICAgcmV0dXJuIDAuNSAqICh0ICogdCAqICgocyArIDEpICogdCAtIHMpKTtcbiAgICByZXR1cm4gMC41ICogKCh0IC09IDIpICogdCAqICgocyArIDEpICogdCArIHMpICsgMik7XG59XG5mdW5jdGlvbiBiYWNrSW4odCkge1xuICAgIGNvbnN0IHMgPSAxLjcwMTU4O1xuICAgIHJldHVybiB0ICogdCAqICgocyArIDEpICogdCAtIHMpO1xufVxuZnVuY3Rpb24gYmFja091dCh0KSB7XG4gICAgY29uc3QgcyA9IDEuNzAxNTg7XG4gICAgcmV0dXJuIC0tdCAqIHQgKiAoKHMgKyAxKSAqIHQgKyBzKSArIDE7XG59XG5mdW5jdGlvbiBib3VuY2VPdXQodCkge1xuICAgIGNvbnN0IGEgPSA0LjAgLyAxMS4wO1xuICAgIGNvbnN0IGIgPSA4LjAgLyAxMS4wO1xuICAgIGNvbnN0IGMgPSA5LjAgLyAxMC4wO1xuICAgIGNvbnN0IGNhID0gNDM1Ni4wIC8gMzYxLjA7XG4gICAgY29uc3QgY2IgPSAzNTQ0Mi4wIC8gMTgwNS4wO1xuICAgIGNvbnN0IGNjID0gMTYwNjEuMCAvIDE4MDUuMDtcbiAgICBjb25zdCB0MiA9IHQgKiB0O1xuICAgIHJldHVybiB0IDwgYVxuICAgICAgICA/IDcuNTYyNSAqIHQyXG4gICAgICAgIDogdCA8IGJcbiAgICAgICAgICAgID8gOS4wNzUgKiB0MiAtIDkuOSAqIHQgKyAzLjRcbiAgICAgICAgICAgIDogdCA8IGNcbiAgICAgICAgICAgICAgICA/IGNhICogdDIgLSBjYiAqIHQgKyBjY1xuICAgICAgICAgICAgICAgIDogMTAuOCAqIHQgKiB0IC0gMjAuNTIgKiB0ICsgMTAuNzI7XG59XG5mdW5jdGlvbiBib3VuY2VJbk91dCh0KSB7XG4gICAgcmV0dXJuIHQgPCAwLjVcbiAgICAgICAgPyAwLjUgKiAoMS4wIC0gYm91bmNlT3V0KDEuMCAtIHQgKiAyLjApKVxuICAgICAgICA6IDAuNSAqIGJvdW5jZU91dCh0ICogMi4wIC0gMS4wKSArIDAuNTtcbn1cbmZ1bmN0aW9uIGJvdW5jZUluKHQpIHtcbiAgICByZXR1cm4gMS4wIC0gYm91bmNlT3V0KDEuMCAtIHQpO1xufVxuZnVuY3Rpb24gY2lyY0luT3V0KHQpIHtcbiAgICBpZiAoKHQgKj0gMikgPCAxKVxuICAgICAgICByZXR1cm4gLTAuNSAqIChNYXRoLnNxcnQoMSAtIHQgKiB0KSAtIDEpO1xuICAgIHJldHVybiAwLjUgKiAoTWF0aC5zcXJ0KDEgLSAodCAtPSAyKSAqIHQpICsgMSk7XG59XG5mdW5jdGlvbiBjaXJjSW4odCkge1xuICAgIHJldHVybiAxLjAgLSBNYXRoLnNxcnQoMS4wIC0gdCAqIHQpO1xufVxuZnVuY3Rpb24gY2lyY091dCh0KSB7XG4gICAgcmV0dXJuIE1hdGguc3FydCgxIC0gLS10ICogdCk7XG59XG5mdW5jdGlvbiBjdWJpY0luT3V0KHQpIHtcbiAgICByZXR1cm4gdCA8IDAuNSA/IDQuMCAqIHQgKiB0ICogdCA6IDAuNSAqIE1hdGgucG93KDIuMCAqIHQgLSAyLjAsIDMuMCkgKyAxLjA7XG59XG5mdW5jdGlvbiBjdWJpY0luKHQpIHtcbiAgICByZXR1cm4gdCAqIHQgKiB0O1xufVxuZnVuY3Rpb24gY3ViaWNPdXQodCkge1xuICAgIGNvbnN0IGYgPSB0IC0gMS4wO1xuICAgIHJldHVybiBmICogZiAqIGYgKyAxLjA7XG59XG5mdW5jdGlvbiBlbGFzdGljSW5PdXQodCkge1xuICAgIHJldHVybiB0IDwgMC41XG4gICAgICAgID8gMC41ICpcbiAgICAgICAgICAgIE1hdGguc2luKCgoKzEzLjAgKiBNYXRoLlBJKSAvIDIpICogMi4wICogdCkgKlxuICAgICAgICAgICAgTWF0aC5wb3coMi4wLCAxMC4wICogKDIuMCAqIHQgLSAxLjApKVxuICAgICAgICA6IDAuNSAqXG4gICAgICAgICAgICBNYXRoLnNpbigoKC0xMy4wICogTWF0aC5QSSkgLyAyKSAqICgyLjAgKiB0IC0gMS4wICsgMS4wKSkgKlxuICAgICAgICAgICAgTWF0aC5wb3coMi4wLCAtMTAuMCAqICgyLjAgKiB0IC0gMS4wKSkgK1xuICAgICAgICAgICAgMS4wO1xufVxuZnVuY3Rpb24gZWxhc3RpY0luKHQpIHtcbiAgICByZXR1cm4gTWF0aC5zaW4oKDEzLjAgKiB0ICogTWF0aC5QSSkgLyAyKSAqIE1hdGgucG93KDIuMCwgMTAuMCAqICh0IC0gMS4wKSk7XG59XG5mdW5jdGlvbiBlbGFzdGljT3V0KHQpIHtcbiAgICByZXR1cm4gKE1hdGguc2luKCgtMTMuMCAqICh0ICsgMS4wKSAqIE1hdGguUEkpIC8gMikgKiBNYXRoLnBvdygyLjAsIC0xMC4wICogdCkgKyAxLjApO1xufVxuZnVuY3Rpb24gZXhwb0luT3V0KHQpIHtcbiAgICByZXR1cm4gdCA9PT0gMC4wIHx8IHQgPT09IDEuMFxuICAgICAgICA/IHRcbiAgICAgICAgOiB0IDwgMC41XG4gICAgICAgICAgICA/ICswLjUgKiBNYXRoLnBvdygyLjAsIDIwLjAgKiB0IC0gMTAuMClcbiAgICAgICAgICAgIDogLTAuNSAqIE1hdGgucG93KDIuMCwgMTAuMCAtIHQgKiAyMC4wKSArIDEuMDtcbn1cbmZ1bmN0aW9uIGV4cG9Jbih0KSB7XG4gICAgcmV0dXJuIHQgPT09IDAuMCA/IHQgOiBNYXRoLnBvdygyLjAsIDEwLjAgKiAodCAtIDEuMCkpO1xufVxuZnVuY3Rpb24gZXhwb091dCh0KSB7XG4gICAgcmV0dXJuIHQgPT09IDEuMCA/IHQgOiAxLjAgLSBNYXRoLnBvdygyLjAsIC0xMC4wICogdCk7XG59XG5mdW5jdGlvbiBxdWFkSW5PdXQodCkge1xuICAgIHQgLz0gMC41O1xuICAgIGlmICh0IDwgMSlcbiAgICAgICAgcmV0dXJuIDAuNSAqIHQgKiB0O1xuICAgIHQtLTtcbiAgICByZXR1cm4gLTAuNSAqICh0ICogKHQgLSAyKSAtIDEpO1xufVxuZnVuY3Rpb24gcXVhZEluKHQpIHtcbiAgICByZXR1cm4gdCAqIHQ7XG59XG5mdW5jdGlvbiBxdWFkT3V0KHQpIHtcbiAgICByZXR1cm4gLXQgKiAodCAtIDIuMCk7XG59XG5mdW5jdGlvbiBxdWFydEluT3V0KHQpIHtcbiAgICByZXR1cm4gdCA8IDAuNVxuICAgICAgICA/ICs4LjAgKiBNYXRoLnBvdyh0LCA0LjApXG4gICAgICAgIDogLTguMCAqIE1hdGgucG93KHQgLSAxLjAsIDQuMCkgKyAxLjA7XG59XG5mdW5jdGlvbiBxdWFydEluKHQpIHtcbiAgICByZXR1cm4gTWF0aC5wb3codCwgNC4wKTtcbn1cbmZ1bmN0aW9uIHF1YXJ0T3V0KHQpIHtcbiAgICByZXR1cm4gTWF0aC5wb3codCAtIDEuMCwgMy4wKSAqICgxLjAgLSB0KSArIDEuMDtcbn1cbmZ1bmN0aW9uIHF1aW50SW5PdXQodCkge1xuICAgIGlmICgodCAqPSAyKSA8IDEpXG4gICAgICAgIHJldHVybiAwLjUgKiB0ICogdCAqIHQgKiB0ICogdDtcbiAgICByZXR1cm4gMC41ICogKCh0IC09IDIpICogdCAqIHQgKiB0ICogdCArIDIpO1xufVxuZnVuY3Rpb24gcXVpbnRJbih0KSB7XG4gICAgcmV0dXJuIHQgKiB0ICogdCAqIHQgKiB0O1xufVxuZnVuY3Rpb24gcXVpbnRPdXQodCkge1xuICAgIHJldHVybiAtLXQgKiB0ICogdCAqIHQgKiB0ICsgMTtcbn1cbmZ1bmN0aW9uIHNpbmVJbk91dCh0KSB7XG4gICAgcmV0dXJuIC0wLjUgKiAoTWF0aC5jb3MoTWF0aC5QSSAqIHQpIC0gMSk7XG59XG5mdW5jdGlvbiBzaW5lSW4odCkge1xuICAgIGNvbnN0IHYgPSBNYXRoLmNvcyh0ICogTWF0aC5QSSAqIDAuNSk7XG4gICAgaWYgKE1hdGguYWJzKHYpIDwgMWUtMTQpXG4gICAgICAgIHJldHVybiAxO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIDEgLSB2O1xufVxuZnVuY3Rpb24gc2luZU91dCh0KSB7XG4gICAgcmV0dXJuIE1hdGguc2luKCh0ICogTWF0aC5QSSkgLyAyKTtcbn1cblxuZXhwb3J0IHsgYmFja0luLCBiYWNrSW5PdXQsIGJhY2tPdXQsIGJvdW5jZUluLCBib3VuY2VJbk91dCwgYm91bmNlT3V0LCBjaXJjSW4sIGNpcmNJbk91dCwgY2lyY091dCwgY3ViaWNJbiwgY3ViaWNJbk91dCwgY3ViaWNPdXQsIGVsYXN0aWNJbiwgZWxhc3RpY0luT3V0LCBlbGFzdGljT3V0LCBleHBvSW4sIGV4cG9Jbk91dCwgZXhwb091dCwgcXVhZEluLCBxdWFkSW5PdXQsIHF1YWRPdXQsIHF1YXJ0SW4sIHF1YXJ0SW5PdXQsIHF1YXJ0T3V0LCBxdWludEluLCBxdWludEluT3V0LCBxdWludE91dCwgc2luZUluLCBzaW5lSW5PdXQsIHNpbmVPdXQgfTtcbiIsImltcG9ydCB7IGN1YmljSW5PdXQsIGN1YmljT3V0IH0gZnJvbSAnLi4vZWFzaW5nJztcbmltcG9ydCB7IGlzX2Z1bmN0aW9uLCBhc3NpZ24gfSBmcm9tICcuLi9pbnRlcm5hbCc7XG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG5mdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cblxuZnVuY3Rpb24gYmx1cihub2RlLCB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSA0MDAsIGVhc2luZyA9IGN1YmljSW5PdXQsIGFtb3VudCA9IDUsIG9wYWNpdHkgPSAwIH0pIHtcbiAgICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgY29uc3QgdGFyZ2V0X29wYWNpdHkgPSArc3R5bGUub3BhY2l0eTtcbiAgICBjb25zdCBmID0gc3R5bGUuZmlsdGVyID09PSAnbm9uZScgPyAnJyA6IHN0eWxlLmZpbHRlcjtcbiAgICBjb25zdCBvZCA9IHRhcmdldF9vcGFjaXR5ICogKDEgLSBvcGFjaXR5KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZWxheSxcbiAgICAgICAgZHVyYXRpb24sXG4gICAgICAgIGVhc2luZyxcbiAgICAgICAgY3NzOiAoX3QsIHUpID0+IGBvcGFjaXR5OiAke3RhcmdldF9vcGFjaXR5IC0gKG9kICogdSl9OyBmaWx0ZXI6ICR7Zn0gYmx1cigke3UgKiBhbW91bnR9cHgpO2BcbiAgICB9O1xufVxuZnVuY3Rpb24gZmFkZShub2RlLCB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSA0MDAgfSkge1xuICAgIGNvbnN0IG8gPSArZ2V0Q29tcHV0ZWRTdHlsZShub2RlKS5vcGFjaXR5O1xuICAgIHJldHVybiB7XG4gICAgICAgIGRlbGF5LFxuICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgY3NzOiB0ID0+IGBvcGFjaXR5OiAke3QgKiBvfWBcbiAgICB9O1xufVxuZnVuY3Rpb24gZmx5KG5vZGUsIHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDQwMCwgZWFzaW5nID0gY3ViaWNPdXQsIHggPSAwLCB5ID0gMCwgb3BhY2l0eSA9IDAgfSkge1xuICAgIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICBjb25zdCB0YXJnZXRfb3BhY2l0eSA9ICtzdHlsZS5vcGFjaXR5O1xuICAgIGNvbnN0IHRyYW5zZm9ybSA9IHN0eWxlLnRyYW5zZm9ybSA9PT0gJ25vbmUnID8gJycgOiBzdHlsZS50cmFuc2Zvcm07XG4gICAgY29uc3Qgb2QgPSB0YXJnZXRfb3BhY2l0eSAqICgxIC0gb3BhY2l0eSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVsYXksXG4gICAgICAgIGR1cmF0aW9uLFxuICAgICAgICBlYXNpbmcsXG4gICAgICAgIGNzczogKHQsIHUpID0+IGBcblx0XHRcdHRyYW5zZm9ybTogJHt0cmFuc2Zvcm19IHRyYW5zbGF0ZSgkeygxIC0gdCkgKiB4fXB4LCAkeygxIC0gdCkgKiB5fXB4KTtcblx0XHRcdG9wYWNpdHk6ICR7dGFyZ2V0X29wYWNpdHkgLSAob2QgKiB1KX1gXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHNsaWRlKG5vZGUsIHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDQwMCwgZWFzaW5nID0gY3ViaWNPdXQgfSkge1xuICAgIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICBjb25zdCBvcGFjaXR5ID0gK3N0eWxlLm9wYWNpdHk7XG4gICAgY29uc3QgaGVpZ2h0ID0gcGFyc2VGbG9hdChzdHlsZS5oZWlnaHQpO1xuICAgIGNvbnN0IHBhZGRpbmdfdG9wID0gcGFyc2VGbG9hdChzdHlsZS5wYWRkaW5nVG9wKTtcbiAgICBjb25zdCBwYWRkaW5nX2JvdHRvbSA9IHBhcnNlRmxvYXQoc3R5bGUucGFkZGluZ0JvdHRvbSk7XG4gICAgY29uc3QgbWFyZ2luX3RvcCA9IHBhcnNlRmxvYXQoc3R5bGUubWFyZ2luVG9wKTtcbiAgICBjb25zdCBtYXJnaW5fYm90dG9tID0gcGFyc2VGbG9hdChzdHlsZS5tYXJnaW5Cb3R0b20pO1xuICAgIGNvbnN0IGJvcmRlcl90b3Bfd2lkdGggPSBwYXJzZUZsb2F0KHN0eWxlLmJvcmRlclRvcFdpZHRoKTtcbiAgICBjb25zdCBib3JkZXJfYm90dG9tX3dpZHRoID0gcGFyc2VGbG9hdChzdHlsZS5ib3JkZXJCb3R0b21XaWR0aCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVsYXksXG4gICAgICAgIGR1cmF0aW9uLFxuICAgICAgICBlYXNpbmcsXG4gICAgICAgIGNzczogdCA9PiBgb3ZlcmZsb3c6IGhpZGRlbjtgICtcbiAgICAgICAgICAgIGBvcGFjaXR5OiAke01hdGgubWluKHQgKiAyMCwgMSkgKiBvcGFjaXR5fTtgICtcbiAgICAgICAgICAgIGBoZWlnaHQ6ICR7dCAqIGhlaWdodH1weDtgICtcbiAgICAgICAgICAgIGBwYWRkaW5nLXRvcDogJHt0ICogcGFkZGluZ190b3B9cHg7YCArXG4gICAgICAgICAgICBgcGFkZGluZy1ib3R0b206ICR7dCAqIHBhZGRpbmdfYm90dG9tfXB4O2AgK1xuICAgICAgICAgICAgYG1hcmdpbi10b3A6ICR7dCAqIG1hcmdpbl90b3B9cHg7YCArXG4gICAgICAgICAgICBgbWFyZ2luLWJvdHRvbTogJHt0ICogbWFyZ2luX2JvdHRvbX1weDtgICtcbiAgICAgICAgICAgIGBib3JkZXItdG9wLXdpZHRoOiAke3QgKiBib3JkZXJfdG9wX3dpZHRofXB4O2AgK1xuICAgICAgICAgICAgYGJvcmRlci1ib3R0b20td2lkdGg6ICR7dCAqIGJvcmRlcl9ib3R0b21fd2lkdGh9cHg7YFxuICAgIH07XG59XG5mdW5jdGlvbiBzY2FsZShub2RlLCB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSA0MDAsIGVhc2luZyA9IGN1YmljT3V0LCBzdGFydCA9IDAsIG9wYWNpdHkgPSAwIH0pIHtcbiAgICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgY29uc3QgdGFyZ2V0X29wYWNpdHkgPSArc3R5bGUub3BhY2l0eTtcbiAgICBjb25zdCB0cmFuc2Zvcm0gPSBzdHlsZS50cmFuc2Zvcm0gPT09ICdub25lJyA/ICcnIDogc3R5bGUudHJhbnNmb3JtO1xuICAgIGNvbnN0IHNkID0gMSAtIHN0YXJ0O1xuICAgIGNvbnN0IG9kID0gdGFyZ2V0X29wYWNpdHkgKiAoMSAtIG9wYWNpdHkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRlbGF5LFxuICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgZWFzaW5nLFxuICAgICAgICBjc3M6IChfdCwgdSkgPT4gYFxuXHRcdFx0dHJhbnNmb3JtOiAke3RyYW5zZm9ybX0gc2NhbGUoJHsxIC0gKHNkICogdSl9KTtcblx0XHRcdG9wYWNpdHk6ICR7dGFyZ2V0X29wYWNpdHkgLSAob2QgKiB1KX1cblx0XHRgXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGRyYXcobm9kZSwgeyBkZWxheSA9IDAsIHNwZWVkLCBkdXJhdGlvbiwgZWFzaW5nID0gY3ViaWNJbk91dCB9KSB7XG4gICAgY29uc3QgbGVuID0gbm9kZS5nZXRUb3RhbExlbmd0aCgpO1xuICAgIGlmIChkdXJhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChzcGVlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IDgwMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0gbGVuIC8gc3BlZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGR1cmF0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGR1cmF0aW9uID0gZHVyYXRpb24obGVuKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVsYXksXG4gICAgICAgIGR1cmF0aW9uLFxuICAgICAgICBlYXNpbmcsXG4gICAgICAgIGNzczogKHQsIHUpID0+IGBzdHJva2UtZGFzaGFycmF5OiAke3QgKiBsZW59ICR7dSAqIGxlbn1gXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyb3NzZmFkZShfYSkge1xuICAgIHZhciB7IGZhbGxiYWNrIH0gPSBfYSwgZGVmYXVsdHMgPSBfX3Jlc3QoX2EsIFtcImZhbGxiYWNrXCJdKTtcbiAgICBjb25zdCB0b19yZWNlaXZlID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IHRvX3NlbmQgPSBuZXcgTWFwKCk7XG4gICAgZnVuY3Rpb24gY3Jvc3NmYWRlKGZyb20sIG5vZGUsIHBhcmFtcykge1xuICAgICAgICBjb25zdCB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSBkID0+IE1hdGguc3FydChkKSAqIDMwLCBlYXNpbmcgPSBjdWJpY091dCB9ID0gYXNzaWduKGFzc2lnbih7fSwgZGVmYXVsdHMpLCBwYXJhbXMpO1xuICAgICAgICBjb25zdCB0byA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnN0IGR4ID0gZnJvbS5sZWZ0IC0gdG8ubGVmdDtcbiAgICAgICAgY29uc3QgZHkgPSBmcm9tLnRvcCAtIHRvLnRvcDtcbiAgICAgICAgY29uc3QgZHcgPSBmcm9tLndpZHRoIC8gdG8ud2lkdGg7XG4gICAgICAgIGNvbnN0IGRoID0gZnJvbS5oZWlnaHQgLyB0by5oZWlnaHQ7XG4gICAgICAgIGNvbnN0IGQgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IHN0eWxlLnRyYW5zZm9ybSA9PT0gJ25vbmUnID8gJycgOiBzdHlsZS50cmFuc2Zvcm07XG4gICAgICAgIGNvbnN0IG9wYWNpdHkgPSArc3R5bGUub3BhY2l0eTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlbGF5LFxuICAgICAgICAgICAgZHVyYXRpb246IGlzX2Z1bmN0aW9uKGR1cmF0aW9uKSA/IGR1cmF0aW9uKGQpIDogZHVyYXRpb24sXG4gICAgICAgICAgICBlYXNpbmcsXG4gICAgICAgICAgICBjc3M6ICh0LCB1KSA9PiBgXG5cdFx0XHRcdG9wYWNpdHk6ICR7dCAqIG9wYWNpdHl9O1xuXHRcdFx0XHR0cmFuc2Zvcm0tb3JpZ2luOiB0b3AgbGVmdDtcblx0XHRcdFx0dHJhbnNmb3JtOiAke3RyYW5zZm9ybX0gdHJhbnNsYXRlKCR7dSAqIGR4fXB4LCR7dSAqIGR5fXB4KSBzY2FsZSgke3QgKyAoMSAtIHQpICogZHd9LCAke3QgKyAoMSAtIHQpICogZGh9KTtcblx0XHRcdGBcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdHJhbnNpdGlvbihpdGVtcywgY291bnRlcnBhcnRzLCBpbnRybykge1xuICAgICAgICByZXR1cm4gKG5vZGUsIHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgaXRlbXMuc2V0KHBhcmFtcy5rZXksIHtcbiAgICAgICAgICAgICAgICByZWN0OiBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJwYXJ0cy5oYXMocGFyYW1zLmtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyByZWN0IH0gPSBjb3VudGVycGFydHMuZ2V0KHBhcmFtcy5rZXkpO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVycGFydHMuZGVsZXRlKHBhcmFtcy5rZXkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3Jvc3NmYWRlKHJlY3QsIG5vZGUsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBub2RlIGlzIGRpc2FwcGVhcmluZyBhbHRvZ2V0aGVyXG4gICAgICAgICAgICAgICAgLy8gKGkuZS4gd2Fzbid0IGNsYWltZWQgYnkgdGhlIG90aGVyIGxpc3QpXG4gICAgICAgICAgICAgICAgLy8gdGhlbiB3ZSBuZWVkIHRvIHN1cHBseSBhbiBvdXRyb1xuICAgICAgICAgICAgICAgIGl0ZW1zLmRlbGV0ZShwYXJhbXMua2V5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsbGJhY2sgJiYgZmFsbGJhY2sobm9kZSwgcGFyYW1zLCBpbnRybyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgICB0cmFuc2l0aW9uKHRvX3NlbmQsIHRvX3JlY2VpdmUsIGZhbHNlKSxcbiAgICAgICAgdHJhbnNpdGlvbih0b19yZWNlaXZlLCB0b19zZW5kLCB0cnVlKVxuICAgIF07XG59XG5cbmV4cG9ydCB7IGJsdXIsIGNyb3NzZmFkZSwgZHJhdywgZmFkZSwgZmx5LCBzY2FsZSwgc2xpZGUgfTtcbiIsIjxzY3JpcHQ+XG5cdGltcG9ydCB7IGdldENvbnRleHQgfSBmcm9tICdzdmVsdGUnO1xuXHRpbXBvcnQgeyBzbGlkZSB9IGZyb20gJ3N2ZWx0ZS90cmFuc2l0aW9uJztcblxuXHRjb25zdCB7IG5hdmlnYXRlIH0gPSBnZXRDb250ZXh0KCdSRVBMJyk7XG5cblx0ZXhwb3J0IGxldCBraW5kO1xuXHRleHBvcnQgbGV0IGRldGFpbHMgPSBudWxsO1xuXHRleHBvcnQgbGV0IGZpbGVuYW1lID0gbnVsbDtcblx0ZXhwb3J0IGxldCB0cnVuY2F0ZTtcblxuXHRmdW5jdGlvbiBtZXNzYWdlKGRldGFpbHMpIHtcblx0XHRsZXQgc3RyID0gZGV0YWlscy5tZXNzYWdlIHx8ICdbbWlzc2luZyBtZXNzYWdlXSc7XG5cblx0XHRsZXQgbG9jID0gW107XG5cblx0XHRpZiAoZGV0YWlscy5maWxlbmFtZSAmJiBkZXRhaWxzLmZpbGVuYW1lICE9PSBmaWxlbmFtZSkge1xuXHRcdFx0bG9jLnB1c2goZGV0YWlscy5maWxlbmFtZSk7XG5cdFx0fVxuXG5cdFx0aWYgKGRldGFpbHMuc3RhcnQpIGxvYy5wdXNoKGRldGFpbHMuc3RhcnQubGluZSwgZGV0YWlscy5zdGFydC5jb2x1bW4pO1xuXG5cdFx0cmV0dXJuIHN0ciArIChsb2MubGVuZ3RoID8gYCAoJHtsb2Muam9pbignOicpfSlgIDogYGApO1xuXHR9O1xuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cblx0Lm1lc3NhZ2Uge1xuXHRcdHBvc2l0aW9uOiByZWxhdGl2ZTtcblx0XHRjb2xvcjogd2hpdGU7XG5cdFx0cGFkZGluZzogMTJweCAxNnB4IDEycHggNDRweDtcblx0XHRmb250OiA0MDAgMTJweC8xLjcgdmFyKC0tZm9udCk7XG5cdFx0bWFyZ2luOiAwO1xuXHRcdGJvcmRlci10b3A6IDFweCBzb2xpZCB3aGl0ZTtcblx0fVxuXG5cdC5uYXZpZ2FibGUge1xuXHRcdGN1cnNvcjogcG9pbnRlcjtcblx0fVxuXG5cdC5tZXNzYWdlOjpiZWZvcmUge1xuXHRcdGNvbnRlbnQ6ICchJztcblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0bGVmdDogMTJweDtcblx0XHR0b3A6IDEwcHg7XG5cdFx0dGV4dC1hbGlnbjogY2VudGVyO1xuXHRcdGxpbmUtaGVpZ2h0OiAxO1xuXHRcdHBhZGRpbmc6IDRweDtcblx0XHRib3JkZXItcmFkaXVzOiA1MCU7XG5cdFx0Y29sb3I6IHdoaXRlO1xuXHRcdGJvcmRlcjogMnB4IHNvbGlkIHdoaXRlO1xuXHRcdGJveC1zaXppbmc6IGNvbnRlbnQtYm94O1xuXHRcdHdpZHRoOiAxMHB4O1xuXHRcdGhlaWdodDogMTBweDtcblx0XHRmb250LXNpemU6IDExcHg7XG5cdFx0Zm9udC13ZWlnaHQ6IDcwMDtcblx0fVxuXG5cdC50cnVuY2F0ZSB7XG5cdFx0d2hpdGUtc3BhY2U6IHByZTtcblx0XHRvdmVyZmxvdy14OiBoaWRkZW47XG5cdFx0dGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XG5cdH1cblxuXHRwIHtcblx0XHRtYXJnaW46IDA7XG5cdH1cblxuXHQuaW5mbyB7XG5cdFx0YmFja2dyb3VuZC1jb2xvcjogdmFyKC0tc2Vjb25kKTtcblx0fVxuXG5cdC5lcnJvciB7XG5cdFx0YmFja2dyb3VuZC1jb2xvcjogI2RhMTA2ZTtcblx0fVxuXG5cdC53YXJuaW5nIHtcblx0XHRiYWNrZ3JvdW5kLWNvbG9yOiAjZTQ3ZTBhO1xuXHR9XG48L3N0eWxlPlxuXG48ZGl2IGluOnNsaWRlPXt7ZGVsYXk6IDE1MCwgZHVyYXRpb246IDEwMH19IG91dDpzbGlkZT17e2R1cmF0aW9uOiAxMDB9fSBjbGFzcz1cIm1lc3NhZ2Uge2tpbmR9XCIgY2xhc3M6dHJ1bmNhdGU+XG5cdHsjaWYgZGV0YWlsc31cblx0XHQ8cFxuXHRcdFx0Y2xhc3M6bmF2aWdhYmxlPXtkZXRhaWxzLmZpbGVuYW1lfVxuXHRcdFx0b246Y2xpY2s9XCJ7KCkgPT4gbmF2aWdhdGUoZGV0YWlscyl9XCJcblx0XHQ+e21lc3NhZ2UoZGV0YWlscyl9PC9wPlxuXHR7OmVsc2V9XG5cdFx0PHNsb3Q+PC9zbG90PlxuXHR7L2lmfVxuPC9kaXY+IiwiPHNjcmlwdCBjb250ZXh0PVwibW9kdWxlXCI+XG5cdGltcG9ydCB7IGlzX2Jyb3dzZXIgfSBmcm9tICcuL2Vudi5qcyc7XG5cblx0bGV0IGNvZGVtaXJyb3JfcHJvbWlzZTtcblx0bGV0IF9Db2RlTWlycm9yO1xuXG5cdGlmIChpc19icm93c2VyKSB7XG5cdFx0Y29kZW1pcnJvcl9wcm9taXNlID0gaW1wb3J0KC8qIHdlYnBhY2tDaHVua05hbWU6IFwiY29kZW1pcnJvclwiICovICcuL2NvZGVtaXJyb3IuanMnKTtcblxuXHRcdGNvZGVtaXJyb3JfcHJvbWlzZS50aGVuKG1vZCA9PiB7XG5cdFx0XHRfQ29kZU1pcnJvciA9IG1vZC5kZWZhdWx0O1xuXHRcdH0pO1xuXHR9XG48L3NjcmlwdD5cblxuPHNjcmlwdD5cblx0aW1wb3J0IHsgb25Nb3VudCwgYmVmb3JlVXBkYXRlLCBjcmVhdGVFdmVudERpc3BhdGNoZXIsIGdldENvbnRleHQgfSBmcm9tICdzdmVsdGUnO1xuXHRpbXBvcnQgTWVzc2FnZSBmcm9tICcuL01lc3NhZ2Uuc3ZlbHRlJztcblxuXHRjb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpO1xuXHRjb25zdCB7IG5hdmlnYXRlIH0gPSBnZXRDb250ZXh0KCdSRVBMJyk7XG5cblx0ZXhwb3J0IGxldCByZWFkb25seSA9IGZhbHNlO1xuXHRleHBvcnQgbGV0IGVycm9yTG9jID0gbnVsbDtcblx0ZXhwb3J0IGxldCBmbGV4ID0gZmFsc2U7XG5cdGV4cG9ydCBsZXQgbGluZU51bWJlcnMgPSB0cnVlO1xuXHRleHBvcnQgbGV0IHRhYiA9IHRydWU7XG5cblx0bGV0IHc7XG5cdGxldCBoO1xuXHRsZXQgY29kZSA9ICcnO1xuXHRsZXQgbW9kZTtcblxuXHQvLyBXZSBoYXZlIHRvIGV4cG9zZSBzZXQgYW5kIHVwZGF0ZSBtZXRob2RzLCByYXRoZXJcblx0Ly8gdGhhbiBtYWtpbmcgdGhpcyBzdGF0ZS1kcml2ZW4gdGhyb3VnaCBwcm9wcyxcblx0Ly8gYmVjYXVzZSBpdCdzIGRpZmZpY3VsdCB0byB1cGRhdGUgYW4gZWRpdG9yXG5cdC8vIHdpdGhvdXQgcmVzZXR0aW5nIHNjcm9sbCBvdGhlcndpc2Vcblx0ZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNldChuZXdfY29kZSwgbmV3X21vZGUpIHtcblx0XHRpZiAobmV3X21vZGUgIT09IG1vZGUpIHtcblx0XHRcdGF3YWl0IGNyZWF0ZUVkaXRvcihtb2RlID0gbmV3X21vZGUpO1xuXHRcdH1cblxuXHRcdGNvZGUgPSBuZXdfY29kZTtcblx0XHR1cGRhdGluZ19leHRlcm5hbGx5ID0gdHJ1ZTtcblx0XHRpZiAoZWRpdG9yKSBlZGl0b3Iuc2V0VmFsdWUoY29kZSk7XG5cdFx0dXBkYXRpbmdfZXh0ZXJuYWxseSA9IGZhbHNlO1xuXHR9XG5cblx0ZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZShuZXdfY29kZSkge1xuXHRcdGNvZGUgPSBuZXdfY29kZTtcblxuXHRcdGlmIChlZGl0b3IpIHtcblx0XHRcdGNvbnN0IHsgbGVmdCwgdG9wIH0gPSBlZGl0b3IuZ2V0U2Nyb2xsSW5mbygpO1xuXHRcdFx0ZWRpdG9yLnNldFZhbHVlKGNvZGUgPSBuZXdfY29kZSk7XG5cdFx0XHRlZGl0b3Iuc2Nyb2xsVG8obGVmdCwgdG9wKTtcblx0XHR9XG5cdH1cblxuXHRleHBvcnQgZnVuY3Rpb24gcmVzaXplKCkge1xuXHRcdGVkaXRvci5yZWZyZXNoKCk7XG5cdH1cblxuXHRleHBvcnQgZnVuY3Rpb24gZm9jdXMoKSB7XG5cdFx0ZWRpdG9yLmZvY3VzKCk7XG5cdH1cblxuXHRjb25zdCBtb2RlcyA9IHtcblx0XHRqczoge1xuXHRcdFx0bmFtZTogJ2phdmFzY3JpcHQnLFxuXHRcdFx0anNvbjogZmFsc2Vcblx0XHR9LFxuXHRcdGpzb246IHtcblx0XHRcdG5hbWU6ICdqYXZhc2NyaXB0Jyxcblx0XHRcdGpzb246IHRydWVcblx0XHR9LFxuXHRcdHN2ZWx0ZToge1xuXHRcdFx0bmFtZTogJ2hhbmRsZWJhcnMnLFxuXHRcdFx0YmFzZTogJ3RleHQvaHRtbCdcblx0XHR9XG5cdH07XG5cblx0Y29uc3QgcmVmcyA9IHt9O1xuXHRsZXQgZWRpdG9yO1xuXHRsZXQgdXBkYXRpbmdfZXh0ZXJuYWxseSA9IGZhbHNlO1xuXHRsZXQgbWFya2VyO1xuXHRsZXQgZXJyb3JfbGluZTtcblx0bGV0IGRlc3Ryb3llZCA9IGZhbHNlO1xuXHRsZXQgQ29kZU1pcnJvcjtcblxuXHQkOiBpZiAoZWRpdG9yICYmIHcgJiYgaCkge1xuXHRcdGVkaXRvci5yZWZyZXNoKCk7XG5cdH1cblxuXHQkOiB7XG5cdFx0aWYgKG1hcmtlcikgbWFya2VyLmNsZWFyKCk7XG5cblx0XHRpZiAoZXJyb3JMb2MpIHtcblx0XHRcdGNvbnN0IGxpbmUgPSBlcnJvckxvYy5saW5lIC0gMTtcblx0XHRcdGNvbnN0IGNoID0gZXJyb3JMb2MuY29sdW1uO1xuXG5cdFx0XHRtYXJrZXIgPSBlZGl0b3IubWFya1RleHQoeyBsaW5lLCBjaCB9LCB7IGxpbmUsIGNoOiBjaCArIDEgfSwge1xuXHRcdFx0XHRjbGFzc05hbWU6ICdlcnJvci1sb2MnXG5cdFx0XHR9KTtcblxuXHRcdFx0ZXJyb3JfbGluZSA9IGxpbmU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVycm9yX2xpbmUgPSBudWxsO1xuXHRcdH1cblx0fVxuXG5cdGxldCBwcmV2aW91c19lcnJvcl9saW5lO1xuXHQkOiBpZiAoZWRpdG9yKSB7XG5cdFx0aWYgKHByZXZpb3VzX2Vycm9yX2xpbmUgIT0gbnVsbCkge1xuXHRcdFx0ZWRpdG9yLnJlbW92ZUxpbmVDbGFzcyhwcmV2aW91c19lcnJvcl9saW5lLCAnd3JhcCcsICdlcnJvci1saW5lJylcblx0XHR9XG5cblx0XHRpZiAoZXJyb3JfbGluZSAmJiAoZXJyb3JfbGluZSAhPT0gcHJldmlvdXNfZXJyb3JfbGluZSkpIHtcblx0XHRcdGVkaXRvci5hZGRMaW5lQ2xhc3MoZXJyb3JfbGluZSwgJ3dyYXAnLCAnZXJyb3ItbGluZScpO1xuXHRcdFx0cHJldmlvdXNfZXJyb3JfbGluZSA9IGVycm9yX2xpbmU7XG5cdFx0fVxuXHR9XG5cblx0b25Nb3VudCgoKSA9PiB7XG5cdFx0aWYgKF9Db2RlTWlycm9yKSB7XG5cdFx0XHRDb2RlTWlycm9yID0gX0NvZGVNaXJyb3I7XG5cdFx0XHRjcmVhdGVFZGl0b3IobW9kZSB8fCAnc3ZlbHRlJykudGhlbigoKSA9PiB7XG5cdFx0XHRcdGlmIChlZGl0b3IpIGVkaXRvci5zZXRWYWx1ZShjb2RlIHx8ICcnKTtcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb2RlbWlycm9yX3Byb21pc2UudGhlbihhc3luYyBtb2QgPT4ge1xuXHRcdFx0XHRDb2RlTWlycm9yID0gbW9kLmRlZmF1bHQ7XG5cdFx0XHRcdGF3YWl0IGNyZWF0ZUVkaXRvcihtb2RlIHx8ICdzdmVsdGUnKTtcblx0XHRcdFx0aWYgKGVkaXRvcikgZWRpdG9yLnNldFZhbHVlKGNvZGUgfHwgJycpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICgpID0+IHtcblx0XHRcdGRlc3Ryb3llZCA9IHRydWU7XG5cdFx0XHRpZiAoZWRpdG9yKSBlZGl0b3IudG9UZXh0QXJlYSgpO1xuXHRcdH1cblx0fSk7XG5cblx0bGV0IGZpcnN0ID0gdHJ1ZTtcblxuXHRhc3luYyBmdW5jdGlvbiBjcmVhdGVFZGl0b3IobW9kZSkge1xuXHRcdGlmIChkZXN0cm95ZWQgfHwgIUNvZGVNaXJyb3IpIHJldHVybjtcblxuXHRcdGlmIChlZGl0b3IpIGVkaXRvci50b1RleHRBcmVhKCk7XG5cblx0XHRjb25zdCBvcHRzID0ge1xuXHRcdFx0bGluZU51bWJlcnMsXG5cdFx0XHRsaW5lV3JhcHBpbmc6IHRydWUsXG5cdFx0XHRpbmRlbnRXaXRoVGFiczogdHJ1ZSxcblx0XHRcdGluZGVudFVuaXQ6IDIsXG5cdFx0XHR0YWJTaXplOiAyLFxuXHRcdFx0dmFsdWU6ICcnLFxuXHRcdFx0bW9kZTogbW9kZXNbbW9kZV0gfHwge1xuXHRcdFx0XHRuYW1lOiBtb2RlXG5cdFx0XHR9LFxuXHRcdFx0cmVhZE9ubHk6IHJlYWRvbmx5LFxuXHRcdFx0YXV0b0Nsb3NlQnJhY2tldHM6IHRydWUsXG5cdFx0XHRhdXRvQ2xvc2VUYWdzOiB0cnVlXG5cdFx0fTtcblxuXHRcdGlmICghdGFiKSBvcHRzLmV4dHJhS2V5cyA9IHtcblx0XHRcdFRhYjogdGFiLFxuXHRcdFx0J1NoaWZ0LVRhYic6IHRhYlxuXHRcdH07XG5cblx0XHQvLyBDcmVhdGluZyBhIHRleHQgZWRpdG9yIGlzIGEgbG90IG9mIHdvcmssIHNvIHdlIHlpZWxkXG5cdFx0Ly8gdGhlIG1haW4gdGhyZWFkIGZvciBhIG1vbWVudC4gVGhpcyBoZWxwcyByZWR1Y2UgamFua1xuXHRcdGlmIChmaXJzdCkgYXdhaXQgc2xlZXAoNTApO1xuXG5cdFx0aWYgKGRlc3Ryb3llZCkgcmV0dXJuO1xuXG5cdFx0ZWRpdG9yID0gQ29kZU1pcnJvci5mcm9tVGV4dEFyZWEocmVmcy5lZGl0b3IsIG9wdHMpO1xuXG5cdFx0ZWRpdG9yLm9uKCdjaGFuZ2UnLCBpbnN0YW5jZSA9PiB7XG5cdFx0XHRpZiAoIXVwZGF0aW5nX2V4dGVybmFsbHkpIHtcblx0XHRcdFx0Y29uc3QgdmFsdWUgPSBpbnN0YW5jZS5nZXRWYWx1ZSgpO1xuXHRcdFx0XHRkaXNwYXRjaCgnY2hhbmdlJywgeyB2YWx1ZSB9KTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGlmIChmaXJzdCkgYXdhaXQgc2xlZXAoNTApO1xuXHRcdGVkaXRvci5yZWZyZXNoKCk7XG5cblx0XHRmaXJzdCA9IGZhbHNlO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2xlZXAobXMpIHtcblx0XHRyZXR1cm4gbmV3IFByb21pc2UoZnVsZmlsID0+IHNldFRpbWVvdXQoZnVsZmlsLCBtcykpO1xuXHR9XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuXHQuY29kZW1pcnJvci1jb250YWluZXIge1xuXHRcdHBvc2l0aW9uOiByZWxhdGl2ZTtcblx0XHR3aWR0aDogMTAwJTtcblx0XHRoZWlnaHQ6IDEwMCU7XG5cdFx0Ym9yZGVyOiBub25lO1xuXHRcdGxpbmUtaGVpZ2h0OiAxLjU7XG5cdFx0b3ZlcmZsb3c6IGhpZGRlbjtcblx0fVxuXG5cdC5jb2RlbWlycm9yLWNvbnRhaW5lciA6Z2xvYmFsKC5Db2RlTWlycm9yKSB7XG5cdFx0aGVpZ2h0OiAxMDAlO1xuXHRcdGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xuXHRcdGZvbnQ6IDQwMCAxNHB4LzEuNyB2YXIoLS1mb250LW1vbm8pO1xuXHRcdGNvbG9yOiB2YXIoLS1iYXNlKTtcblx0fVxuXG5cdC5jb2RlbWlycm9yLWNvbnRhaW5lci5mbGV4IDpnbG9iYWwoLkNvZGVNaXJyb3IpIHtcblx0XHRoZWlnaHQ6IGF1dG87XG5cdH1cblxuXHQuY29kZW1pcnJvci1jb250YWluZXIuZmxleCA6Z2xvYmFsKC5Db2RlTWlycm9yLWxpbmVzKSB7XG5cdFx0cGFkZGluZzogMDtcblx0fVxuXG5cdC5jb2RlbWlycm9yLWNvbnRhaW5lciA6Z2xvYmFsKC5Db2RlTWlycm9yLWd1dHRlcnMpIHtcblx0XHRwYWRkaW5nOiAwIDE2cHggMCA4cHg7XG5cdFx0Ym9yZGVyOiBub25lO1xuXHR9XG5cblx0LmNvZGVtaXJyb3ItY29udGFpbmVyIDpnbG9iYWwoLmVycm9yLWxvYykge1xuXHRcdHBvc2l0aW9uOiByZWxhdGl2ZTtcblx0XHRib3JkZXItYm90dG9tOiAycHggc29saWQgI2RhMTA2ZTtcblx0fVxuXG5cdC5jb2RlbWlycm9yLWNvbnRhaW5lciA6Z2xvYmFsKC5lcnJvci1saW5lKSB7XG5cdFx0YmFja2dyb3VuZC1jb2xvcjogcmdiYSgyMDAsIDAsIDAsIC4wNSk7XG5cdH1cblxuXHR0ZXh0YXJlYSB7XG5cdFx0dmlzaWJpbGl0eTogaGlkZGVuO1xuXHR9XG5cblx0cHJlIHtcblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0d2lkdGg6IDEwMCU7XG5cdFx0aGVpZ2h0OiAxMDAlO1xuXHRcdHRvcDogMDtcblx0XHRsZWZ0OiAwO1xuXHRcdGJvcmRlcjogbm9uZTtcblx0XHRwYWRkaW5nOiA0cHggNHB4IDRweCA2MHB4O1xuXHRcdHJlc2l6ZTogbm9uZTtcblx0XHRmb250LWZhbWlseTogdmFyKC0tZm9udC1tb25vKTtcblx0XHRmb250LXNpemU6IDEzcHg7XG5cdFx0bGluZS1oZWlnaHQ6IDEuNztcblx0XHR1c2VyLXNlbGVjdDogbm9uZTtcblx0XHRwb2ludGVyLWV2ZW50czogbm9uZTtcblx0XHRjb2xvcjogI2NjYztcblx0XHR0YWItc2l6ZTogMjtcblx0XHQtbW96LXRhYi1zaXplOiAyO1xuXHR9XG5cblx0LmZsZXggcHJlIHtcblx0XHRwYWRkaW5nOiAwIDAgMCA0cHg7XG5cdFx0aGVpZ2h0OiBhdXRvO1xuXHR9XG48L3N0eWxlPlxuXG48ZGl2IGNsYXNzPSdjb2RlbWlycm9yLWNvbnRhaW5lcicgY2xhc3M6ZmxleCBiaW5kOm9mZnNldFdpZHRoPXt3fSBiaW5kOm9mZnNldEhlaWdodD17aH0+XG5cdDwhLS0gc3ZlbHRlLWlnbm9yZSBhMTF5LXBvc2l0aXZlLXRhYmluZGV4IC0tPlxuXHQ8dGV4dGFyZWFcblx0XHR0YWJpbmRleD0nMidcblx0XHRiaW5kOnRoaXM9e3JlZnMuZWRpdG9yfVxuXHRcdHJlYWRvbmx5XG5cdFx0dmFsdWU9e2NvZGV9XG5cdD48L3RleHRhcmVhPlxuXG5cdHsjaWYgIUNvZGVNaXJyb3J9XG5cdFx0PHByZSBzdHlsZT1cInBvc2l0aW9uOiBhYnNvbHV0ZTsgbGVmdDogMDsgdG9wOiAwXCJcblx0XHQ+e2NvZGV9PC9wcmU+XG5cblx0XHQ8ZGl2IHN0eWxlPVwicG9zaXRpb246IGFic29sdXRlOyB3aWR0aDogMTAwJTsgYm90dG9tOiAwXCI+XG5cdFx0XHQ8TWVzc2FnZSBraW5kPSdpbmZvJz5sb2FkaW5nIGVkaXRvci4uLjwvTWVzc2FnZT5cblx0XHQ8L2Rpdj5cblx0ey9pZn1cbjwvZGl2PiIsIjxzY3JpcHQ+XG5cdGltcG9ydCB7IGdldENvbnRleHQsIGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJ3N2ZWx0ZSc7XG5cblx0ZXhwb3J0IGxldCBoYW5kbGVfc2VsZWN0O1xuXG5cdGNvbnN0IHsgY29tcG9uZW50cywgc2VsZWN0ZWQsIHJlcXVlc3RfZm9jdXMsIHJlYnVuZGxlIH0gPSBnZXRDb250ZXh0KCdSRVBMJyk7XG5cblx0bGV0IGVkaXRpbmcgPSBudWxsO1xuXG5cdGZ1bmN0aW9uIHNlbGVjdENvbXBvbmVudChjb21wb25lbnQpIHtcblx0XHRpZiAoJHNlbGVjdGVkICE9PSBjb21wb25lbnQpIHtcblx0XHRcdGVkaXRpbmcgPSBudWxsO1xuXHRcdFx0aGFuZGxlX3NlbGVjdChjb21wb25lbnQpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGVkaXRUYWIoY29tcG9uZW50KSB7XG5cdFx0aWYgKCRzZWxlY3RlZCA9PT0gY29tcG9uZW50KSB7XG5cdFx0XHRlZGl0aW5nID0gJHNlbGVjdGVkO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGNsb3NlRWRpdCgpIHtcblx0XHRjb25zdCBtYXRjaCA9IC8oLispXFwuKHN2ZWx0ZXxqcykkLy5leGVjKCRzZWxlY3RlZC5uYW1lKTtcblx0XHQkc2VsZWN0ZWQubmFtZSA9IG1hdGNoID8gbWF0Y2hbMV0gOiAkc2VsZWN0ZWQubmFtZTtcblx0XHRpZiAobWF0Y2ggJiYgbWF0Y2hbMl0pICRzZWxlY3RlZC50eXBlID0gbWF0Y2hbMl07XG5cdFx0ZWRpdGluZyA9IG51bGw7XG5cblx0XHQvLyByZS1zZWxlY3QsIGluIGNhc2UgdGhlIHR5cGUgY2hhbmdlZFxuXHRcdGhhbmRsZV9zZWxlY3QoJHNlbGVjdGVkKTtcblxuXHRcdGNvbXBvbmVudHMgPSBjb21wb25lbnRzOyAvLyBUT0RPIG5lY2Vzc2FyeT9cblxuXHRcdC8vIGZvY3VzIHRoZSBlZGl0b3IsIGJ1dCB3YWl0IGEgYmVhdCAoc28ga2V5IGV2ZW50cyBhcmVuJ3QgbWlzZGlyZWN0ZWQpXG5cdFx0c2V0VGltZW91dChyZXF1ZXN0X2ZvY3VzKTtcblxuXHRcdHJlYnVuZGxlKCk7XG5cdH1cblxuXHRmdW5jdGlvbiByZW1vdmUoY29tcG9uZW50KSB7XG5cdFx0bGV0IHJlc3VsdCA9IGNvbmZpcm0oYEFyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBkZWxldGUgJHtjb21wb25lbnQubmFtZX0uJHtjb21wb25lbnQudHlwZX0/YCk7XG5cblx0XHRpZiAocmVzdWx0KSB7XG5cdFx0XHRjb25zdCBpbmRleCA9ICRjb21wb25lbnRzLmluZGV4T2YoY29tcG9uZW50KTtcblxuXHRcdFx0aWYgKH5pbmRleCkge1xuXHRcdFx0XHRjb21wb25lbnRzLnNldCgkY29tcG9uZW50cy5zbGljZSgwLCBpbmRleCkuY29uY2F0KCRjb21wb25lbnRzLnNsaWNlKGluZGV4ICsgMSkpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoYENvdWxkIG5vdCBmaW5kIGNvbXBvbmVudCEgVGhhdCdzLi4uIG9kZGApO1xuXHRcdFx0fVxuXG5cdFx0XHRoYW5kbGVfc2VsZWN0KCRjb21wb25lbnRzW2luZGV4XSB8fCAkY29tcG9uZW50c1skY29tcG9uZW50cy5sZW5ndGggLSAxXSk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gc2VsZWN0SW5wdXQoZXZlbnQpIHtcblx0XHRzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdGV2ZW50LnRhcmdldC5zZWxlY3QoKTtcblx0XHR9KTtcblx0fVxuXG5cdGxldCB1aWQgPSAxO1xuXG5cdGZ1bmN0aW9uIGFkZE5ldygpIHtcblx0XHRjb25zdCBjb21wb25lbnQgPSB7XG5cdFx0XHRuYW1lOiB1aWQrKyA/IGBDb21wb25lbnQke3VpZH1gIDogJ0NvbXBvbmVudDEnLFxuXHRcdFx0dHlwZTogJ3N2ZWx0ZScsXG5cdFx0XHRzb3VyY2U6ICcnXG5cdFx0fTtcblxuXHRcdGVkaXRpbmcgPSBjb21wb25lbnQ7XG5cblx0XHRzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdC8vIFRPRE8gd2UgY2FuIGRvIHRoaXMgd2l0aG91dCBJRHNcblx0XHRcdGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNvbXBvbmVudC5uYW1lKS5zY3JvbGxJbnRvVmlldyhmYWxzZSk7XG5cdFx0fSk7XG5cblx0XHRjb21wb25lbnRzLnVwZGF0ZShjb21wb25lbnRzID0+IGNvbXBvbmVudHMuY29uY2F0KGNvbXBvbmVudCkpO1xuXHRcdGhhbmRsZV9zZWxlY3QoY29tcG9uZW50KTtcblx0fVxuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cblx0LmNvbXBvbmVudC1zZWxlY3RvciB7XG5cdFx0cG9zaXRpb246IHJlbGF0aXZlO1xuXHRcdGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZWVlO1xuXHRcdG92ZXJmbG93OiBoaWRkZW47XG5cdH1cblxuXHQuZmlsZS10YWJzIHtcblx0XHRib3JkZXI6IG5vbmU7XG5cdFx0bWFyZ2luOiAwO1xuXHRcdHdoaXRlLXNwYWNlOiBub3dyYXA7XG5cdFx0b3ZlcmZsb3cteDogYXV0bztcblx0XHRvdmVyZmxvdy15OiBoaWRkZW47XG5cdFx0aGVpZ2h0OiAxMGVtO1xuXHR9XG5cblx0LmZpbGUtdGFicyAuYnV0dG9uLCAuZmlsZS10YWJzIGJ1dHRvbiB7XG5cdFx0cG9zaXRpb246IHJlbGF0aXZlO1xuXHRcdGRpc3BsYXk6IGlubGluZS1ibG9jaztcblx0XHRmb250OiA0MDAgMTJweC8xLjUgdmFyKC0tZm9udCk7XG5cdFx0YmFja2dyb3VuZDogd2hpdGU7XG5cdFx0Ym9yZGVyOiBub25lO1xuXHRcdGJvcmRlci1ib3R0b206IDNweCBzb2xpZCB0cmFuc3BhcmVudDtcblx0XHRwYWRkaW5nOiAxMnB4IDE0cHggOHB4IDhweDtcblx0XHRtYXJnaW46IDA7XG5cdFx0Y29sb3I6ICM5OTk7XG5cdFx0Ym9yZGVyLXJhZGl1czogMDtcblx0fVxuXG5cdC5maWxlLXRhYnMgLmJ1dHRvbjpmaXJzdC1jaGlsZCB7XG5cdFx0cGFkZGluZy1sZWZ0OiAxMnB4O1xuXHR9XG5cblx0LmZpbGUtdGFicyAuYnV0dG9uLmFjdGl2ZSB7XG5cdFx0LyogY29sb3I6IHZhcigtLXNlY29uZCk7ICovXG5cdFx0Y29sb3I6ICMzMzM7XG5cdFx0Ym9yZGVyLWJvdHRvbTogM3B4IHNvbGlkIHZhcigtLXByaW1lKTtcblx0fVxuXG5cdC5lZGl0YWJsZSwgLnVuZWRpdGFibGUsIC5pbnB1dC1zaXplciwgaW5wdXQge1xuXHRcdGRpc3BsYXk6IGlubGluZS1ibG9jaztcblx0XHRwb3NpdGlvbjogcmVsYXRpdmU7XG5cdFx0bGluZS1oZWlnaHQ6IDE7XG5cdH1cblxuXHQuaW5wdXQtc2l6ZXIge1xuXHRcdGNvbG9yOiAjY2NjO1xuXHR9XG5cblx0aW5wdXQge1xuXHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHR3aWR0aDogMTAwJTtcblx0XHRsZWZ0OiA4cHg7XG5cdFx0dG9wOiAxMnB4O1xuXHRcdGZvbnQ6IDQwMCAxMnB4LzEuNSB2YXIoLS1mb250KTtcblx0XHRib3JkZXI6IG5vbmU7XG5cdFx0Y29sb3I6IHZhcigtLWZsYXNoKTtcblx0XHRvdXRsaW5lOiBub25lO1xuXHRcdGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuXHR9XG5cblx0LnJlbW92ZSB7XG5cdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdGRpc3BsYXk6IG5vbmU7XG5cdFx0cmlnaHQ6IDFweDtcblx0XHR0b3A6IDRweDtcblx0XHR3aWR0aDogMTZweDtcblx0XHR0ZXh0LWFsaWduOiByaWdodDtcblx0XHRwYWRkaW5nOiAxMnB4IDAgMTJweCA1cHg7XG5cdFx0Zm9udC1zaXplOiA4cHg7XG5cdFx0Y3Vyc29yOiBwb2ludGVyO1xuXHR9XG5cblx0LnJlbW92ZTpob3ZlciB7XG5cdFx0Y29sb3I6IHZhcigtLWZsYXNoKTtcblx0fVxuXG5cdC5maWxlLXRhYnMgLmJ1dHRvbi5hY3RpdmUgLmVkaXRhYmxlIHtcblx0XHRjdXJzb3I6IHRleHQ7XG5cdH1cblxuXHQuZmlsZS10YWJzIC5idXR0b24uYWN0aXZlIC5yZW1vdmUge1xuXHRcdGRpc3BsYXk6IGJsb2NrO1xuXHR9XG5cblx0LmFkZC1uZXcge1xuXHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHRsZWZ0OiAwO1xuXHRcdHRvcDogMDtcblx0XHRwYWRkaW5nOiAxMnB4IDEwcHggOHB4IDAgIWltcG9ydGFudDtcblx0XHRoZWlnaHQ6IDQwcHg7XG5cdFx0dGV4dC1hbGlnbjogY2VudGVyO1xuXHRcdGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xuXHR9XG5cblx0LmFkZC1uZXc6aG92ZXIge1xuXHRcdGNvbG9yOiB2YXIoLS1mbGFzaCkgIWltcG9ydGFudDtcblx0fVxuXG5cdHN2ZyB7XG5cdFx0cG9zaXRpb246IHJlbGF0aXZlO1xuXHRcdG92ZXJmbG93OiBoaWRkZW47XG5cdFx0dmVydGljYWwtYWxpZ246IG1pZGRsZTtcblx0XHQtby1vYmplY3QtZml0OiBjb250YWluO1xuXHRcdG9iamVjdC1maXQ6IGNvbnRhaW47XG5cdFx0LXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOiBjZW50ZXIgY2VudGVyO1xuXHRcdHRyYW5zZm9ybS1vcmlnaW46IGNlbnRlciBjZW50ZXI7XG5cblx0XHRzdHJva2U6IGN1cnJlbnRDb2xvcjtcblx0XHRzdHJva2Utd2lkdGg6IDI7XG5cdFx0c3Ryb2tlLWxpbmVjYXA6IHJvdW5kO1xuXHRcdHN0cm9rZS1saW5lam9pbjogcm91bmQ7XG5cdFx0ZmlsbDogbm9uZTtcblx0fVxuPC9zdHlsZT5cblxuPGRpdiBjbGFzcz1cImNvbXBvbmVudC1zZWxlY3RvclwiPlxuXHR7I2lmICRjb21wb25lbnRzLmxlbmd0aH1cblx0XHQ8ZGl2IGNsYXNzPVwiZmlsZS10YWJzXCIgb246ZGJsY2xpY2s9XCJ7YWRkTmV3fVwiPlxuXHRcdFx0eyNlYWNoICRjb21wb25lbnRzIGFzIGNvbXBvbmVudH1cblx0XHRcdFx0PGRpdlxuXHRcdFx0XHRcdGlkPXtjb21wb25lbnQubmFtZX1cblx0XHRcdFx0XHRjbGFzcz1cImJ1dHRvblwiXG5cdFx0XHRcdFx0cm9sZT1cImJ1dHRvblwiXG5cdFx0XHRcdFx0Y2xhc3M6YWN0aXZlPVwie2NvbXBvbmVudCA9PT0gJHNlbGVjdGVkfVwiXG5cdFx0XHRcdFx0b246Y2xpY2s9XCJ7KCkgPT4gc2VsZWN0Q29tcG9uZW50KGNvbXBvbmVudCl9XCJcblx0XHRcdFx0XHRvbjpkYmxjbGljaz1cIntlID0+IGUuc3RvcFByb3BhZ2F0aW9uKCl9XCJcblx0XHRcdFx0PlxuXHRcdFx0XHRcdHsjaWYgY29tcG9uZW50Lm5hbWUgPT0gJ0FwcCd9XG5cdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwidW5lZGl0YWJsZVwiPlxuXHRcdFx0XHRcdFx0XHRBcHAuc3ZlbHRlXG5cdFx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHR7OmVsc2V9XG5cdFx0XHRcdFx0XHR7I2lmIGNvbXBvbmVudCA9PT0gZWRpdGluZ31cblx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJpbnB1dC1zaXplclwiPntlZGl0aW5nLm5hbWUgKyAoL1xcLi8udGVzdChlZGl0aW5nLm5hbWUpID8gJycgOiBgLiR7ZWRpdGluZy50eXBlfWApfTwvc3Bhbj5cblxuXHRcdFx0XHRcdFx0XHQ8IS0tIHN2ZWx0ZS1pZ25vcmUgYTExeS1hdXRvZm9jdXMgLS0+XG5cdFx0XHRcdFx0XHRcdDxpbnB1dFxuXHRcdFx0XHRcdFx0XHRcdGF1dG9mb2N1c1xuXHRcdFx0XHRcdFx0XHRcdHNwZWxsY2hlY2s9e2ZhbHNlfVxuXHRcdFx0XHRcdFx0XHRcdGJpbmQ6dmFsdWU9e2VkaXRpbmcubmFtZX1cblx0XHRcdFx0XHRcdFx0XHRvbjpmb2N1cz17c2VsZWN0SW5wdXR9XG5cdFx0XHRcdFx0XHRcdFx0b246Ymx1cj17Y2xvc2VFZGl0fVxuXHRcdFx0XHRcdFx0XHRcdG9uOmtleWRvd249e2UgPT4gZS53aGljaCA9PT0gMTMgJiYgZS50YXJnZXQuYmx1cigpfVxuXHRcdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHR7OmVsc2V9XG5cdFx0XHRcdFx0XHRcdDxkaXZcblx0XHRcdFx0XHRcdFx0XHRjbGFzcz1cImVkaXRhYmxlXCJcblx0XHRcdFx0XHRcdFx0XHR0aXRsZT1cImVkaXQgY29tcG9uZW50IG5hbWVcIlxuXHRcdFx0XHRcdFx0XHRcdG9uOmNsaWNrPVwieygpID0+IGVkaXRUYWIoY29tcG9uZW50KX1cIlxuXHRcdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdFx0e2NvbXBvbmVudC5uYW1lfS57Y29tcG9uZW50LnR5cGV9XG5cdFx0XHRcdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwicmVtb3ZlXCIgb246Y2xpY2s9XCJ7KCkgPT4gcmVtb3ZlKGNvbXBvbmVudCl9XCI+XG5cdFx0XHRcdFx0XHRcdFx0PHN2ZyB3aWR0aD1cIjEyXCIgaGVpZ2h0PVwiMTJcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8bGluZSBzdHJva2U9XCIjOTk5XCIgeDE9JzE4JyB5MT0nNicgeDI9JzYnIHkyPScxOCcgLz5cblx0XHRcdFx0XHRcdFx0XHRcdDxsaW5lIHN0cm9rZT1cIiM5OTlcIiB4MT0nNicgeTE9JzYnIHgyPScxOCcgeTI9JzE4JyAvPlxuXHRcdFx0XHRcdFx0XHRcdDwvc3ZnPlxuXHRcdFx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdFx0XHR7L2lmfVxuXHRcdFx0XHRcdHsvaWZ9XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0ey9lYWNofVxuXG5cdFx0XHQ8YnV0dG9uIGNsYXNzPVwiYWRkLW5ld1wiIG9uOmNsaWNrPXthZGROZXd9IHRpdGxlPVwiYWRkIG5ldyBjb21wb25lbnRcIj5cblx0XHRcdFx0PHN2ZyB3aWR0aD1cIjEyXCIgaGVpZ2h0PVwiMTJcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+XG5cdFx0XHRcdFx0PGxpbmUgc3Ryb2tlPVwiIzk5OVwiIHgxPScxMicgeTE9JzUnIHgyPScxMicgeTI9JzE5JyAvPlxuXHRcdFx0XHRcdDxsaW5lIHN0cm9rZT1cIiM5OTlcIiB4MT0nNScgeTE9JzEyJyB4Mj0nMTknIHkyPScxMicgLz5cblx0XHRcdFx0PC9zdmc+XG5cdFx0XHQ8L2J1dHRvbj5cblx0XHQ8L2Rpdj5cblx0ey9pZn1cbjwvZGl2PlxuIiwiPHNjcmlwdD5cblx0aW1wb3J0IHsgZ2V0Q29udGV4dCwgb25Nb3VudCB9IGZyb20gJ3N2ZWx0ZSc7XG5cdGltcG9ydCBDb2RlTWlycm9yIGZyb20gJy4uL0NvZGVNaXJyb3Iuc3ZlbHRlJztcblx0aW1wb3J0IE1lc3NhZ2UgZnJvbSAnLi4vTWVzc2FnZS5zdmVsdGUnO1xuXG5cdGNvbnN0IHsgYnVuZGxlLCBzZWxlY3RlZCwgaGFuZGxlX2NoYW5nZSwgbmF2aWdhdGUsIHJlZ2lzdGVyX21vZHVsZV9lZGl0b3IgfSA9IGdldENvbnRleHQoJ1JFUEwnKTtcblxuXHRleHBvcnQgbGV0IGVycm9yTG9jO1xuXG5cdGxldCBlZGl0b3I7XG5cdG9uTW91bnQoKCkgPT4ge1xuXHRcdHJlZ2lzdGVyX21vZHVsZV9lZGl0b3IoZWRpdG9yKTtcblx0fSk7XG5cblx0ZXhwb3J0IGZ1bmN0aW9uIGZvY3VzKCkge1xuXHRcdGVkaXRvci5mb2N1cygpO1xuXHR9XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuXHQuZWRpdG9yLXdyYXBwZXIge1xuXHRcdHotaW5kZXg6IDU7XG5cdFx0YmFja2dyb3VuZDogdmFyKC0tYmFjay1saWdodCk7XG5cdFx0ZGlzcGxheTogZmxleDtcblx0XHRmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuXHR9XG5cblx0LmVkaXRvciB7XG5cdFx0aGVpZ2h0OiAwO1xuXHRcdGZsZXg6IDEgMSBhdXRvO1xuXHR9XG5cblx0Omdsb2JhbCguY29sdW1ucykgLmVkaXRvci13cmFwcGVyIHtcblx0XHQvKiBtYWtlIGl0IGVhc2llciB0byBpbnRlcmFjdCB3aXRoIHNjcm9sbGJhciAqL1xuXHRcdHBhZGRpbmctcmlnaHQ6IDhweDtcblx0XHRoZWlnaHQ6IGF1dG87XG5cdFx0LyogaGVpZ2h0OiAxMDAlOyAqL1xuXHR9XG48L3N0eWxlPlxuXG48ZGl2IGNsYXNzPVwiZWRpdG9yLXdyYXBwZXJcIj5cblx0PGRpdiBjbGFzcz1cImVkaXRvclwiPlxuXHRcdDxDb2RlTWlycm9yXG5cdFx0XHRiaW5kOnRoaXM9e2VkaXRvcn1cblx0XHRcdHtlcnJvckxvY31cblx0XHRcdG9uOmNoYW5nZT17aGFuZGxlX2NoYW5nZX1cblx0XHQvPlxuXHQ8L2Rpdj5cblxuXHQ8ZGl2IGNsYXNzPVwiaW5mb1wiPlxuXHRcdHsjaWYgJGJ1bmRsZX1cblx0XHRcdHsjaWYgJGJ1bmRsZS5lcnJvcn1cblx0XHRcdFx0PE1lc3NhZ2Uga2luZD1cImVycm9yXCIgZGV0YWlscz17JGJ1bmRsZS5lcnJvcn0gZmlsZW5hbWU9XCJ7JHNlbGVjdGVkLm5hbWV9Lnskc2VsZWN0ZWQudHlwZX1cIi8+XG5cdFx0XHR7OmVsc2UgaWYgJGJ1bmRsZS53YXJuaW5ncy5sZW5ndGggPiAwfVxuXHRcdFx0XHR7I2VhY2ggJGJ1bmRsZS53YXJuaW5ncyBhcyB3YXJuaW5nfVxuXHRcdFx0XHRcdDxNZXNzYWdlIGtpbmQ9XCJ3YXJuaW5nXCIgZGV0YWlscz17d2FybmluZ30gZmlsZW5hbWU9XCJ7JHNlbGVjdGVkLm5hbWV9Lnskc2VsZWN0ZWQudHlwZX1cIi8+XG5cdFx0XHRcdHsvZWFjaH1cblx0XHRcdHsvaWZ9XG5cdFx0ey9pZn1cblx0PC9kaXY+XG48L2Rpdj4iLCJ2YXIgY2hhclRvSW50ZWdlciA9IHt9O1xudmFyIGNoYXJzID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89JztcbmZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICBjaGFyVG9JbnRlZ2VyW2NoYXJzLmNoYXJDb2RlQXQoaSldID0gaTtcbn1cbmZ1bmN0aW9uIGRlY29kZShtYXBwaW5ncykge1xuICAgIHZhciBnZW5lcmF0ZWRDb2RlQ29sdW1uID0gMDsgLy8gZmlyc3QgZmllbGRcbiAgICB2YXIgc291cmNlRmlsZUluZGV4ID0gMDsgLy8gc2Vjb25kIGZpZWxkXG4gICAgdmFyIHNvdXJjZUNvZGVMaW5lID0gMDsgLy8gdGhpcmQgZmllbGRcbiAgICB2YXIgc291cmNlQ29kZUNvbHVtbiA9IDA7IC8vIGZvdXJ0aCBmaWVsZFxuICAgIHZhciBuYW1lSW5kZXggPSAwOyAvLyBmaWZ0aCBmaWVsZFxuICAgIHZhciBkZWNvZGVkID0gW107XG4gICAgdmFyIGxpbmUgPSBbXTtcbiAgICB2YXIgc2VnbWVudCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gMCwgc2hpZnQgPSAwLCB2YWx1ZSA9IDAsIGxlbiA9IG1hcHBpbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBjID0gbWFwcGluZ3MuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPT09IDQ0KSB7IC8vIFwiLFwiXG4gICAgICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgbGluZS5wdXNoKHNlZ21lbnQpO1xuICAgICAgICAgICAgc2VnbWVudCA9IFtdO1xuICAgICAgICAgICAgaiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA9PT0gNTkpIHsgLy8gXCI7XCJcbiAgICAgICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aClcbiAgICAgICAgICAgICAgICBsaW5lLnB1c2goc2VnbWVudCk7XG4gICAgICAgICAgICBzZWdtZW50ID0gW107XG4gICAgICAgICAgICBqID0gMDtcbiAgICAgICAgICAgIGRlY29kZWQucHVzaChsaW5lKTtcbiAgICAgICAgICAgIGxpbmUgPSBbXTtcbiAgICAgICAgICAgIGdlbmVyYXRlZENvZGVDb2x1bW4gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGludGVnZXIgPSBjaGFyVG9JbnRlZ2VyW2NdO1xuICAgICAgICAgICAgaWYgKGludGVnZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjaGFyYWN0ZXIgKCcgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpICsgJyknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBoYXNDb250aW51YXRpb25CaXQgPSBpbnRlZ2VyICYgMzI7XG4gICAgICAgICAgICBpbnRlZ2VyICY9IDMxO1xuICAgICAgICAgICAgdmFsdWUgKz0gaW50ZWdlciA8PCBzaGlmdDtcbiAgICAgICAgICAgIGlmIChoYXNDb250aW51YXRpb25CaXQpIHtcbiAgICAgICAgICAgICAgICBzaGlmdCArPSA1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHNob3VsZE5lZ2F0ZSA9IHZhbHVlICYgMTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA+Pj49IDE7XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZE5lZ2F0ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IC12YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAtMHg4MDAwMDAwMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGogPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZWRDb2RlQ29sdW1uICs9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBzZWdtZW50LnB1c2goZ2VuZXJhdGVkQ29kZUNvbHVtbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGogPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlRmlsZUluZGV4ICs9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBzZWdtZW50LnB1c2goc291cmNlRmlsZUluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaiA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2VDb2RlTGluZSArPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudC5wdXNoKHNvdXJjZUNvZGVMaW5lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaiA9PT0gMykge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2VDb2RlQ29sdW1uICs9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBzZWdtZW50LnB1c2goc291cmNlQ29kZUNvbHVtbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGogPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZUluZGV4ICs9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBzZWdtZW50LnB1c2gobmFtZUluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gc2hpZnQgPSAwOyAvLyByZXNldFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzZWdtZW50Lmxlbmd0aClcbiAgICAgICAgbGluZS5wdXNoKHNlZ21lbnQpO1xuICAgIGRlY29kZWQucHVzaChsaW5lKTtcbiAgICByZXR1cm4gZGVjb2RlZDtcbn1cbmZ1bmN0aW9uIGVuY29kZShkZWNvZGVkKSB7XG4gICAgdmFyIHNvdXJjZUZpbGVJbmRleCA9IDA7IC8vIHNlY29uZCBmaWVsZFxuICAgIHZhciBzb3VyY2VDb2RlTGluZSA9IDA7IC8vIHRoaXJkIGZpZWxkXG4gICAgdmFyIHNvdXJjZUNvZGVDb2x1bW4gPSAwOyAvLyBmb3VydGggZmllbGRcbiAgICB2YXIgbmFtZUluZGV4ID0gMDsgLy8gZmlmdGggZmllbGRcbiAgICB2YXIgbWFwcGluZ3MgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlY29kZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGxpbmUgPSBkZWNvZGVkW2ldO1xuICAgICAgICBpZiAoaSA+IDApXG4gICAgICAgICAgICBtYXBwaW5ncyArPSAnOyc7XG4gICAgICAgIGlmIChsaW5lLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB2YXIgZ2VuZXJhdGVkQ29kZUNvbHVtbiA9IDA7IC8vIGZpcnN0IGZpZWxkXG4gICAgICAgIHZhciBsaW5lTWFwcGluZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBsaW5lXzEgPSBsaW5lOyBfaSA8IGxpbmVfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBzZWdtZW50ID0gbGluZV8xW19pXTtcbiAgICAgICAgICAgIHZhciBzZWdtZW50TWFwcGluZ3MgPSBlbmNvZGVJbnRlZ2VyKHNlZ21lbnRbMF0gLSBnZW5lcmF0ZWRDb2RlQ29sdW1uKTtcbiAgICAgICAgICAgIGdlbmVyYXRlZENvZGVDb2x1bW4gPSBzZWdtZW50WzBdO1xuICAgICAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHNlZ21lbnRNYXBwaW5ncyArPVxuICAgICAgICAgICAgICAgICAgICBlbmNvZGVJbnRlZ2VyKHNlZ21lbnRbMV0gLSBzb3VyY2VGaWxlSW5kZXgpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZUludGVnZXIoc2VnbWVudFsyXSAtIHNvdXJjZUNvZGVMaW5lKSArXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVJbnRlZ2VyKHNlZ21lbnRbM10gLSBzb3VyY2VDb2RlQ29sdW1uKTtcbiAgICAgICAgICAgICAgICBzb3VyY2VGaWxlSW5kZXggPSBzZWdtZW50WzFdO1xuICAgICAgICAgICAgICAgIHNvdXJjZUNvZGVMaW5lID0gc2VnbWVudFsyXTtcbiAgICAgICAgICAgICAgICBzb3VyY2VDb2RlQ29sdW1uID0gc2VnbWVudFszXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA9PT0gNSkge1xuICAgICAgICAgICAgICAgIHNlZ21lbnRNYXBwaW5ncyArPSBlbmNvZGVJbnRlZ2VyKHNlZ21lbnRbNF0gLSBuYW1lSW5kZXgpO1xuICAgICAgICAgICAgICAgIG5hbWVJbmRleCA9IHNlZ21lbnRbNF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaW5lTWFwcGluZ3MucHVzaChzZWdtZW50TWFwcGluZ3MpO1xuICAgICAgICB9XG4gICAgICAgIG1hcHBpbmdzICs9IGxpbmVNYXBwaW5ncy5qb2luKCcsJyk7XG4gICAgfVxuICAgIHJldHVybiBtYXBwaW5ncztcbn1cbmZ1bmN0aW9uIGVuY29kZUludGVnZXIobnVtKSB7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIG51bSA9IG51bSA8IDAgPyAoLW51bSA8PCAxKSB8IDEgOiBudW0gPDwgMTtcbiAgICBkbyB7XG4gICAgICAgIHZhciBjbGFtcGVkID0gbnVtICYgMzE7XG4gICAgICAgIG51bSA+Pj49IDU7XG4gICAgICAgIGlmIChudW0gPiAwKSB7XG4gICAgICAgICAgICBjbGFtcGVkIHw9IDMyO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSBjaGFyc1tjbGFtcGVkXTtcbiAgICB9IHdoaWxlIChudW0gPiAwKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgeyBkZWNvZGUsIGVuY29kZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c291cmNlbWFwLWNvZGVjLmVzLmpzLm1hcFxuIiwiaW1wb3J0IHsgZGVjb2RlIH0gZnJvbSAnc291cmNlbWFwLWNvZGVjJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0TG9jYXRpb25Gcm9tU3RhY2soc3RhY2ssIG1hcCkge1xuXHRpZiAoIXN0YWNrKSByZXR1cm47XG5cdGNvbnN0IGxhc3QgPSBzdGFjay5zcGxpdCgnXFxuJylbMV07XG5cdGNvbnN0IG1hdGNoID0gLzxhbm9ueW1vdXM+OihcXGQrKTooXFxkKylcXCkkLy5leGVjKGxhc3QpO1xuXG5cdGlmICghbWF0Y2gpIHJldHVybiBudWxsO1xuXG5cdGNvbnN0IGxpbmUgPSArbWF0Y2hbMV07XG5cdGNvbnN0IGNvbHVtbiA9ICttYXRjaFsyXTtcblxuXHRyZXR1cm4gdHJhY2UoeyBsaW5lLCBjb2x1bW4gfSwgbWFwKTtcbn1cblxuZnVuY3Rpb24gdHJhY2UobG9jLCBtYXApIHtcblx0Y29uc3QgbWFwcGluZ3MgPSBkZWNvZGUobWFwLm1hcHBpbmdzKTtcblx0Y29uc3Qgc2VnbWVudHMgPSBtYXBwaW5nc1tsb2MubGluZSAtIDFdO1xuXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbaV07XG5cdFx0aWYgKHNlZ21lbnRbMF0gPT09IGxvYy5jb2x1bW4pIHtcblx0XHRcdGNvbnN0IFssIHNvdXJjZUluZGV4LCBsaW5lLCBjb2x1bW5dID0gc2VnbWVudDtcblx0XHRcdGNvbnN0IHNvdXJjZSA9IG1hcC5zb3VyY2VzW3NvdXJjZUluZGV4XS5zbGljZSgyKTtcblxuXHRcdFx0cmV0dXJuIHsgc291cmNlLCBsaW5lOiBsaW5lICsgMSwgY29sdW1uIH07XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG51bGw7XG59XG4iLCJsZXQgdWlkID0gMTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVwbFByb3h5IHtcblx0Y29uc3RydWN0b3IoaWZyYW1lLCBoYW5kbGVycykge1xuXHRcdHRoaXMuaWZyYW1lID0gaWZyYW1lO1xuXHRcdHRoaXMuaGFuZGxlcnMgPSBoYW5kbGVycztcblxuXHRcdHRoaXMucGVuZGluZ19jbWRzID0gbmV3IE1hcCgpO1xuXG5cdFx0dGhpcy5oYW5kbGVfZXZlbnQgPSBlID0+IHRoaXMuaGFuZGxlX3JlcGxfbWVzc2FnZShlKTtcblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMuaGFuZGxlX2V2ZW50LCBmYWxzZSk7XG5cdH1cblxuXHRkZXN0cm95KCkge1xuXHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5oYW5kbGVfZXZlbnQpO1xuXHR9XG5cblx0aWZyYW1lX2NvbW1hbmQoYWN0aW9uLCBhcmdzKSB7XG5cdFx0cmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHRcdGNvbnN0IGNtZF9pZCA9IHVpZCsrO1xuXG5cdFx0XHR0aGlzLnBlbmRpbmdfY21kcy5zZXQoY21kX2lkLCB7IHJlc29sdmUsIHJlamVjdCB9KTtcblxuXHRcdFx0dGhpcy5pZnJhbWUuY29udGVudFdpbmRvdy5wb3N0TWVzc2FnZSh7IGFjdGlvbiwgY21kX2lkLCBhcmdzIH0sICcqJyk7XG5cdFx0fSk7XG5cdH1cblxuXHRoYW5kbGVfY29tbWFuZF9tZXNzYWdlKGNtZF9kYXRhKSB7XG5cdFx0bGV0IGFjdGlvbiA9IGNtZF9kYXRhLmFjdGlvbjtcblx0XHRsZXQgaWQgPSBjbWRfZGF0YS5jbWRfaWQ7XG5cdFx0bGV0IGhhbmRsZXIgPSB0aGlzLnBlbmRpbmdfY21kcy5nZXQoaWQpO1xuXG5cdFx0aWYgKGhhbmRsZXIpIHtcblx0XHRcdHRoaXMucGVuZGluZ19jbWRzLmRlbGV0ZShpZCk7XG5cdFx0XHRpZiAoYWN0aW9uID09PSAnY21kX2Vycm9yJykge1xuXHRcdFx0XHRsZXQgeyBtZXNzYWdlLCBzdGFjayB9ID0gY21kX2RhdGE7XG5cdFx0XHRcdGxldCBlID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuXHRcdFx0XHRlLnN0YWNrID0gc3RhY2s7XG5cdFx0XHRcdGhhbmRsZXIucmVqZWN0KGUpXG5cdFx0XHR9XG5cblx0XHRcdGlmIChhY3Rpb24gPT09ICdjbWRfb2snKSB7XG5cdFx0XHRcdGhhbmRsZXIucmVzb2x2ZShjbWRfZGF0YS5hcmdzKVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdjb21tYW5kIG5vdCBmb3VuZCcsIGlkLCBjbWRfZGF0YSwgWy4uLnRoaXMucGVuZGluZ19jbWRzLmtleXMoKV0pO1xuXHRcdH1cblx0fVxuXG5cdGhhbmRsZV9yZXBsX21lc3NhZ2UoZXZlbnQpIHtcblx0XHRpZiAoZXZlbnQuc291cmNlICE9PSB0aGlzLmlmcmFtZS5jb250ZW50V2luZG93KSByZXR1cm47XG5cblx0XHRjb25zdCB7IGFjdGlvbiwgYXJncyB9ID0gZXZlbnQuZGF0YTtcblxuXHRcdGlmIChhY3Rpb24gPT09ICdjbWRfZXJyb3InIHx8IGFjdGlvbiA9PT0gJ2NtZF9vaycpIHtcblx0XHRcdHRoaXMuaGFuZGxlX2NvbW1hbmRfbWVzc2FnZShldmVudC5kYXRhKTtcblx0XHR9XG5cblx0XHRpZiAoYWN0aW9uID09PSAnZmV0Y2hfcHJvZ3Jlc3MnKSB7XG5cdFx0XHR0aGlzLmhhbmRsZXJzLm9uX2ZldGNoX3Byb2dyZXNzKGFyZ3MucmVtYWluaW5nKVxuXHRcdH1cblx0fVxuXG5cdGV2YWwoc2NyaXB0KSB7XG5cdFx0cmV0dXJuIHRoaXMuaWZyYW1lX2NvbW1hbmQoJ2V2YWwnLCB7IHNjcmlwdCB9KTtcblx0fVxuXG5cdGhhbmRsZV9saW5rcygpIHtcblx0XHRyZXR1cm4gdGhpcy5pZnJhbWVfY29tbWFuZCgnY2F0Y2hfY2xpY2tzJywge30pO1xuXHR9XG59IiwiZXhwb3J0IGRlZmF1bHQgXCI8IWRvY3R5cGUgaHRtbD5cXG48aHRtbD5cXG5cXHQ8aGVhZD5cXG5cXHRcXHQ8c3R5bGU+XFxuXFx0XFx0XFx0aHRtbCwgYm9keSB7XFxuXFx0cG9zaXRpb246IHJlbGF0aXZlO1xcblxcdHdpZHRoOiAxMDAlO1xcblxcdGhlaWdodDogMTAwJTtcXG59XFxuXFxuYm9keSB7XFxuXFx0Y29sb3I6ICMzMzM7XFxuXFx0bWFyZ2luOiAwO1xcblxcdHBhZGRpbmc6IDhweDtcXG5cXHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xcblxcdGZvbnQtZmFtaWx5OiAtYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsIFxcXCJTZWdvZSBVSVxcXCIsIFJvYm90bywgT3h5Z2VuLVNhbnMsIFVidW50dSwgQ2FudGFyZWxsLCBcXFwiSGVsdmV0aWNhIE5ldWVcXFwiLCBzYW5zLXNlcmlmO1xcbn1cXG5cXG5hIHtcXG5cXHRjb2xvcjogcmdiKDAsMTAwLDIwMCk7XFxuXFx0dGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbn1cXG5cXG5hOmhvdmVyIHtcXG5cXHR0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXG59XFxuXFxuYTp2aXNpdGVkIHtcXG5cXHRjb2xvcjogcmdiKDAsODAsMTYwKTtcXG59XFxuXFxubGFiZWwge1xcblxcdGRpc3BsYXk6IGJsb2NrO1xcbn1cXG5cXG5pbnB1dCwgYnV0dG9uLCBzZWxlY3QsIHRleHRhcmVhIHtcXG5cXHRmb250LWZhbWlseTogaW5oZXJpdDtcXG5cXHRmb250LXNpemU6IGluaGVyaXQ7XFxuXFx0cGFkZGluZzogMC40ZW07XFxuXFx0bWFyZ2luOiAwIDAgMC41ZW0gMDtcXG5cXHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xcblxcdGJvcmRlcjogMXB4IHNvbGlkICNjY2M7XFxuXFx0Ym9yZGVyLXJhZGl1czogMnB4O1xcbn1cXG5cXG5pbnB1dDpkaXNhYmxlZCB7XFxuXFx0Y29sb3I6ICNjY2M7XFxufVxcblxcbmlucHV0W3R5cGU9XFxcInJhbmdlXFxcIl0ge1xcblxcdGhlaWdodDogMDtcXG59XFxuXFxuYnV0dG9uIHtcXG5cXHRiYWNrZ3JvdW5kLWNvbG9yOiAjZjRmNGY0O1xcblxcdG91dGxpbmU6IG5vbmU7XFxufVxcblxcbmJ1dHRvbjphY3RpdmUge1xcblxcdGJhY2tncm91bmQtY29sb3I6ICNkZGQ7XFxufVxcblxcbmJ1dHRvbjpmb2N1cyB7XFxuXFx0Ym9yZGVyLWNvbG9yOiAjNjY2O1xcbn1cXG5cXHRcXHQ8L3N0eWxlPlxcblxcblxcdFxcdDxzY3JpcHQ+XFxuXFx0XFx0XFx0KGZ1bmN0aW9uKCl7XFxuXFx0XFx0XFx0XFx0ZnVuY3Rpb24gaGFuZGxlX21lc3NhZ2UoZXYpIHtcXG5cXHRcXHRcXHRcXHRcXHRsZXQgeyBhY3Rpb24sIGNtZF9pZCB9ID0gZXYuZGF0YTtcXG5cXHRcXHRcXHRcXHRcXHRjb25zdCBzZW5kX21lc3NhZ2UgPSAocGF5bG9hZCkgPT4gcGFyZW50LnBvc3RNZXNzYWdlKCB7IC4uLnBheWxvYWQgfSwgZXYub3JpZ2luKTtcXG5cXHRcXHRcXHRcXHRcXHRjb25zdCBzZW5kX3JlcGx5ID0gKHBheWxvYWQpID0+IHNlbmRfbWVzc2FnZSh7IC4uLnBheWxvYWQsIGNtZF9pZCB9KTtcXG5cXHRcXHRcXHRcXHRcXHRjb25zdCBzZW5kX29rID0gKCkgPT4gc2VuZF9yZXBseSh7IGFjdGlvbjogJ2NtZF9vaycgfSk7XFxuXFx0XFx0XFx0XFx0XFx0Y29uc3Qgc2VuZF9lcnJvciA9IChtZXNzYWdlLCBzdGFjaykgPT4gc2VuZF9yZXBseSh7IGFjdGlvbjogJ2NtZF9lcnJvcicsIG1lc3NhZ2UsIHN0YWNrIH0pO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmIChhY3Rpb24gPT09ICdldmFsJykge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRyeSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y29uc3QgeyBzY3JpcHQgfSA9IGV2LmRhdGEuYXJncztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRldmFsKHNjcmlwdCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c2VuZF9vaygpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH0gY2F0Y2ggKGUpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzZW5kX2Vycm9yKGUubWVzc2FnZSwgZS5zdGFjayk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoYWN0aW9uID09PSAnY2F0Y2hfY2xpY2tzJykge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRyeSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y29uc3QgdG9wX29yaWdpbiA9IGV2Lm9yaWdpbjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZXZlbnQgPT4ge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChldmVudC53aGljaCAhPT0gMSkgcmV0dXJuO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChldmVudC5tZXRhS2V5IHx8IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQuc2hpZnRLZXkpIHJldHVybjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkgcmV0dXJuO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGVuc3VyZSB0YXJnZXQgaXMgYSBsaW5rXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bGV0IGVsID0gZXZlbnQudGFyZ2V0O1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHdoaWxlIChlbCAmJiBlbC5ub2RlTmFtZSAhPT0gJ0EnKSBlbCA9IGVsLnBhcmVudE5vZGU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCFlbCB8fCBlbC5ub2RlTmFtZSAhPT0gJ0EnKSByZXR1cm47XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGVsLmhhc0F0dHJpYnV0ZSgnZG93bmxvYWQnKSB8fCBlbC5nZXRBdHRyaWJ1dGUoJ3JlbCcpID09PSAnZXh0ZXJuYWwnIHx8IGVsLnRhcmdldCkgcmV0dXJuO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGVsLmhyZWYuc3RhcnRzV2l0aCh0b3Bfb3JpZ2luKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbnN0IHVybCA9IG5ldyBVUkwoZWwuaHJlZik7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKHVybC5oYXNoWzBdID09PSAnIycpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR3aW5kb3cubG9jYXRpb24uaGFzaCA9IHVybC5oYXNoO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHdpbmRvdy5vcGVuKGVsLmhyZWYsICdfYmxhbmsnKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzZW5kX29rKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBjYXRjaChlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c2VuZF9lcnJvcihlLm1lc3NhZ2UsIGUuc3RhY2spO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgaGFuZGxlX21lc3NhZ2UsIGZhbHNlKTtcXG5cXHRcXHRcXHR9KS5jYWxsKHRoaXMpO1xcblxcdFxcdDwvc2NyaXB0PlxcblxcdDwvaGVhZD5cXG5cXHQ8Ym9keT48L2JvZHk+XFxuPC9odG1sPlwiOyIsIjxzY3JpcHQ+XG5cdGltcG9ydCB7IG9uTW91bnQsIGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciwgZ2V0Q29udGV4dCB9IGZyb20gJ3N2ZWx0ZSc7XG5cdGltcG9ydCBnZXRMb2NhdGlvbkZyb21TdGFjayBmcm9tICcuL2dldExvY2F0aW9uRnJvbVN0YWNrLmpzJztcblx0aW1wb3J0IFJlcGxQcm94eSBmcm9tICcuL1JlcGxQcm94eS5qcyc7XG5cdGltcG9ydCBNZXNzYWdlIGZyb20gJy4uL01lc3NhZ2Uuc3ZlbHRlJztcblx0aW1wb3J0IHNyY2RvYyBmcm9tICcuL3NyY2RvYy9pbmRleC5qcyc7XG5cdGltcG9ydCB7IGRlY29kZSB9IGZyb20gJ3NvdXJjZW1hcC1jb2RlYyc7XG5cblx0Y29uc3QgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKTtcblx0Y29uc3QgeyBidW5kbGUsIG5hdmlnYXRlIH0gPSBnZXRDb250ZXh0KCdSRVBMJyk7XG5cblx0ZXhwb3J0IGxldCBlcnJvcjsgLy8gVE9ETyBzaG91bGQgdGhpcyBiZSBleHBvc2VkIGFzIGEgcHJvcD9cblxuXHRleHBvcnQgZnVuY3Rpb24gc2V0UHJvcChwcm9wLCB2YWx1ZSkge1xuXHRcdGlmICghcHJveHkpIHJldHVybjtcblx0XHRwcm94eS5zZXRQcm9wKHByb3AsIHZhbHVlKTtcblx0fVxuXG5cdGV4cG9ydCBsZXQgc3RhdHVzO1xuXHRleHBvcnQgbGV0IHJlbGF4ZWQgPSBmYWxzZTtcblx0ZXhwb3J0IGxldCBpbmplY3RlZEpTID0gJyc7XG5cdGV4cG9ydCBsZXQgaW5qZWN0ZWRDU1MgPSAnJztcblxuXHRsZXQgaWZyYW1lO1xuXHRsZXQgcGVuZGluZ19pbXBvcnRzID0gMDtcblx0bGV0IHBlbmRpbmcgPSBmYWxzZTtcblxuXHRsZXQgcHJveHkgPSBudWxsO1xuXG5cdGxldCByZWFkeSA9IGZhbHNlO1xuXHRsZXQgaW5pdGVkID0gZmFsc2U7XG5cblx0b25Nb3VudCgoKSA9PiB7XG5cdFx0cHJveHkgPSBuZXcgUmVwbFByb3h5KGlmcmFtZSwge1xuXHRcdFx0b25fZmV0Y2hfcHJvZ3Jlc3M6IHByb2dyZXNzID0+IHtcblx0XHRcdFx0cGVuZGluZ19pbXBvcnRzID0gcHJvZ3Jlc3M7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRpZnJhbWUuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcblx0XHRcdHByb3h5LmhhbmRsZV9saW5rcygpO1xuXHRcdFx0cmVhZHkgPSB0cnVlO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuICgpID0+IHtcblx0XHRcdHByb3h5LmRlc3Ryb3koKTtcblx0XHR9XG5cdH0pO1xuXG5cdGFzeW5jIGZ1bmN0aW9uIGFwcGx5X2J1bmRsZSgkYnVuZGxlKSB7XG5cdFx0aWYgKCEkYnVuZGxlIHx8ICRidW5kbGUuZXJyb3IpIHJldHVybjtcblxuXHRcdHRyeSB7XG5cdFx0XHRhd2FpdCBwcm94eS5ldmFsKGBcblx0XHRcdFx0JHtpbmplY3RlZEpTfVxuXG5cdFx0XHRcdCR7c3R5bGVzfVxuXG5cdFx0XHRcdGNvbnN0IHN0eWxlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3N0eWxlW2lkXj1zdmVsdGUtXScpO1xuXG5cdFx0XHRcdCR7JGJ1bmRsZS5kb20uY29kZX1cblxuXHRcdFx0XHRsZXQgaSA9IHN0eWxlcy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlIChpLS0pIHN0eWxlc1tpXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlc1tpXSk7XG5cblx0XHRcdFx0aWYgKHdpbmRvdy5jb21wb25lbnQpIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0d2luZG93LmNvbXBvbmVudC4kZGVzdHJveSgpO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvcihlcnIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRvY3VtZW50LmJvZHkuaW5uZXJIVE1MID0gJyc7XG5cdFx0XHRcdHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gJyc7XG5cdFx0XHRcdHdpbmRvdy5fc3ZlbHRlVHJhbnNpdGlvbk1hbmFnZXIgPSBudWxsO1xuXG5cdFx0XHRcdHdpbmRvdy5jb21wb25lbnQgPSBuZXcgU3ZlbHRlQ29tcG9uZW50LmRlZmF1bHQoe1xuXHRcdFx0XHRcdHRhcmdldDogZG9jdW1lbnQuYm9keVxuXHRcdFx0XHR9KTtcblx0XHRcdGApO1xuXG5cdFx0XHRlcnJvciA9IG51bGw7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0Y29uc3QgbG9jID0gZ2V0TG9jYXRpb25Gcm9tU3RhY2soZS5zdGFjaywgJGJ1bmRsZS5kb20ubWFwKTtcblx0XHRcdGlmIChsb2MpIHtcblx0XHRcdFx0ZS5maWxlbmFtZSA9IGxvYy5zb3VyY2U7XG5cdFx0XHRcdGUubG9jID0geyBsaW5lOiBsb2MubGluZSwgY29sdW1uOiBsb2MuY29sdW1uIH07XG5cdFx0XHR9XG5cblx0XHRcdGVycm9yID0gZTtcblx0XHR9XG5cblx0XHRpbml0ZWQgPSB0cnVlO1xuXHR9XG5cblx0JDogaWYgKHJlYWR5KSBhcHBseV9idW5kbGUoJGJ1bmRsZSk7XG5cblx0JDogc3R5bGVzID0gaW5qZWN0ZWRDU1MgJiYgYHtcblx0XHRjb25zdCBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG5cdFx0c3R5bGUudGV4dENvbnRlbnQgPSAke0pTT04uc3RyaW5naWZ5KGluamVjdGVkQ1NTKX07XG5cdFx0ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzdHlsZSk7XG5cdH1gO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cblx0LmlmcmFtZS1jb250YWluZXIge1xuXHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHRiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcblx0XHRib3JkZXI6IG5vbmU7XG5cdFx0d2lkdGg6IDEwMCU7XG5cdFx0aGVpZ2h0OiAxMDAlO1xuXHR9XG5cblx0aWZyYW1lIHtcblx0XHR3aWR0aDogMTAwJTtcblx0XHRoZWlnaHQ6IDEwMCU7XG5cdFx0LyogaGVpZ2h0OiBjYWxjKDEwMHZoIC0gdmFyKC0tbmF2LWgpKTsgKi9cblx0XHRib3JkZXI6IG5vbmU7XG5cdFx0ZGlzcGxheTogYmxvY2s7XG5cdH1cblxuXHQuZ3JleWVkLW91dCB7XG5cdFx0ZmlsdGVyOiBncmF5c2NhbGUoNTAlKSBibHVyKDFweCk7XG5cdFx0b3BhY2l0eTogLjI1O1xuXHR9XG5cblx0Lm92ZXJsYXkge1xuXHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHRib3R0b206IDA7XG5cdFx0d2lkdGg6IDEwMCU7XG5cdH1cbjwvc3R5bGU+XG5cbjxkaXYgY2xhc3M9XCJpZnJhbWUtY29udGFpbmVyXCI+XG5cdDxpZnJhbWVcblx0XHR0aXRsZT1cIlJlc3VsdFwiXG5cdFx0Y2xhc3M6aW5pdGVkXG5cdFx0YmluZDp0aGlzPXtpZnJhbWV9XG5cdFx0c2FuZGJveD1cImFsbG93LXBvcHVwcy10by1lc2NhcGUtc2FuZGJveCBhbGxvdy1zY3JpcHRzIGFsbG93LXBvcHVwcyBhbGxvdy1mb3JtcyBhbGxvdy1wb2ludGVyLWxvY2sgYWxsb3ctdG9wLW5hdmlnYXRpb24gYWxsb3ctbW9kYWxzIHtyZWxheGVkID8gJ2FsbG93LXNhbWUtb3JpZ2luJyA6ICcnfVwiXG5cdFx0Y2xhc3M9XCJ7ZXJyb3IgfHwgcGVuZGluZyB8fCBwZW5kaW5nX2ltcG9ydHMgPyAnZ3JleWVkLW91dCcgOiAnJ31cIlxuXHRcdHtzcmNkb2N9XG5cdD48L2lmcmFtZT5cblxuXHQ8ZGl2IGNsYXNzPVwib3ZlcmxheVwiPlxuXHRcdHsjaWYgZXJyb3J9XG5cdFx0XHQ8TWVzc2FnZSBraW5kPVwiZXJyb3JcIiBkZXRhaWxzPXtlcnJvcn0vPlxuXHRcdHs6ZWxzZSBpZiBzdGF0dXMgfHwgISRidW5kbGV9XG5cdFx0XHQ8TWVzc2FnZSBraW5kPVwiaW5mb1wiIHRydW5jYXRlPntzdGF0dXMgfHwgJ2xvYWRpbmcgU3ZlbHRlIGNvbXBpbGVyLi4uJ308L01lc3NhZ2U+XG5cdFx0ey9pZn1cblx0PC9kaXY+XG48L2Rpdj4iLCI8c2NyaXB0PlxuXHRpbXBvcnQgeyBnZXRDb250ZXh0IH0gZnJvbSAnc3ZlbHRlJztcblxuXHRjb25zdCB7IGNvbXBpbGVfb3B0aW9ucyB9ID0gZ2V0Q29udGV4dCgnUkVQTCcpO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cblx0Lm9wdGlvbnMge1xuXHRcdHBhZGRpbmc6IDAgMTBweDtcblx0XHRmb250LWZhbWlseTogdmFyKC0tZm9udC1tb25vKTtcblx0XHRmb250LXNpemU6IDEzcHg7XG5cdFx0Y29sb3I6ICM5OTk7XG5cdFx0bGluZS1oZWlnaHQ6IDEuODtcblx0fVxuXG5cdC5vcHRpb24ge1xuXHRcdGRpc3BsYXk6IGJsb2NrO1xuXHRcdHBhZGRpbmc6IDAgMCAwIDEuMjVlbTtcblx0XHR3aGl0ZS1zcGFjZTogbm93cmFwO1xuXHRcdGNvbG9yOiAjMzMzO1xuXHRcdHVzZXItc2VsZWN0OiBub25lO1xuXHR9XG5cblx0LmtleSB7XG5cdFx0ZGlzcGxheTogaW5saW5lLWJsb2NrO1xuXHRcdHdpZHRoOiA5ZW07XG5cdH1cblxuXHQuc3RyaW5nIHtcblx0XHRjb2xvcjogaHNsKDQxLCAzNyUsIDQ1JSk7XG5cdH1cblxuXHQuYm9vbGVhbiB7XG5cdFx0Y29sb3I6IGhzbCg0NSwgNyUsIDQ1JSk7XG5cdH1cblxuXHRsYWJlbCB7XG5cdFx0ZGlzcGxheTogaW5saW5lLWJsb2NrO1xuXHR9XG5cblx0bGFiZWxbZm9yXSB7XG5cdFx0Y29sb3I6IHZhcigtLXN0cmluZyk7XG5cdH1cblxuXHRpbnB1dFt0eXBlPWNoZWNrYm94XSB7XG5cdFx0dG9wOiAtMXB4O1xuXHR9XG5cblx0aW5wdXRbdHlwZT1yYWRpb10ge1xuXHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHR0b3A6IGF1dG87XG5cdFx0b3ZlcmZsb3c6IGhpZGRlbjtcblx0XHRjbGlwOiByZWN0KDFweCwgMXB4LCAxcHgsIDFweCk7XG5cdFx0d2lkdGg6IDFweDtcblx0XHRoZWlnaHQ6IDFweDtcblx0XHR3aGl0ZS1zcGFjZTogbm93cmFwO1xuXHR9XG5cblx0aW5wdXRbdHlwZT1yYWRpb10gKyBsYWJlbCB7XG5cdFx0cGFkZGluZzogMCAwIDAgMS42ZW07XG5cdFx0bWFyZ2luOiAwIDAuNmVtIDAgMDtcblx0XHRvcGFjaXR5OiAwLjc7XG5cdH1cblxuXHRpbnB1dFt0eXBlPXJhZGlvXTpjaGVja2VkICsgbGFiZWwge1xuXHRcdG9wYWNpdHk6IDE7XG5cdH1cblxuXHQvKiBpbnB1dFt0eXBlPXJhZGlvXTpmb2N1cyArIGxhYmVsIHtcblx0XHRjb2xvcjogIzAwZjtcblx0XHRvdXRsaW5lOiAxcHggZG90dGVkICMwMGY7XG5cdH0gKi9cblxuXHRpbnB1dFt0eXBlPXJhZGlvXSArIGxhYmVsOmJlZm9yZSB7XG5cdFx0Y29udGVudDogJyc7XG5cdFx0YmFja2dyb3VuZDogI2VlZTtcblx0XHRkaXNwbGF5OiBibG9jaztcblx0XHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRcdGZsb2F0OiBsZWZ0O1xuXHRcdHdpZHRoOiAxNXB4O1xuXHRcdGhlaWdodDogMTVweDtcblx0XHRtYXJnaW4tbGVmdDogLTIxcHg7XG5cdFx0bWFyZ2luLXRvcDogNHB4O1xuXHRcdHZlcnRpY2FsLWFsaWduOiB0b3A7XG5cdFx0Y3Vyc29yOiBwb2ludGVyO1xuXHRcdHRleHQtYWxpZ246IGNlbnRlcjtcblx0XHR0cmFuc2l0aW9uOiBib3gtc2hhZG93IDAuMXMgZWFzZS1vdXQ7XG5cdH1cblxuXHRpbnB1dFt0eXBlPXJhZGlvXSArIGxhYmVsOmJlZm9yZSB7XG5cdFx0YmFja2dyb3VuZC1jb2xvcjogdmFyKC0tc2Vjb25kKTtcblx0XHRib3JkZXItcmFkaXVzOiAxMDAlO1xuXHRcdGJveC1zaGFkb3c6IGluc2V0IDAgMCAwIDAuNWVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgLjk1KTtcblx0XHRib3JkZXI6IDFweCBzb2xpZCB2YXIoLS1zZWNvbmQpO1xuXHR9XG5cblx0aW5wdXRbdHlwZT1yYWRpb106Y2hlY2tlZCArIGxhYmVsOmJlZm9yZSB7XG5cdFx0YmFja2dyb3VuZC1jb2xvcjogdmFyKC0tcHJpbWUpO1xuXHRcdGJveC1zaGFkb3c6IGluc2V0IDAgMCAwIC4xNWVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgLjk1KTtcblx0XHRib3JkZXI6IDFweCBzb2xpZCB2YXIoLS1zZWNvbmQpO1xuXHRcdHRyYW5zaXRpb246IGJveC1zaGFkb3cgMC4ycyBlYXNlLW91dDtcblx0fVxuPC9zdHlsZT5cblxuPGRpdiBjbGFzcz1cIm9wdGlvbnNcIj5cblx0cmVzdWx0ID0gc3ZlbHRlLmNvbXBpbGUoc291cmNlLCAmIzEyMztcblx0PGRpdiBjbGFzcz1cIm9wdGlvblwiPlxuXHRcdDxzcGFuIGNsYXNzPVwia2V5XCI+Z2VuZXJhdGU6PC9zcGFuPlxuXG5cdFx0PGlucHV0IGlkPVwiZG9tLWlucHV0XCIgdHlwZT1cInJhZGlvXCIgYmluZDpncm91cD17JGNvbXBpbGVfb3B0aW9ucy5nZW5lcmF0ZX0gdmFsdWU9XCJkb21cIj5cblx0XHQ8bGFiZWwgZm9yPVwiZG9tLWlucHV0XCI+PHNwYW4gY2xhc3M9XCJzdHJpbmdcIj5cImRvbVwiPC9zcGFuPjwvbGFiZWw+XG5cblx0XHQ8aW5wdXQgaWQ9XCJzc3ItaW5wdXRcIiB0eXBlPVwicmFkaW9cIiBiaW5kOmdyb3VwPXskY29tcGlsZV9vcHRpb25zLmdlbmVyYXRlfSB2YWx1ZT1cInNzclwiPlxuXHRcdDxsYWJlbCBmb3I9XCJzc3ItaW5wdXRcIj48c3BhbiBjbGFzcz1cInN0cmluZ1wiPlwic3NyXCI8L3NwYW4+LDwvbGFiZWw+XG5cdDwvZGl2PlxuXG5cdDxsYWJlbCBjbGFzcz1cIm9wdGlvblwiPlxuXHRcdDxzcGFuIGNsYXNzPVwia2V5XCI+ZGV2Ojwvc3Bhbj5cblx0XHQ8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgYmluZDpjaGVja2VkPXskY29tcGlsZV9vcHRpb25zLmRldn0+IDxzcGFuIGNsYXNzPVwiYm9vbGVhblwiPnskY29tcGlsZV9vcHRpb25zLmRldn08L3NwYW4+LFxuXHQ8L2xhYmVsPlxuXG5cdDxsYWJlbCBjbGFzcz1cIm9wdGlvblwiPlxuXHRcdDxzcGFuIGNsYXNzPVwia2V5XCI+Y3NzOjwvc3Bhbj5cblx0XHQ8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgYmluZDpjaGVja2VkPXskY29tcGlsZV9vcHRpb25zLmNzc30+IDxzcGFuIGNsYXNzPVwiYm9vbGVhblwiPnskY29tcGlsZV9vcHRpb25zLmNzc308L3NwYW4+LFxuXHQ8L2xhYmVsPlxuXG5cdDxsYWJlbCBjbGFzcz1cIm9wdGlvblwiPlxuXHRcdDxzcGFuIGNsYXNzPVwia2V5XCI+aHlkcmF0YWJsZTo8L3NwYW4+XG5cdFx0PGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGJpbmQ6Y2hlY2tlZD17JGNvbXBpbGVfb3B0aW9ucy5oeWRyYXRhYmxlfT4gPHNwYW4gY2xhc3M9XCJib29sZWFuXCI+eyRjb21waWxlX29wdGlvbnMuaHlkcmF0YWJsZX08L3NwYW4+LFxuXHQ8L2xhYmVsPlxuXG5cdDxsYWJlbCBjbGFzcz1cIm9wdGlvblwiPlxuXHRcdDxzcGFuIGNsYXNzPVwia2V5XCI+Y3VzdG9tRWxlbWVudDo8L3NwYW4+XG5cdFx0PGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGJpbmQ6Y2hlY2tlZD17JGNvbXBpbGVfb3B0aW9ucy5jdXN0b21FbGVtZW50fT4gPHNwYW4gY2xhc3M9XCJib29sZWFuXCI+eyRjb21waWxlX29wdGlvbnMuY3VzdG9tRWxlbWVudH08L3NwYW4+LFxuXHQ8L2xhYmVsPlxuXG5cdDxsYWJlbCBjbGFzcz1cIm9wdGlvblwiPlxuXHRcdDxzcGFuIGNsYXNzPVwia2V5XCI+aW1tdXRhYmxlOjwvc3Bhbj5cblx0XHQ8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgYmluZDpjaGVja2VkPXskY29tcGlsZV9vcHRpb25zLmltbXV0YWJsZX0+IDxzcGFuIGNsYXNzPVwiYm9vbGVhblwiPnskY29tcGlsZV9vcHRpb25zLmltbXV0YWJsZX08L3NwYW4+LFxuXHQ8L2xhYmVsPlxuXG5cdDxsYWJlbCBjbGFzcz1cIm9wdGlvblwiPlxuXHRcdDxzcGFuIGNsYXNzPVwia2V5XCI+bGVnYWN5Ojwvc3Bhbj5cblx0XHQ8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgYmluZDpjaGVja2VkPXskY29tcGlsZV9vcHRpb25zLmxlZ2FjeX0+IDxzcGFuIGNsYXNzPVwiYm9vbGVhblwiPnskY29tcGlsZV9vcHRpb25zLmxlZ2FjeX08L3NwYW4+XG5cdDwvbGFiZWw+XG5cdH0pO1xuPC9kaXY+IiwiY29uc3Qgd29ya2VycyA9IG5ldyBNYXAoKTtcblxubGV0IHVpZCA9IDE7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbXBpbGVyIHtcblx0Y29uc3RydWN0b3Iod29ya2Vyc1VybCwgc3ZlbHRlVXJsKSB7XG5cdFx0aWYgKCF3b3JrZXJzLmhhcyhzdmVsdGVVcmwpKSB7XG5cdFx0XHRjb25zdCB3b3JrZXIgPSBuZXcgV29ya2VyKGAke3dvcmtlcnNVcmx9L2NvbXBpbGVyLmpzYCk7XG5cdFx0XHR3b3JrZXIucG9zdE1lc3NhZ2UoeyB0eXBlOiAnaW5pdCcsIHN2ZWx0ZVVybCB9KTtcblx0XHRcdHdvcmtlcnMuc2V0KHN2ZWx0ZVVybCwgd29ya2VyKTtcblx0XHR9XG5cblx0XHR0aGlzLndvcmtlciA9IHdvcmtlcnMuZ2V0KHN2ZWx0ZVVybCk7XG5cblx0XHR0aGlzLmhhbmRsZXJzID0gbmV3IE1hcCgpO1xuXG5cdFx0dGhpcy53b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGV2ZW50ID0+IHtcblx0XHRcdGNvbnN0IGhhbmRsZXIgPSB0aGlzLmhhbmRsZXJzLmdldChldmVudC5kYXRhLmlkKTtcblxuXHRcdFx0aWYgKGhhbmRsZXIpIHsgLy8gaWYgbm8gaGFuZGxlciwgd2FzIG1lYW50IGZvciBhIGRpZmZlcmVudCBSRVBMXG5cdFx0XHRcdGhhbmRsZXIoZXZlbnQuZGF0YS5yZXN1bHQpO1xuXHRcdFx0XHR0aGlzLmhhbmRsZXJzLmRlbGV0ZShldmVudC5kYXRhLmlkKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdGNvbXBpbGUoY29tcG9uZW50LCBvcHRpb25zKSB7XG5cdFx0cmV0dXJuIG5ldyBQcm9taXNlKGZ1bGZpbCA9PiB7XG5cdFx0XHRjb25zdCBpZCA9IHVpZCsrO1xuXG5cdFx0XHR0aGlzLmhhbmRsZXJzLnNldChpZCwgZnVsZmlsKTtcblxuXHRcdFx0dGhpcy53b3JrZXIucG9zdE1lc3NhZ2Uoe1xuXHRcdFx0XHRpZCxcblx0XHRcdFx0dHlwZTogJ2NvbXBpbGUnLFxuXHRcdFx0XHRzb3VyY2U6IGNvbXBvbmVudC5zb3VyY2UsXG5cdFx0XHRcdG9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe1xuXHRcdFx0XHRcdG5hbWU6IGNvbXBvbmVudC5uYW1lLFxuXHRcdFx0XHRcdGZpbGVuYW1lOiBgJHtjb21wb25lbnQubmFtZX0uc3ZlbHRlYFxuXHRcdFx0XHR9LCBvcHRpb25zKSxcblx0XHRcdFx0ZW50cnk6IGNvbXBvbmVudC5uYW1lID09PSAnQXBwJ1xuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdH1cblxuXHRkZXN0cm95KCkge1xuXHRcdHRoaXMud29ya2VyLnRlcm1pbmF0ZSgpO1xuXHR9XG59IiwiPHNjcmlwdD5cblx0aW1wb3J0IHsgZ2V0Q29udGV4dCwgb25Nb3VudCB9IGZyb20gJ3N2ZWx0ZSc7XG5cdGltcG9ydCBTcGxpdFBhbmUgZnJvbSAnLi4vU3BsaXRQYW5lLnN2ZWx0ZSc7XG5cdGltcG9ydCBWaWV3ZXIgZnJvbSAnLi9WaWV3ZXIuc3ZlbHRlJztcblx0aW1wb3J0IENvbXBpbGVyT3B0aW9ucyBmcm9tICcuL0NvbXBpbGVyT3B0aW9ucy5zdmVsdGUnO1xuXHRpbXBvcnQgQ29tcGlsZXIgZnJvbSAnLi9Db21waWxlci5qcyc7XG5cdGltcG9ydCBDb2RlTWlycm9yIGZyb20gJy4uL0NvZGVNaXJyb3Iuc3ZlbHRlJztcblx0aW1wb3J0IHsgaXNfYnJvd3NlciB9IGZyb20gJy4uL2Vudi5qcyc7XG5cblx0Y29uc3QgeyByZWdpc3Rlcl9vdXRwdXQgfSA9IGdldENvbnRleHQoJ1JFUEwnKTtcblxuXHRleHBvcnQgbGV0IHN2ZWx0ZVVybDtcblx0ZXhwb3J0IGxldCB3b3JrZXJzVXJsO1xuXHRleHBvcnQgbGV0IHN0YXR1cztcblx0ZXhwb3J0IGxldCBzb3VyY2VFcnJvckxvYyA9IG51bGw7XG5cdGV4cG9ydCBsZXQgcnVudGltZUVycm9yID0gbnVsbDtcblx0ZXhwb3J0IGxldCBlbWJlZGRlZCA9IGZhbHNlO1xuXHRleHBvcnQgbGV0IHJlbGF4ZWQgPSBmYWxzZTtcblx0ZXhwb3J0IGxldCBpbmplY3RlZEpTO1xuXHRleHBvcnQgbGV0IGluamVjdGVkQ1NTO1xuXG5cdGxldCBmb287IC8vIFRPRE8gd29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL3N2ZWx0ZWpzL3N2ZWx0ZS9pc3N1ZXMvMjEyMlxuXG5cdHJlZ2lzdGVyX291dHB1dCh7XG5cdFx0c2V0OiBhc3luYyAoc2VsZWN0ZWQsIG9wdGlvbnMpID0+IHtcblx0XHRcdGlmIChzZWxlY3RlZC50eXBlID09PSAnanMnKSB7XG5cdFx0XHRcdGpzX2VkaXRvci5zZXQoYC8qIFNlbGVjdCBhIGNvbXBvbmVudCB0byBzZWUgaXRzIGNvbXBpbGVkIGNvZGUgKi9gKTtcblx0XHRcdFx0Y3NzX2VkaXRvci5zZXQoYC8qIFNlbGVjdCBhIGNvbXBvbmVudCB0byBzZWUgaXRzIGNvbXBpbGVkIGNvZGUgKi9gKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBjb21waWxlZCA9IGF3YWl0IGNvbXBpbGVyLmNvbXBpbGUoc2VsZWN0ZWQsIG9wdGlvbnMpO1xuXHRcdFx0aWYgKCFqc19lZGl0b3IpIHJldHVybjsgLy8gdW5tb3VudGVkXG5cblx0XHRcdGpzX2VkaXRvci5zZXQoY29tcGlsZWQuanMsICdqcycpO1xuXHRcdFx0Y3NzX2VkaXRvci5zZXQoY29tcGlsZWQuY3NzLCAnY3NzJyk7XG5cdFx0fSxcblxuXHRcdHVwZGF0ZTogYXN5bmMgKHNlbGVjdGVkLCBvcHRpb25zKSA9PiB7XG5cdFx0XHRpZiAoc2VsZWN0ZWQudHlwZSA9PT0gJ2pzJykgcmV0dXJuO1xuXG5cdFx0XHRjb25zdCBjb21waWxlZCA9IGF3YWl0IGNvbXBpbGVyLmNvbXBpbGUoc2VsZWN0ZWQsIG9wdGlvbnMpO1xuXHRcdFx0aWYgKCFqc19lZGl0b3IpIHJldHVybjsgLy8gdW5tb3VudGVkXG5cblx0XHRcdGpzX2VkaXRvci51cGRhdGUoY29tcGlsZWQuanMpO1xuXHRcdFx0Y3NzX2VkaXRvci51cGRhdGUoY29tcGlsZWQuY3NzKTtcblx0XHR9XG5cdH0pO1xuXG5cdGNvbnN0IGNvbXBpbGVyID0gaXNfYnJvd3NlciAmJiBuZXcgQ29tcGlsZXIod29ya2Vyc1VybCwgc3ZlbHRlVXJsKTtcblxuXHQvLyByZWZzXG5cdGxldCB2aWV3ZXI7XG5cdGxldCBqc19lZGl0b3I7XG5cdGxldCBjc3NfZWRpdG9yO1xuXHRjb25zdCBzZXR0ZXJzID0ge307XG5cblx0bGV0IHZpZXcgPSAncmVzdWx0Jztcbjwvc2NyaXB0PlxuXG48c3R5bGU+XG5cdC52aWV3LXRvZ2dsZSB7XG5cdFx0aGVpZ2h0OiB2YXIoLS1wYW5lLWNvbnRyb2xzLWgpO1xuXHRcdGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZWVlO1xuXHRcdHdoaXRlLXNwYWNlOiBub3dyYXA7XG5cdFx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0fVxuXG5cdGJ1dHRvbiB7XG5cdFx0Lyogd2lkdGg6IDUwJTtcblx0XHRoZWlnaHQ6IDEwMCU7ICovXG5cdFx0YmFja2dyb3VuZDogd2hpdGU7XG5cdFx0dGV4dC1hbGlnbjogbGVmdDtcblx0XHRwb3NpdGlvbjogcmVsYXRpdmU7XG5cdFx0Zm9udDogNDAwIDEycHgvMS41IHZhcigtLWZvbnQpO1xuXHRcdGJvcmRlcjogbm9uZTtcblx0XHRib3JkZXItYm90dG9tOiAzcHggc29saWQgdHJhbnNwYXJlbnQ7XG5cdFx0cGFkZGluZzogMTJweCAxMnB4IDhweCAxMnB4O1xuXHRcdGNvbG9yOiAjOTk5O1xuXHRcdGJvcmRlci1yYWRpdXM6IDA7XG5cdH1cblxuXHRidXR0b24uYWN0aXZlIHtcblx0XHRib3JkZXItYm90dG9tOiAzcHggc29saWQgdmFyKC0tcHJpbWUpO1xuXHRcdGNvbG9yOiAjMzMzO1xuXHR9XG5cblx0ZGl2W3Nsb3RdIHtcblx0XHRoZWlnaHQ6IDEwMCU7XG5cdH1cblxuXHRzZWN0aW9uW3Nsb3RdIHtcblx0XHRvdmVyZmxvdzogYXV0bztcblx0fVxuXG5cdGgzIHtcblx0XHRmb250OiA3MDAgMTJweC8xLjUgdmFyKC0tZm9udCk7XG5cdFx0cGFkZGluZzogMTJweCAwIDhweCAxMHB4O1xuXHRcdC8qIGNvbG9yOiB2YXIoLS10ZXh0KTsgKi9cblx0XHRjb2xvcjogIzMzMztcblx0fVxuXG5cdC50YWItY29udGVudCB7XG5cdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdHdpZHRoOiAxMDAlO1xuXHRcdGhlaWdodDogY2FsYygxMDAlIC0gNDJweCk7XG5cdFx0b3BhY2l0eTogMDtcblx0XHRwb2ludGVyLWV2ZW50czogbm9uZTtcblx0fVxuXG5cdC50YWItY29udGVudC52aXNpYmxlIHtcblx0XHQvKiBjYW4ndCB1c2UgdmlzaWJpbGl0eSBkdWUgdG8gYSB3ZWlyZCBwYWludGluZyBidWcgaW4gQ2hyb21lICovXG5cdFx0b3BhY2l0eTogMTtcblx0XHRwb2ludGVyLWV2ZW50czogYWxsO1xuXHR9XG48L3N0eWxlPlxuXG48ZGl2IGNsYXNzPVwidmlldy10b2dnbGVcIj5cblx0PGJ1dHRvblxuXHRcdGNsYXNzOmFjdGl2ZT1cInt2aWV3ID09PSAncmVzdWx0J31cIlxuXHRcdG9uOmNsaWNrPVwieygpID0+IHZpZXcgPSAncmVzdWx0J31cIlxuXHQ+UmVzdWx0PC9idXR0b24+XG5cblx0PGJ1dHRvblxuXHRcdGNsYXNzOmFjdGl2ZT1cInt2aWV3ID09PSAnanMnfVwiXG5cdFx0b246Y2xpY2s9XCJ7KCkgPT4gdmlldyA9ICdqcyd9XCJcblx0PkpTIG91dHB1dDwvYnV0dG9uPlxuXG5cdDxidXR0b25cblx0XHRjbGFzczphY3RpdmU9XCJ7dmlldyA9PT0gJ2Nzcyd9XCJcblx0XHRvbjpjbGljaz1cInsoKSA9PiB2aWV3ID0gJ2Nzcyd9XCJcblx0PkNTUyBvdXRwdXQ8L2J1dHRvbj5cbjwvZGl2PlxuXG48IS0tIGNvbXBvbmVudCB2aWV3ZXIgLS0+XG48ZGl2IGNsYXNzPVwidGFiLWNvbnRlbnRcIiBjbGFzczp2aXNpYmxlPVwie3ZpZXcgPT09ICdyZXN1bHQnfVwiPlxuXHQ8Vmlld2VyXG5cdFx0YmluZDp0aGlzPXt2aWV3ZXJ9XG5cdFx0YmluZDplcnJvcj17cnVudGltZUVycm9yfVxuXHRcdHtzdGF0dXN9XG5cdFx0e3JlbGF4ZWR9XG5cdFx0e2luamVjdGVkSlN9XG5cdFx0e2luamVjdGVkQ1NTfVxuXHQvPlxuPC9kaXY+XG5cbjwhLS0ganMgb3V0cHV0IC0tPlxuPGRpdiBjbGFzcz1cInRhYi1jb250ZW50XCIgY2xhc3M6dmlzaWJsZT1cInt2aWV3ID09PSAnanMnfVwiPlxuXHR7I2lmIGVtYmVkZGVkfVxuXHRcdDxDb2RlTWlycm9yXG5cdFx0XHRiaW5kOnRoaXM9e2pzX2VkaXRvcn1cblx0XHRcdG1vZGU9XCJqc1wiXG5cdFx0XHRlcnJvckxvYz17c291cmNlRXJyb3JMb2N9XG5cdFx0XHRyZWFkb25seVxuXHRcdC8+XG5cdHs6ZWxzZX1cblx0XHQ8U3BsaXRQYW5lIHR5cGU9XCJ2ZXJ0aWNhbFwiIHBvcz17Njd9PlxuXHRcdFx0PGRpdiBzbG90PVwiYVwiPlxuXHRcdFx0XHQ8Q29kZU1pcnJvclxuXHRcdFx0XHRcdGJpbmQ6dGhpcz17anNfZWRpdG9yfVxuXHRcdFx0XHRcdG1vZGU9XCJqc1wiXG5cdFx0XHRcdFx0ZXJyb3JMb2M9e3NvdXJjZUVycm9yTG9jfVxuXHRcdFx0XHRcdHJlYWRvbmx5XG5cdFx0XHRcdC8+XG5cdFx0XHQ8L2Rpdj5cblxuXHRcdFx0PHNlY3Rpb24gc2xvdD1cImJcIj5cblx0XHRcdFx0PGgzPkNvbXBpbGVyIG9wdGlvbnM8L2gzPlxuXG5cdFx0XHRcdDxDb21waWxlck9wdGlvbnMgYmluZDpmb289e2Zvb30vPlxuXHRcdFx0PC9zZWN0aW9uPlxuXHRcdDwvU3BsaXRQYW5lPlxuXHR7L2lmfVxuPC9kaXY+XG5cbjwhLS0gY3NzIG91dHB1dCAtLT5cbjxkaXYgY2xhc3M9XCJ0YWItY29udGVudFwiIGNsYXNzOnZpc2libGU9XCJ7dmlldyA9PT0gJ2Nzcyd9XCI+XG5cdDxDb2RlTWlycm9yXG5cdFx0YmluZDp0aGlzPXtjc3NfZWRpdG9yfVxuXHRcdG1vZGU9XCJjc3NcIlxuXHRcdGVycm9yTG9jPXtzb3VyY2VFcnJvckxvY31cblx0XHRyZWFkb25seVxuXHQvPlxuPC9kaXY+XG4iLCJjb25zdCB3b3JrZXJzID0gbmV3IE1hcCgpO1xuXG5sZXQgdWlkID0gMTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnVuZGxlciB7XG5cdGNvbnN0cnVjdG9yKHsgd29ya2Vyc1VybCwgcGFja2FnZXNVcmwsIHN2ZWx0ZVVybCwgb25zdGF0dXMgfSkge1xuXHRcdGNvbnN0IGhhc2ggPSBgJHtwYWNrYWdlc1VybH06JHtzdmVsdGVVcmx9YDtcblxuXHRcdGlmICghd29ya2Vycy5oYXMoaGFzaCkpIHtcblx0XHRcdGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIoYCR7d29ya2Vyc1VybH0vYnVuZGxlci5qc2ApO1xuXHRcdFx0d29ya2VyLnBvc3RNZXNzYWdlKHsgdHlwZTogJ2luaXQnLCBwYWNrYWdlc1VybCwgc3ZlbHRlVXJsIH0pO1xuXHRcdFx0d29ya2Vycy5zZXQoaGFzaCwgd29ya2VyKTtcblx0XHR9XG5cblx0XHR0aGlzLndvcmtlciA9IHdvcmtlcnMuZ2V0KGhhc2gpO1xuXG5cdFx0dGhpcy5oYW5kbGVycyA9IG5ldyBNYXAoKTtcblxuXHRcdHRoaXMud29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBldmVudCA9PiB7XG5cdFx0XHRjb25zdCBoYW5kbGVyID0gdGhpcy5oYW5kbGVycy5nZXQoZXZlbnQuZGF0YS51aWQpO1xuXG5cdFx0XHRpZiAoaGFuZGxlcikgeyAvLyBpZiBubyBoYW5kbGVyLCB3YXMgbWVhbnQgZm9yIGEgZGlmZmVyZW50IFJFUExcblx0XHRcdFx0aWYgKGV2ZW50LmRhdGEudHlwZSA9PT0gJ3N0YXR1cycpIHtcblx0XHRcdFx0XHRvbnN0YXR1cyhldmVudC5kYXRhLm1lc3NhZ2UpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG9uc3RhdHVzKG51bGwpO1xuXHRcdFx0XHRoYW5kbGVyKGV2ZW50LmRhdGEpO1xuXHRcdFx0XHR0aGlzLmhhbmRsZXJzLmRlbGV0ZShldmVudC5kYXRhLnVpZCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXHRidW5kbGUoY29tcG9uZW50cykge1xuXHRcdHJldHVybiBuZXcgUHJvbWlzZShmdWxmaWwgPT4ge1xuXHRcdFx0dGhpcy5oYW5kbGVycy5zZXQodWlkLCBmdWxmaWwpO1xuXG5cdFx0XHR0aGlzLndvcmtlci5wb3N0TWVzc2FnZSh7XG5cdFx0XHRcdHVpZCxcblx0XHRcdFx0dHlwZTogJ2J1bmRsZScsXG5cdFx0XHRcdGNvbXBvbmVudHNcblx0XHRcdH0pO1xuXG5cdFx0XHR1aWQgKz0gMTtcblx0XHR9KTtcblx0fVxuXG5cdGRlc3Ryb3koKSB7XG5cdFx0dGhpcy53b3JrZXIudGVybWluYXRlKCk7XG5cdH1cbn0iLCI8c2NyaXB0PlxuXHRpbXBvcnQgeyBvbk1vdW50LCBzZXRDb250ZXh0LCBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tICdzdmVsdGUnO1xuXHRpbXBvcnQgeyB3cml0YWJsZSB9IGZyb20gJ3N2ZWx0ZS9zdG9yZSc7XG5cdGltcG9ydCBTcGxpdFBhbmUgZnJvbSAnLi9TcGxpdFBhbmUuc3ZlbHRlJztcblx0aW1wb3J0IENvZGVNaXJyb3IgZnJvbSAnLi9Db2RlTWlycm9yLnN2ZWx0ZSc7XG5cdGltcG9ydCBDb21wb25lbnRTZWxlY3RvciBmcm9tICcuL0lucHV0L0NvbXBvbmVudFNlbGVjdG9yLnN2ZWx0ZSc7XG5cdGltcG9ydCBNb2R1bGVFZGl0b3IgZnJvbSAnLi9JbnB1dC9Nb2R1bGVFZGl0b3Iuc3ZlbHRlJztcblx0aW1wb3J0IE91dHB1dCBmcm9tICcuL091dHB1dC9pbmRleC5zdmVsdGUnO1xuXHRpbXBvcnQgQnVuZGxlciBmcm9tICcuL0J1bmRsZXIuanMnO1xuXHRpbXBvcnQgeyBpc19icm93c2VyIH0gZnJvbSAnLi9lbnYuanMnO1xuXG5cdGV4cG9ydCBsZXQgd29ya2Vyc1VybDtcblx0ZXhwb3J0IGxldCBwYWNrYWdlc1VybCA9ICdodHRwczovL3VucGtnLmNvbSc7XG5cdGV4cG9ydCBsZXQgc3ZlbHRlVXJsID0gYCR7cGFja2FnZXNVcmx9L3N2ZWx0ZWA7XG5cdGV4cG9ydCBsZXQgZW1iZWRkZWQgPSBmYWxzZTtcblx0ZXhwb3J0IGxldCBvcmllbnRhdGlvbiA9ICdjb2x1bW5zJztcblx0ZXhwb3J0IGxldCByZWxheGVkID0gZmFsc2U7XG5cdGV4cG9ydCBsZXQgZml4ZWQgPSBmYWxzZTtcblx0ZXhwb3J0IGxldCBmaXhlZFBvcyA9IDUwO1xuXHRleHBvcnQgbGV0IGluamVjdGVkSlMgPSAnJztcblx0ZXhwb3J0IGxldCBpbmplY3RlZENTUyA9ICcnO1xuXG5cdGV4cG9ydCBmdW5jdGlvbiB0b0pTT04oKSB7XG5cdFx0Ly8gVE9ETyB0aGVyZSdzIGEgYnVnIGhlcmUg4oCUIFN2ZWx0ZSBob2lzdHMgdGhpcyBmdW5jdGlvbiBiZWNhdXNlXG5cdFx0Ly8gaXQgd3JvbmdseSB0aGluZ3MgdGhhdCAkY29tcG9uZW50cyBpcyBnbG9iYWwuIE5lZWRzIHRvXG5cdFx0Ly8gZmFjdG9yIGluICQgdmFyaWFibGVzIHdoZW4gZGV0ZXJtaW5pbmcgaG9pc3RhYmlsaXR5XG5cblx0XHRzdmVsdGVVcmw7IC8vIHdvcmthcm91bmRcblxuXHRcdHJldHVybiB7XG5cdFx0XHRpbXBvcnRzOiAkYnVuZGxlLmltcG9ydHMsXG5cdFx0XHRjb21wb25lbnRzOiAkY29tcG9uZW50c1xuXHRcdH07XG5cdH1cblxuXHRleHBvcnQgYXN5bmMgZnVuY3Rpb24gc2V0KGRhdGEpIHtcblx0XHRjb21wb25lbnRzLnNldChkYXRhLmNvbXBvbmVudHMpO1xuXHRcdHNlbGVjdGVkLnNldChkYXRhLmNvbXBvbmVudHNbMF0pO1xuXG5cdFx0cmVidW5kbGUoKTtcblxuXHRcdGF3YWl0IG1vZHVsZV9lZGl0b3JfcmVhZHk7XG5cdFx0YXdhaXQgb3V0cHV0X3JlYWR5O1xuXG5cdFx0aW5qZWN0ZWRDU1MgPSBkYXRhLmNzcyB8fCAnJztcblx0XHRtb2R1bGVfZWRpdG9yLnNldCgkc2VsZWN0ZWQuc291cmNlLCAkc2VsZWN0ZWQudHlwZSk7XG5cdFx0b3V0cHV0LnNldCgkc2VsZWN0ZWQsICRjb21waWxlX29wdGlvbnMpO1xuXHR9XG5cblx0ZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZShkYXRhKSB7XG5cdFx0Y29uc3QgeyBuYW1lLCB0eXBlIH0gPSAkc2VsZWN0ZWQgfHwge307XG5cblx0XHRjb21wb25lbnRzLnNldChkYXRhLmNvbXBvbmVudHMpO1xuXG5cdFx0Y29uc3QgbWF0Y2hlZF9jb21wb25lbnQgPSBkYXRhLmNvbXBvbmVudHMuZmluZChmaWxlID0+IGZpbGUubmFtZSA9PT0gbmFtZSAmJiBmaWxlLnR5cGUgPT09IHR5cGUpO1xuXHRcdHNlbGVjdGVkLnNldChtYXRjaGVkX2NvbXBvbmVudCB8fCBkYXRhLmNvbXBvbmVudHNbMF0pO1xuXG5cdFx0aW5qZWN0ZWRDU1MgPSBkYXRhLmNzcyB8fCAnJztcblxuXHRcdGlmIChtYXRjaGVkX2NvbXBvbmVudCkge1xuXHRcdFx0bW9kdWxlX2VkaXRvci51cGRhdGUobWF0Y2hlZF9jb21wb25lbnQuc291cmNlKTtcblx0XHRcdG91dHB1dC51cGRhdGUobWF0Y2hlZF9jb21wb25lbnQsICRjb21waWxlX29wdGlvbnMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtb2R1bGVfZWRpdG9yLnNldChtYXRjaGVkX2NvbXBvbmVudC5zb3VyY2UsIG1hdGNoZWRfY29tcG9uZW50LnR5cGUpO1xuXHRcdFx0b3V0cHV0LnNldChtYXRjaGVkX2NvbXBvbmVudCwgJGNvbXBpbGVfb3B0aW9ucyk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCF3b3JrZXJzVXJsKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBZb3UgbXVzdCBzdXBwbHkgd29ya2Vyc1VybCBwcm9wIHRvIDxSZXBsPmApO1xuXHR9XG5cblx0Y29uc3QgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKTtcblxuXHRjb25zdCBjb21wb25lbnRzID0gd3JpdGFibGUoW10pO1xuXHRjb25zdCBzZWxlY3RlZCA9IHdyaXRhYmxlKG51bGwpO1xuXHRjb25zdCBidW5kbGUgPSB3cml0YWJsZShudWxsKTtcblxuXHRjb25zdCBjb21waWxlX29wdGlvbnMgPSB3cml0YWJsZSh7XG5cdFx0Z2VuZXJhdGU6ICdkb20nLFxuXHRcdGRldjogZmFsc2UsXG5cdFx0Y3NzOiBmYWxzZSxcblx0XHRoeWRyYXRhYmxlOiBmYWxzZSxcblx0XHRjdXN0b21FbGVtZW50OiBmYWxzZSxcblx0XHRpbW11dGFibGU6IGZhbHNlLFxuXHRcdGxlZ2FjeTogZmFsc2Vcblx0fSk7XG5cblx0bGV0IG1vZHVsZV9lZGl0b3I7XG5cdGxldCBvdXRwdXQ7XG5cblx0bGV0IGN1cnJlbnRfdG9rZW47XG5cdGFzeW5jIGZ1bmN0aW9uIHJlYnVuZGxlKCkge1xuXHRcdGNvbnN0IHRva2VuID0gY3VycmVudF90b2tlbiA9IHt9O1xuXHRcdGNvbnN0IHJlc3VsdCA9IGF3YWl0IGJ1bmRsZXIuYnVuZGxlKCRjb21wb25lbnRzKTtcblx0XHRpZiAocmVzdWx0ICYmIHRva2VuID09PSBjdXJyZW50X3Rva2VuKSBidW5kbGUuc2V0KHJlc3VsdCk7XG5cdH1cblxuXHQvLyBUT0RPIHRoaXMgaXMgYSBob3JyaWJsZSBrbHVkZ2UsIHdyaXR0ZW4gaW4gYSBwYW5pYy4gZml4IGl0XG5cdGxldCBmdWxmaWxfbW9kdWxlX2VkaXRvcl9yZWFkeTtcblx0bGV0IG1vZHVsZV9lZGl0b3JfcmVhZHkgPSBuZXcgUHJvbWlzZShmID0+IGZ1bGZpbF9tb2R1bGVfZWRpdG9yX3JlYWR5ID0gZik7XG5cblx0bGV0IGZ1bGZpbF9vdXRwdXRfcmVhZHk7XG5cdGxldCBvdXRwdXRfcmVhZHkgPSBuZXcgUHJvbWlzZShmID0+IGZ1bGZpbF9vdXRwdXRfcmVhZHkgPSBmKTtcblxuXG5cdHNldENvbnRleHQoJ1JFUEwnLCB7XG5cdFx0Y29tcG9uZW50cyxcblx0XHRzZWxlY3RlZCxcblx0XHRidW5kbGUsXG5cdFx0Y29tcGlsZV9vcHRpb25zLFxuXG5cdFx0cmVidW5kbGUsXG5cblx0XHRuYXZpZ2F0ZTogaXRlbSA9PiB7XG5cdFx0XHRjb25zdCBtYXRjaCA9IC9eKC4rKVxcLihcXHcrKSQvLmV4ZWMoaXRlbS5maWxlbmFtZSk7XG5cdFx0XHRpZiAoIW1hdGNoKSByZXR1cm47IC8vID8/P1xuXG5cdFx0XHRjb25zdCBbLCBuYW1lLCB0eXBlXSA9IG1hdGNoO1xuXHRcdFx0Y29uc3QgY29tcG9uZW50ID0gJGNvbXBvbmVudHMuZmluZChjID0+IGMubmFtZSA9PT0gbmFtZSAmJiBjLnR5cGUgPT09IHR5cGUpO1xuXHRcdFx0aGFuZGxlX3NlbGVjdChjb21wb25lbnQpO1xuXG5cdFx0XHQvLyBUT0RPIHNlbGVjdCB0aGUgbGluZS9jb2x1bW4gaW4gcXVlc3Rpb25cblx0XHR9LFxuXG5cdFx0aGFuZGxlX2NoYW5nZTogZXZlbnQgPT4ge1xuXHRcdFx0c2VsZWN0ZWQudXBkYXRlKGNvbXBvbmVudCA9PiB7XG5cdFx0XHRcdC8vIFRPRE8gdGhpcyBpcyBhIGJpdCBoYWNreSDigJQgd2UncmUgcmVseWluZyBvbiBtdXRhYmlsaXR5XG5cdFx0XHRcdC8vIHNvIHRoYXQgdXBkYXRpbmcgY29tcG9uZW50cyB3b3Jrcy4uLiBtaWdodCBiZSBiZXR0ZXJcblx0XHRcdFx0Ly8gaWYgYSkgY29tcG9uZW50cyBoYWQgdW5pcXVlIElEcywgYikgd2UgdHJhY2tlZCBzZWxlY3RlZFxuXHRcdFx0XHQvLyAqaW5kZXgqIHJhdGhlciB0aGFuIGNvbXBvbmVudCwgYW5kIGMpIGBzZWxlY3RlZGAgd2FzXG5cdFx0XHRcdC8vIGRlcml2ZWQgZnJvbSBgY29tcG9uZW50c2AgYW5kIGBpbmRleGBcblx0XHRcdFx0Y29tcG9uZW50LnNvdXJjZSA9IGV2ZW50LmRldGFpbC52YWx1ZTtcblx0XHRcdFx0cmV0dXJuIGNvbXBvbmVudDtcblx0XHRcdH0pO1xuXG5cdFx0XHRjb21wb25lbnRzLnVwZGF0ZShjID0+IGMpO1xuXG5cdFx0XHQvLyByZWNvbXBpbGUgc2VsZWN0ZWQgY29tcG9uZW50XG5cdFx0XHRvdXRwdXQudXBkYXRlKCRzZWxlY3RlZCwgJGNvbXBpbGVfb3B0aW9ucyk7XG5cblx0XHRcdHJlYnVuZGxlKCk7XG5cblx0XHRcdGRpc3BhdGNoKCdjaGFuZ2UnLCB7XG5cdFx0XHRcdGNvbXBvbmVudHM6ICRjb21wb25lbnRzXG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0cmVnaXN0ZXJfbW9kdWxlX2VkaXRvcihlZGl0b3IpIHtcblx0XHRcdG1vZHVsZV9lZGl0b3IgPSBlZGl0b3I7XG5cdFx0XHRmdWxmaWxfbW9kdWxlX2VkaXRvcl9yZWFkeSgpO1xuXHRcdH0sXG5cblx0XHRyZWdpc3Rlcl9vdXRwdXQoaGFuZGxlcnMpIHtcblx0XHRcdG91dHB1dCA9IGhhbmRsZXJzO1xuXHRcdFx0ZnVsZmlsX291dHB1dF9yZWFkeSgpO1xuXHRcdH0sXG5cblx0XHRyZXF1ZXN0X2ZvY3VzKCkge1xuXHRcdFx0bW9kdWxlX2VkaXRvci5mb2N1cygpO1xuXHRcdH1cblx0fSk7XG5cblx0ZnVuY3Rpb24gaGFuZGxlX3NlbGVjdChjb21wb25lbnQpIHtcblx0XHRzZWxlY3RlZC5zZXQoY29tcG9uZW50KTtcblx0XHRtb2R1bGVfZWRpdG9yLnNldChjb21wb25lbnQuc291cmNlLCBjb21wb25lbnQudHlwZSk7XG5cdFx0b3V0cHV0LnNldCgkc2VsZWN0ZWQsICRjb21waWxlX29wdGlvbnMpO1xuXHR9XG5cblx0bGV0IGlucHV0O1xuXHRsZXQgc291cmNlRXJyb3JMb2M7XG5cdGxldCBydW50aW1lRXJyb3JMb2M7IC8vIFRPRE8gcmVmYWN0b3IgdGhpcyBzdHVmZiDigJQgcnVudGltZUVycm9yTG9jIGlzIHVudXNlZFxuXHRsZXQgc3RhdHVzID0gbnVsbDtcblxuXHRjb25zdCBidW5kbGVyID0gaXNfYnJvd3NlciAmJiBuZXcgQnVuZGxlcih7XG5cdFx0d29ya2Vyc1VybCxcblx0XHRwYWNrYWdlc1VybCxcblx0XHRzdmVsdGVVcmwsXG5cdFx0b25zdGF0dXM6IG1lc3NhZ2UgPT4ge1xuXHRcdFx0c3RhdHVzID0gbWVzc2FnZTtcblx0XHR9XG5cdH0pO1xuXG5cdCQ6IGlmIChvdXRwdXQgJiYgJHNlbGVjdGVkKSB7XG5cdFx0b3V0cHV0LnVwZGF0ZSgkc2VsZWN0ZWQsICRjb21waWxlX29wdGlvbnMpO1xuXHR9XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuXHQuY29udGFpbmVyIHtcblx0XHRwb3NpdGlvbjogcmVsYXRpdmU7XG5cdFx0d2lkdGg6IDEwMCU7XG5cdFx0aGVpZ2h0OiAxMDAlO1xuXHR9XG5cblx0LmNvbnRhaW5lciA6Z2xvYmFsKHNlY3Rpb24pIHtcblx0XHRwb3NpdGlvbjogcmVsYXRpdmU7XG5cdFx0cGFkZGluZzogNDJweCAwIDAgMDtcblx0XHRoZWlnaHQ6IDEwMCU7XG5cdFx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0fVxuXG5cdC5jb250YWluZXIgOmdsb2JhbChzZWN0aW9uKSA+IDpnbG9iYWwoKik6Zmlyc3QtY2hpbGQge1xuXHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHR0b3A6IDA7XG5cdFx0bGVmdDogMDtcblx0XHR3aWR0aDogMTAwJTtcblx0XHRoZWlnaHQ6IDQycHg7XG5cdFx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0fVxuXG5cdC5jb250YWluZXIgOmdsb2JhbChzZWN0aW9uKSA+IDpnbG9iYWwoKik6bGFzdC1jaGlsZCB7XG5cdFx0d2lkdGg6IDEwMCU7XG5cdFx0aGVpZ2h0OiAxMDAlO1xuXHR9XG48L3N0eWxlPlxuXG48ZGl2IGNsYXNzPVwiY29udGFpbmVyXCIgY2xhc3M6b3JpZW50YXRpb24+XG5cdDxTcGxpdFBhbmVcblx0XHR0eXBlPVwie29yaWVudGF0aW9uID09PSAncm93cycgPyAndmVydGljYWwnIDogJ2hvcml6b250YWwnfVwiXG5cdFx0cG9zPVwie2ZpeGVkID8gZml4ZWRQb3MgOiBvcmllbnRhdGlvbiA9PT0gJ3Jvd3MnID8gNTAgOiA2MH1cIlxuXHRcdHtmaXhlZH1cblx0PlxuXHRcdDxzZWN0aW9uIHNsb3Q9YT5cblx0XHRcdDxDb21wb25lbnRTZWxlY3RvciB7aGFuZGxlX3NlbGVjdH0vPlxuXHRcdFx0PE1vZHVsZUVkaXRvciBiaW5kOnRoaXM9e2lucHV0fSBlcnJvckxvYz1cIntzb3VyY2VFcnJvckxvYyB8fCBydW50aW1lRXJyb3JMb2N9XCIvPlxuXHRcdDwvc2VjdGlvbj5cblxuXHRcdDxzZWN0aW9uIHNsb3Q9YiBzdHlsZT0naGVpZ2h0OiAxMDAlOyc+XG5cdFx0XHQ8T3V0cHV0IHtzdmVsdGVVcmx9IHt3b3JrZXJzVXJsfSB7c3RhdHVzfSB7ZW1iZWRkZWR9IHtyZWxheGVkfSB7aW5qZWN0ZWRKU30ge2luamVjdGVkQ1NTfS8+XG5cdFx0PC9zZWN0aW9uPlxuXHQ8L1NwbGl0UGFuZT5cbjwvZGl2PlxuIl0sIm5hbWVzIjpbInlvb3RpbHMuY2xhbXAiLCJ1aWQiLCJ3b3JrZXJzIl0sIm1hcHBpbmdzIjoiOzs7QUE0R0EsU0FBUyxLQUFLLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUU7SUFDMUIsT0FB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LENBQUMsQ0FBQyxDQUFDOzs7R0FHMUIsTUFBTSxDQUFDLE1BQU0sQ0FBQyxTQUFTLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQzs7R0FFM0MsUUFBUSxFQUFFLENBQUM7O0dBRVgsUUFBUSxDQUFDLFFBQVEsRUFBRTtJQUNsQixVQUFVLEVBQUUsV0FBVztJQUN2QixDQUFDLENBQUM7R0FDSDs7RUFFRCxzQkFBc0IsQ0FBQyxNQUFNLEVBQUU7R0FDOUIsYUFBYSxHQUFHLE1BQU0sQ0FBQztHQUN2QiwwQkFBMEIsRUFBRSxDQUFDO0dBQzdCOztFQUVELGVBQWUsQ0FBQyxRQUFRLEVBQUU7MEJBQ3pCLE1BQU0sR0FBRyxTQUFRLENBQUM7R0FDbEIsbUJBQW1CLEVBQUUsQ0FBQztHQUN0Qjs7RUFFRCxhQUFhLEdBQUc7R0FDZixhQUFhLENBQUMsS0FBSyxFQUFFLENBQUM7R0FDdEI7RUFDRCxDQUFDLENBQUM7O0NBRUgsU0FBUyxhQUFhLENBQUMsU0FBUyxFQUFFO0VBQ2pDLFFBQVEsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUM7RUFDeEIsYUFBYSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsTUFBTSxFQUFFLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQztFQUNwRCxNQUFNLENBQUMsR0FBRyxDQUFDLFNBQVMsRUFBRSxnQkFBZ0IsQ0FBQyxDQUFDO0VBQ3hDOztDQUVELElBQUksS0FBSyxDQUFDO0NBQ1YsSUFBSSxjQUFjLENBQUM7Q0FDbkIsSUFBSSxlQUFlLENBQUM7Q0FDcEIsSUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDOztDQUVsQixNQUFNLE9BQU8sR0FBRyxVQUFVLElBQUksSUFBSSxPQUFPLENBQUM7RUFDekMsVUFBVTtFQUNWLFdBQVc7RUFDWCxTQUFTO0VBQ1QsUUFBUSxFQUFFLE9BQU8sSUFBSTswQkFDcEIsTUFBTSxHQUFHLFFBQU8sQ0FBQztHQUNqQjtFQUNELENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUVBRUEsSUFBSSxNQUFNLElBQUksU0FBUyxFQUFFO0lBQzNCLE1BQU0sQ0FBQyxNQUFNLENBQUMsU0FBUyxFQUFFLGdCQUFnQixDQUFDLENBQUM7SUFDM0M7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsifQ==
