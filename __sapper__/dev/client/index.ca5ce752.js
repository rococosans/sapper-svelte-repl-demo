import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, h as element, k as claim_element, l as children, m as detach_dev, o as attr_dev, p as add_location, q as insert_dev, X as destroy_each, f as space, r as text, j as claim_space, u as claim_text, J as toggle_class, P as set_style, N as listen_dev, v as append_dev, A as mount_component, x as set_data_dev, t as transition_in, b as transition_out, D as destroy_component, R as prop_dev, K as add_render_callback, G as getContext, H as binding_callbacks, a0 as bind, a3 as HtmlTag, F as check_outros, e as globals, E as group_outros, a1 as add_flush_callback } from './index.121aa0ed.js';
import './index.ab7b6b80.js';
import { g as goto } from './app.688aaf8d.js';
import { R as Repl } from './Repl.d20fb43b.js';
import { s as svelteUrl, r as rollupUrl, m as mapbox_setup, S as ScreenToggle } from './config.305e0082.js';
import { I as Icon } from './index.0a978f10.js';
import './navigation.84703ebc.js';

/* src\routes\del-tutorial\[slug]\_TableOfContents.svelte generated by Svelte v3.12.0 */

const file = "src\\routes\\del-tutorial\\[slug]\\_TableOfContents.svelte";

function get_each_context_1(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.chapter = list[i];
	child_ctx.i = i;
	return child_ctx;
}

function get_each_context(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.section = list[i];
	child_ctx.i = i;
	return child_ctx;
}

// (83:5) {#each section.chapters as chapter, i}
function create_each_block_1(ctx) {
	var option, t0_value = String.fromCharCode(ctx.i + 97) + "", t0, t1, t2_value = ctx.chapter.title + "", t2, option_value_value;

	const block = {
		c: function create() {
			option = element("option");
			t0 = text(t0_value);
			t1 = text(". ");
			t2 = text(t2_value);
			this.h();
		},

		l: function claim(nodes) {
			option = claim_element(nodes, "OPTION", { value: true }, false);
			var option_nodes = children(option);

			t0 = claim_text(option_nodes, t0_value);
			t1 = claim_text(option_nodes, ". ");
			t2 = claim_text(option_nodes, t2_value);
			option_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			option.__value = option_value_value = ctx.chapter.slug;
			option.value = option.__value;
			add_location(option, file, 83, 6, 1506);
		},

		m: function mount(target, anchor) {
			insert_dev(target, option, anchor);
			append_dev(option, t0);
			append_dev(option, t1);
			append_dev(option, t2);
		},

		p: function update(changed, ctx) {
			if ((changed.sections) && t2_value !== (t2_value = ctx.chapter.title + "")) {
				set_data_dev(t2, t2_value);
			}

			if ((changed.sections) && option_value_value !== (option_value_value = ctx.chapter.slug)) {
				prop_dev(option, "__value", option_value_value);
			}

			option.value = option.__value;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(option);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_each_block_1.name, type: "each", source: "(83:5) {#each section.chapters as chapter, i}", ctx });
	return block;
}

// (81:3) {#each sections as section, i}
function create_each_block(ctx) {
	var optgroup, optgroup_label_value;

	let each_value_1 = ctx.section.chapters;

	let each_blocks = [];

	for (let i_1 = 0; i_1 < each_value_1.length; i_1 += 1) {
		each_blocks[i_1] = create_each_block_1(get_each_context_1(ctx, each_value_1, i_1));
	}

	const block = {
		c: function create() {
			optgroup = element("optgroup");

			for (let i_1 = 0; i_1 < each_blocks.length; i_1 += 1) {
				each_blocks[i_1].c();
			}
			this.h();
		},

		l: function claim(nodes) {
			optgroup = claim_element(nodes, "OPTGROUP", { label: true }, false);
			var optgroup_nodes = children(optgroup);

			for (let i_1 = 0; i_1 < each_blocks.length; i_1 += 1) {
				each_blocks[i_1].l(optgroup_nodes);
			}

			optgroup_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(optgroup, "label", optgroup_label_value = "" + (ctx.i + 1) + ". " + ctx.section.title);
			add_location(optgroup, file, 81, 4, 1412);
		},

		m: function mount(target, anchor) {
			insert_dev(target, optgroup, anchor);

			for (let i_1 = 0; i_1 < each_blocks.length; i_1 += 1) {
				each_blocks[i_1].m(optgroup, null);
			}
		},

		p: function update(changed, ctx) {
			if (changed.sections) {
				each_value_1 = ctx.section.chapters;

				let i_1;
				for (i_1 = 0; i_1 < each_value_1.length; i_1 += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i_1);

					if (each_blocks[i_1]) {
						each_blocks[i_1].p(changed, child_ctx);
					} else {
						each_blocks[i_1] = create_each_block_1(child_ctx);
						each_blocks[i_1].c();
						each_blocks[i_1].m(optgroup, null);
					}
				}

				for (; i_1 < each_blocks.length; i_1 += 1) {
					each_blocks[i_1].d(1);
				}
				each_blocks.length = each_value_1.length;
			}

			if ((changed.sections) && optgroup_label_value !== (optgroup_label_value = "" + (ctx.i + 1) + ". " + ctx.section.title)) {
				attr_dev(optgroup, "label", optgroup_label_value);
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(optgroup);
			}

			destroy_each(each_blocks, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_each_block.name, type: "each", source: "(81:3) {#each sections as section, i}", ctx });
	return block;
}

function create_fragment(ctx) {
	var nav, a0, a0_href_value, t0, div, span1, strong, span0, t1, t2_value = ctx.selected.section.title + "", t2, t3, t4, t5_value = ctx.selected.chapter.title + "", t5, t6, select, select_value_value, t7, a1, a1_href_value, current, dispose;

	var icon0 = new Icon({
		props: { name: "arrow-left" },
		$$inline: true
	});

	var icon1 = new Icon({ props: { name: "menu" }, $$inline: true });

	let each_value = ctx.sections;

	let each_blocks = [];

	for (let i_1 = 0; i_1 < each_value.length; i_1 += 1) {
		each_blocks[i_1] = create_each_block(get_each_context(ctx, each_value, i_1));
	}

	var icon2 = new Icon({
		props: { name: "arrow-right" },
		$$inline: true
	});

	const block = {
		c: function create() {
			nav = element("nav");
			a0 = element("a");
			icon0.$$.fragment.c();
			t0 = space();
			div = element("div");
			span1 = element("span");
			strong = element("strong");
			span0 = element("span");
			icon1.$$.fragment.c();
			t1 = space();
			t2 = text(t2_value);
			t3 = text(" /");
			t4 = space();
			t5 = text(t5_value);
			t6 = space();
			select = element("select");

			for (let i_1 = 0; i_1 < each_blocks.length; i_1 += 1) {
				each_blocks[i_1].c();
			}

			t7 = space();
			a1 = element("a");
			icon2.$$.fragment.c();
			this.h();
		},

		l: function claim(nodes) {
			nav = claim_element(nodes, "NAV", { class: true }, false);
			var nav_nodes = children(nav);

			a0 = claim_element(nav_nodes, "A", { rel: true, class: true, href: true }, false);
			var a0_nodes = children(a0);

			icon0.$$.fragment.l(a0_nodes);
			a0_nodes.forEach(detach_dev);
			t0 = claim_space(nav_nodes);

			div = claim_element(nav_nodes, "DIV", { class: true }, false);
			var div_nodes = children(div);

			span1 = claim_element(div_nodes, "SPAN", { class: true }, false);
			var span1_nodes = children(span1);

			strong = claim_element(span1_nodes, "STRONG", { class: true }, false);
			var strong_nodes = children(strong);

			span0 = claim_element(strong_nodes, "SPAN", { style: true, class: true }, false);
			var span0_nodes = children(span0);

			icon1.$$.fragment.l(span0_nodes);
			span0_nodes.forEach(detach_dev);
			t1 = claim_space(strong_nodes);
			t2 = claim_text(strong_nodes, t2_value);
			t3 = claim_text(strong_nodes, " /");
			strong_nodes.forEach(detach_dev);
			t4 = claim_space(span1_nodes);
			t5 = claim_text(span1_nodes, t5_value);
			span1_nodes.forEach(detach_dev);
			t6 = claim_space(div_nodes);

			select = claim_element(div_nodes, "SELECT", { value: true, class: true }, false);
			var select_nodes = children(select);

			for (let i_1 = 0; i_1 < each_blocks.length; i_1 += 1) {
				each_blocks[i_1].l(select_nodes);
			}

			select_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			t7 = claim_space(nav_nodes);

			a1 = claim_element(nav_nodes, "A", { rel: true, class: true, href: true }, false);
			var a1_nodes = children(a1);

			icon2.$$.fragment.l(a1_nodes);
			a1_nodes.forEach(detach_dev);
			nav_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(a0, "rel", "prefetch");
			attr_dev(a0, "class", "no-underline svelte-faku86");
			attr_dev(a0, "href", a0_href_value = "tutorial/" + (ctx.selected.prev || ctx.selected).slug);
			toggle_class(a0, "disabled", !ctx.selected.prev);
			add_location(a0, file, 66, 1, 961);
			set_style(span0, "position", "relative");
			set_style(span0, "top", "-0.1em");
			set_style(span0, "margin", "0 0.5em 0 0");
			attr_dev(span0, "class", "svelte-faku86");
			add_location(span0, file, 73, 4, 1152);
			attr_dev(strong, "class", "svelte-faku86");
			add_location(strong, file, 72, 3, 1139);
			attr_dev(span1, "class", "svelte-faku86");
			add_location(span1, file, 71, 2, 1129);
			attr_dev(select, "class", "svelte-faku86");
			add_location(select, file, 79, 2, 1331);
			attr_dev(div, "class", "svelte-faku86");
			add_location(div, file, 70, 1, 1121);
			attr_dev(a1, "rel", "prefetch");
			attr_dev(a1, "class", "no-underline svelte-faku86");
			attr_dev(a1, "href", a1_href_value = "tutorial/" + (ctx.selected.next || ctx.selected).slug);
			toggle_class(a1, "disabled", !ctx.selected.next);
			add_location(a1, file, 90, 1, 1653);
			attr_dev(nav, "class", "svelte-faku86");
			add_location(nav, file, 65, 0, 954);
			dispose = listen_dev(select, "change", navigate);
		},

		m: function mount(target, anchor) {
			insert_dev(target, nav, anchor);
			append_dev(nav, a0);
			mount_component(icon0, a0, null);
			append_dev(nav, t0);
			append_dev(nav, div);
			append_dev(div, span1);
			append_dev(span1, strong);
			append_dev(strong, span0);
			mount_component(icon1, span0, null);
			append_dev(strong, t1);
			append_dev(strong, t2);
			append_dev(strong, t3);
			append_dev(span1, t4);
			append_dev(span1, t5);
			append_dev(div, t6);
			append_dev(div, select);

			for (let i_1 = 0; i_1 < each_blocks.length; i_1 += 1) {
				each_blocks[i_1].m(select, null);
			}

			select_value_value = ctx.slug;
			for (var i = 0; i < select.options.length; i += 1) {
				var option = select.options[i];

				if (option.__value === select_value_value) {
					option.selected = true;
					break;
				}
			}

			append_dev(nav, t7);
			append_dev(nav, a1);
			mount_component(icon2, a1, null);
			current = true;
		},

		p: function update(changed, ctx) {
			if ((!current || changed.selected) && a0_href_value !== (a0_href_value = "tutorial/" + (ctx.selected.prev || ctx.selected).slug)) {
				attr_dev(a0, "href", a0_href_value);
			}

			if (changed.selected) {
				toggle_class(a0, "disabled", !ctx.selected.prev);
			}

			if ((!current || changed.selected) && t2_value !== (t2_value = ctx.selected.section.title + "")) {
				set_data_dev(t2, t2_value);
			}

			if ((!current || changed.selected) && t5_value !== (t5_value = ctx.selected.chapter.title + "")) {
				set_data_dev(t5, t5_value);
			}

			if (changed.sections) {
				each_value = ctx.sections;

				let i_1;
				for (i_1 = 0; i_1 < each_value.length; i_1 += 1) {
					const child_ctx = get_each_context(ctx, each_value, i_1);

					if (each_blocks[i_1]) {
						each_blocks[i_1].p(changed, child_ctx);
					} else {
						each_blocks[i_1] = create_each_block(child_ctx);
						each_blocks[i_1].c();
						each_blocks[i_1].m(select, null);
					}
				}

				for (; i_1 < each_blocks.length; i_1 += 1) {
					each_blocks[i_1].d(1);
				}
				each_blocks.length = each_value.length;
			}

			if ((!current || changed.slug) && select_value_value !== (select_value_value = ctx.slug)) {
				for (var i = 0; i < select.options.length; i += 1) {
					var option = select.options[i];

					if (option.__value === select_value_value) {
						option.selected = true;
						break;
					}
				}
			}

			if ((!current || changed.selected) && a1_href_value !== (a1_href_value = "tutorial/" + (ctx.selected.next || ctx.selected).slug)) {
				attr_dev(a1, "href", a1_href_value);
			}

			if (changed.selected) {
				toggle_class(a1, "disabled", !ctx.selected.next);
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(icon0.$$.fragment, local);

			transition_in(icon1.$$.fragment, local);

			transition_in(icon2.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(icon0.$$.fragment, local);
			transition_out(icon1.$$.fragment, local);
			transition_out(icon2.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(nav);
			}

			destroy_component(icon0);

			destroy_component(icon1);

			destroy_each(each_blocks, detaching);

			destroy_component(icon2);

			dispose();
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment.name, type: "component", source: "", ctx });
	return block;
}

function navigate(e) {
	goto(`tutorial/${e.target.value}`);
}

function instance($$self, $$props, $$invalidate) {
	

	let { sections, slug, selected } = $$props;

	const writable_props = ['sections', 'slug', 'selected'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<TableOfContents> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ('sections' in $$props) $$invalidate('sections', sections = $$props.sections);
		if ('slug' in $$props) $$invalidate('slug', slug = $$props.slug);
		if ('selected' in $$props) $$invalidate('selected', selected = $$props.selected);
	};

	$$self.$capture_state = () => {
		return { sections, slug, selected };
	};

	$$self.$inject_state = $$props => {
		if ('sections' in $$props) $$invalidate('sections', sections = $$props.sections);
		if ('slug' in $$props) $$invalidate('slug', slug = $$props.slug);
		if ('selected' in $$props) $$invalidate('selected', selected = $$props.selected);
	};

	return { sections, slug, selected };
}

class TableOfContents extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, ["sections", "slug", "selected"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "TableOfContents", options, id: create_fragment.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.sections === undefined && !('sections' in props)) {
			console.warn("<TableOfContents> was created without expected prop 'sections'");
		}
		if (ctx.slug === undefined && !('slug' in props)) {
			console.warn("<TableOfContents> was created without expected prop 'slug'");
		}
		if (ctx.selected === undefined && !('selected' in props)) {
			console.warn("<TableOfContents> was created without expected prop 'selected'");
		}
	}

	get sections() {
		throw new Error("<TableOfContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sections(value) {
		throw new Error("<TableOfContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get slug() {
		throw new Error("<TableOfContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set slug(value) {
		throw new Error("<TableOfContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get selected() {
		throw new Error("<TableOfContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set selected(value) {
		throw new Error("<TableOfContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\routes\del-tutorial\[slug]\index.svelte generated by Svelte v3.12.0 */
const { window: window_1 } = globals;

const file$1 = "src\\routes\\del-tutorial\\[slug]\\index.svelte";

// (282:5) {#if chapter.app_b}
function create_if_block_2(ctx) {
	var button, t_value = ctx.completed ? 'Reset' : 'Show me' + "", t, dispose;

	const block = {
		c: function create() {
			button = element("button");
			t = text(t_value);
			this.h();
		},

		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", { class: true }, false);
			var button_nodes = children(button);

			t = claim_text(button_nodes, t_value);
			button_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(button, "class", "show svelte-bj9kxg");
			add_location(button, file$1, 284, 6, 6053);
			dispose = listen_dev(button, "click", ctx.click_handler);
		},

		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t);
		},

		p: function update(changed, ctx) {
			if ((changed.completed) && t_value !== (t_value = ctx.completed ? 'Reset' : 'Show me' + "")) {
				set_data_dev(t, t_value);
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(button);
			}

			dispose();
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_2.name, type: "if", source: "(282:5) {#if chapter.app_b}", ctx });
	return block;
}

// (290:5) {#if selected.next}
function create_if_block_1(ctx) {
	var a, t, a_href_value;

	const block = {
		c: function create() {
			a = element("a");
			t = text("Next");
			this.h();
		},

		l: function claim(nodes) {
			a = claim_element(nodes, "A", { class: true, href: true }, false);
			var a_nodes = children(a);

			t = claim_text(a_nodes, "Next");
			a_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(a, "class", "next svelte-bj9kxg");
			attr_dev(a, "href", a_href_value = "tutorial/" + ctx.selected.next.slug);
			add_location(a, file$1, 290, 6, 6227);
		},

		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);
			append_dev(a, t);
		},

		p: function update(changed, ctx) {
			if ((changed.selected) && a_href_value !== (a_href_value = "tutorial/" + ctx.selected.next.slug)) {
				attr_dev(a, "href", a_href_value);
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(a);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_1.name, type: "if", source: "(290:5) {#if selected.next}", ctx });
	return block;
}

// (316:1) {#if mobile}
function create_if_block(ctx) {
	var updating_offset, current;

	function screentoggle_offset_binding(value) {
		ctx.screentoggle_offset_binding.call(null, value);
		updating_offset = true;
		add_flush_callback(() => updating_offset = false);
	}

	let screentoggle_props = { labels: ['tutorial', 'input', 'output'] };
	if (ctx.offset !== void 0) {
		screentoggle_props.offset = ctx.offset;
	}
	var screentoggle = new ScreenToggle({
		props: screentoggle_props,
		$$inline: true
	});

	binding_callbacks.push(() => bind(screentoggle, 'offset', screentoggle_offset_binding));

	const block = {
		c: function create() {
			screentoggle.$$.fragment.c();
		},

		l: function claim(nodes) {
			screentoggle.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(screentoggle, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var screentoggle_changes = {};
			if (!updating_offset && changed.offset) {
				screentoggle_changes.offset = ctx.offset;
			}
			screentoggle.$set(screentoggle_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(screentoggle.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(screentoggle.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(screentoggle, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block.name, type: "if", source: "(316:1) {#if mobile}", ctx });
	return block;
}

function create_fragment$1(ctx) {
	var title_value, meta0, meta1, meta1_content_value, meta2, meta2_content_value, t0, div7, div6, div4, div0, t1, div3, html_tag, raw_value = ctx.chapter.html + "", t2, div1, t3, t4, div2, a, t5, t6, div5, div6_class_value, t7, current, dispose;

	add_render_callback(ctx.onwindowresize);

	document.title = title_value = "" + ctx.selected.section.title + " / " + ctx.selected.chapter.title + " • Svelte Tutorial";

	var tableofcontents = new TableOfContents({
		props: {
		sections: ctx.sections,
		slug: ctx.slug,
		selected: ctx.selected
	},
		$$inline: true
	});

	var if_block0 = (ctx.chapter.app_b) && create_if_block_2(ctx);

	var if_block1 = (ctx.selected.next) && create_if_block_1(ctx);

	let repl_1_props = {
		workersUrl: "workers",
		svelteUrl: svelteUrl,
		rollupUrl: rollupUrl,
		orientation: ctx.mobile ? 'columns' : 'rows',
		fixed: ctx.mobile,
		injectedJS: mapbox_setup,
		relaxed: true
	};
	var repl_1 = new Repl({ props: repl_1_props, $$inline: true });

	ctx.repl_1_binding(repl_1);
	repl_1.$on("change", ctx.handle_change);

	var if_block2 = (ctx.mobile) && create_if_block(ctx);

	const block = {
		c: function create() {
			meta0 = element("meta");
			meta1 = element("meta");
			meta2 = element("meta");
			t0 = space();
			div7 = element("div");
			div6 = element("div");
			div4 = element("div");
			div0 = element("div");
			tableofcontents.$$.fragment.c();
			t1 = space();
			div3 = element("div");
			t2 = space();
			div1 = element("div");
			if (if_block0) if_block0.c();
			t3 = space();
			if (if_block1) if_block1.c();
			t4 = space();
			div2 = element("div");
			a = element("a");
			t5 = text("Edit this chapter");
			t6 = space();
			div5 = element("div");
			repl_1.$$.fragment.c();
			t7 = space();
			if (if_block2) if_block2.c();
			this.h();
		},

		l: function claim(nodes) {
			meta0 = claim_element(nodes, "META", { name: true, content: true }, false);
			var meta0_nodes = children(meta0);

			meta0_nodes.forEach(detach_dev);

			meta1 = claim_element(nodes, "META", { name: true, content: true }, false);
			var meta1_nodes = children(meta1);

			meta1_nodes.forEach(detach_dev);

			meta2 = claim_element(nodes, "META", { name: true, content: true }, false);
			var meta2_nodes = children(meta2);

			meta2_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);

			div7 = claim_element(nodes, "DIV", { class: true }, false);
			var div7_nodes = children(div7);

			div6 = claim_element(div7_nodes, "DIV", { class: true }, false);
			var div6_nodes = children(div6);

			div4 = claim_element(div6_nodes, "DIV", { class: true }, false);
			var div4_nodes = children(div4);

			div0 = claim_element(div4_nodes, "DIV", { class: true }, false);
			var div0_nodes = children(div0);

			tableofcontents.$$.fragment.l(div0_nodes);
			div0_nodes.forEach(detach_dev);
			t1 = claim_space(div4_nodes);

			div3 = claim_element(div4_nodes, "DIV", { class: true }, false);
			var div3_nodes = children(div3);

			t2 = claim_space(div3_nodes);

			div1 = claim_element(div3_nodes, "DIV", { class: true }, false);
			var div1_nodes = children(div1);

			if (if_block0) if_block0.l(div1_nodes);
			t3 = claim_space(div1_nodes);
			if (if_block1) if_block1.l(div1_nodes);
			div1_nodes.forEach(detach_dev);
			t4 = claim_space(div3_nodes);

			div2 = claim_element(div3_nodes, "DIV", { class: true }, false);
			var div2_nodes = children(div2);

			a = claim_element(div2_nodes, "A", { class: true, href: true }, false);
			var a_nodes = children(a);

			t5 = claim_text(a_nodes, "Edit this chapter");
			a_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			div3_nodes.forEach(detach_dev);
			div4_nodes.forEach(detach_dev);
			t6 = claim_space(div6_nodes);

			div5 = claim_element(div6_nodes, "DIV", { class: true }, false);
			var div5_nodes = children(div5);

			repl_1.$$.fragment.l(div5_nodes);
			div5_nodes.forEach(detach_dev);
			div6_nodes.forEach(detach_dev);
			t7 = claim_space(div7_nodes);
			if (if_block2) if_block2.l(div7_nodes);
			div7_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(meta0, "name", "twitter:title");
			attr_dev(meta0, "content", "Svelte tutorial");
			add_location(meta0, file$1, 263, 1, 5310);
			attr_dev(meta1, "name", "twitter:description");
			attr_dev(meta1, "content", meta1_content_value = "" + ctx.selected.section.title + " / " + ctx.selected.chapter.title);
			add_location(meta1, file$1, 264, 1, 5365);
			attr_dev(meta2, "name", "Description");
			attr_dev(meta2, "content", meta2_content_value = "" + ctx.selected.section.title + " / " + ctx.selected.chapter.title);
			add_location(meta2, file$1, 265, 1, 5462);
			attr_dev(div0, "class", "table-of-contents");
			add_location(div0, file$1, 273, 3, 5710);
			html_tag = new HtmlTag(raw_value, t2);
			attr_dev(div1, "class", "controls svelte-bj9kxg");
			add_location(div1, file$1, 280, 4, 5890);
			attr_dev(a, "class", "no-underline svelte-bj9kxg");
			attr_dev(a, "href", ctx.improve_link);
			add_location(a, file$1, 295, 5, 6351);
			attr_dev(div2, "class", "improve-chapter svelte-bj9kxg");
			add_location(div2, file$1, 294, 4, 6316);
			attr_dev(div3, "class", "chapter-markup svelte-bj9kxg");
			add_location(div3, file$1, 277, 3, 5808);
			attr_dev(div4, "class", "tutorial-text svelte-bj9kxg");
			add_location(div4, file$1, 272, 2, 5679);
			attr_dev(div5, "class", "tutorial-repl");
			add_location(div5, file$1, 300, 2, 6450);
			attr_dev(div6, "class", div6_class_value = "viewport offset-" + ctx.offset + " svelte-bj9kxg");
			add_location(div6, file$1, 271, 1, 5638);
			attr_dev(div7, "class", "tutorial-outer svelte-bj9kxg");
			add_location(div7, file$1, 270, 0, 5608);
			dispose = listen_dev(window_1, "resize", ctx.onwindowresize);
		},

		m: function mount(target, anchor) {
			append_dev(document.head, meta0);
			append_dev(document.head, meta1);
			append_dev(document.head, meta2);
			insert_dev(target, t0, anchor);
			insert_dev(target, div7, anchor);
			append_dev(div7, div6);
			append_dev(div6, div4);
			append_dev(div4, div0);
			mount_component(tableofcontents, div0, null);
			append_dev(div4, t1);
			append_dev(div4, div3);
			html_tag.m(div3);
			append_dev(div3, t2);
			append_dev(div3, div1);
			if (if_block0) if_block0.m(div1, null);
			append_dev(div1, t3);
			if (if_block1) if_block1.m(div1, null);
			append_dev(div3, t4);
			append_dev(div3, div2);
			append_dev(div2, a);
			append_dev(a, t5);
			ctx.div3_binding(div3);
			append_dev(div6, t6);
			append_dev(div6, div5);
			mount_component(repl_1, div5, null);
			append_dev(div7, t7);
			if (if_block2) if_block2.m(div7, null);
			current = true;
		},

		p: function update(changed, ctx) {
			if ((!current || changed.selected) && title_value !== (title_value = "" + ctx.selected.section.title + " / " + ctx.selected.chapter.title + " • Svelte Tutorial")) {
				document.title = title_value;
			}

			if ((!current || changed.selected) && meta1_content_value !== (meta1_content_value = "" + ctx.selected.section.title + " / " + ctx.selected.chapter.title)) {
				attr_dev(meta1, "content", meta1_content_value);
			}

			if ((!current || changed.selected) && meta2_content_value !== (meta2_content_value = "" + ctx.selected.section.title + " / " + ctx.selected.chapter.title)) {
				attr_dev(meta2, "content", meta2_content_value);
			}

			var tableofcontents_changes = {};
			if (changed.slug) tableofcontents_changes.slug = ctx.slug;
			if (changed.selected) tableofcontents_changes.selected = ctx.selected;
			tableofcontents.$set(tableofcontents_changes);

			if ((!current || changed.chapter) && raw_value !== (raw_value = ctx.chapter.html + "")) {
				html_tag.p(raw_value);
			}

			if (ctx.chapter.app_b) {
				if (if_block0) {
					if_block0.p(changed, ctx);
				} else {
					if_block0 = create_if_block_2(ctx);
					if_block0.c();
					if_block0.m(div1, t3);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (ctx.selected.next) {
				if (if_block1) {
					if_block1.p(changed, ctx);
				} else {
					if_block1 = create_if_block_1(ctx);
					if_block1.c();
					if_block1.m(div1, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (!current || changed.improve_link) {
				attr_dev(a, "href", ctx.improve_link);
			}

			var repl_1_changes = {};
			if (changed.mobile) repl_1_changes.orientation = ctx.mobile ? 'columns' : 'rows';
			if (changed.mobile) repl_1_changes.fixed = ctx.mobile;
			repl_1.$set(repl_1_changes);

			if ((!current || changed.offset) && div6_class_value !== (div6_class_value = "viewport offset-" + ctx.offset + " svelte-bj9kxg")) {
				attr_dev(div6, "class", div6_class_value);
			}

			if (ctx.mobile) {
				if (if_block2) {
					if_block2.p(changed, ctx);
					transition_in(if_block2, 1);
				} else {
					if_block2 = create_if_block(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div7, null);
				}
			} else if (if_block2) {
				group_outros();
				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});
				check_outros();
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(tableofcontents.$$.fragment, local);

			transition_in(repl_1.$$.fragment, local);

			transition_in(if_block2);
			current = true;
		},

		o: function outro(local) {
			transition_out(tableofcontents.$$.fragment, local);
			transition_out(repl_1.$$.fragment, local);
			transition_out(if_block2);
			current = false;
		},

		d: function destroy(detaching) {
			detach_dev(meta0);
			detach_dev(meta1);
			detach_dev(meta2);

			if (detaching) {
				detach_dev(t0);
				detach_dev(div7);
			}

			destroy_component(tableofcontents);

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			ctx.div3_binding(null);
			ctx.repl_1_binding(null);

			destroy_component(repl_1);

			if (if_block2) if_block2.d();
			dispose();
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$1.name, type: "component", source: "", ctx });
	return block;
}

async function preload({ params }) {
	const res = await this.fetch(`tutorial/${params.slug}.json`);

	if (!res.ok) {
		return this.redirect(301, `tutorial/basics`);
	}

	return {
		slug: params.slug,
		chapter: await res.json()
	};
}

const tutorial_repo_link = 'https://github.com/sveltejs/svelte/tree/master/site/content/tutorial';

function instance$1($$self, $$props, $$invalidate) {
	

	let { slug, chapter } = $$props;

	const { sections } = getContext('tutorial');

	let repl;
	let prev;
	let scrollable;
	const lookup = new Map();

	let width =  window.innerWidth ;
	let offset = 0;

	sections.forEach(section => {
		section.chapters.forEach(chapter => {
			const obj = {
				slug: chapter.slug,
				section,
				chapter,
				prev
			};

			lookup.set(chapter.slug, obj);

			{ // pending https://github.com/sveltejs/svelte/issues/2135
				if (prev) prev.next = obj;
				prev = obj;
			}
		});
	});

	const clone = file => ({
		name: file.name,
		type: file.type,
		source: file.source
	});

	function reset() {
		repl.update({
			components: chapter.app_a.map(clone)
		});
	}

	function complete() {
		repl.update({
			components: chapter.app_b.map(clone)
		});
	}

	let completed = false;

	function handle_change(event) {
		$$invalidate('completed', completed = event.detail.components.every((file, i) => {
			const expected = chapter.app_b[i];
			return expected && (
				file.name === expected.name &&
				file.type === expected.type &&
				file.source.trim().replace(/\s+$/gm, '') === expected.source.trim().replace(/\s+$/gm, '')
			);
		}));
	}

	const writable_props = ['slug', 'chapter'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Index> was created with unknown prop '${key}'`);
	});

	function onwindowresize() {
		width = window_1.innerWidth; $$invalidate('width', width);
	}

	const click_handler = () => completed ? reset() : complete();

	function div3_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			$$invalidate('scrollable', scrollable = $$value);
		});
	}

	function repl_1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			$$invalidate('repl', repl = $$value);
		});
	}

	function screentoggle_offset_binding(value) {
		offset = value;
		$$invalidate('offset', offset);
	}

	$$self.$set = $$props => {
		if ('slug' in $$props) $$invalidate('slug', slug = $$props.slug);
		if ('chapter' in $$props) $$invalidate('chapter', chapter = $$props.chapter);
	};

	$$self.$capture_state = () => {
		return { slug, chapter, repl, prev, scrollable, width, offset, completed, selected, improve_link, mobile };
	};

	$$self.$inject_state = $$props => {
		if ('slug' in $$props) $$invalidate('slug', slug = $$props.slug);
		if ('chapter' in $$props) $$invalidate('chapter', chapter = $$props.chapter);
		if ('repl' in $$props) $$invalidate('repl', repl = $$props.repl);
		if ('prev' in $$props) prev = $$props.prev;
		if ('scrollable' in $$props) $$invalidate('scrollable', scrollable = $$props.scrollable);
		if ('width' in $$props) $$invalidate('width', width = $$props.width);
		if ('offset' in $$props) $$invalidate('offset', offset = $$props.offset);
		if ('completed' in $$props) $$invalidate('completed', completed = $$props.completed);
		if ('selected' in $$props) $$invalidate('selected', selected = $$props.selected);
		if ('improve_link' in $$props) $$invalidate('improve_link', improve_link = $$props.improve_link);
		if ('mobile' in $$props) $$invalidate('mobile', mobile = $$props.mobile);
	};

	let selected, improve_link, mobile;

	$$self.$$.update = ($$dirty = { scrollable: 1, chapter: 1, slug: 1, selected: 1, repl: 1, width: 1 }) => {
		if ($$dirty.scrollable || $$dirty.chapter) { if (scrollable) scrollable.scrollTo(0, 0); }
		if ($$dirty.slug) { $$invalidate('selected', selected = lookup.get(slug)); }
		if ($$dirty.selected) { $$invalidate('improve_link', improve_link = `${tutorial_repo_link}/${selected.chapter.section_dir}/${selected.chapter.chapter_dir}`); }
		if ($$dirty.repl || $$dirty.chapter) { if (repl) {
				$$invalidate('completed', completed = false);
				repl.set({
					components: chapter.app_a.map(clone)
				});
			} }
		if ($$dirty.width) { $$invalidate('mobile', mobile = width < 768); }
	};

	return {
		slug,
		chapter,
		sections,
		repl,
		scrollable,
		width,
		offset,
		reset,
		complete,
		completed,
		handle_change,
		selected,
		improve_link,
		mobile,
		onwindowresize,
		click_handler,
		div3_binding,
		repl_1_binding,
		screentoggle_offset_binding
	};
}

class Index extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, ["slug", "chapter"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "Index", options, id: create_fragment$1.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.slug === undefined && !('slug' in props)) {
			console.warn("<Index> was created without expected prop 'slug'");
		}
		if (ctx.chapter === undefined && !('chapter' in props)) {
			console.warn("<Index> was created without expected prop 'chapter'");
		}
	}

	get slug() {
		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set slug(value) {
		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get chapter() {
		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set chapter(value) {
		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default Index;
export { preload };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguY2E1Y2U3NTIuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9yb3V0ZXMvZGVsLXR1dG9yaWFsL1tzbHVnXS9fVGFibGVPZkNvbnRlbnRzLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvZGVsLXR1dG9yaWFsL1tzbHVnXS9pbmRleC5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdD5cblx0aW1wb3J0IHsgZ290byB9IGZyb20gJ0BzYXBwZXIvYXBwJztcblx0aW1wb3J0IHsgSWNvbiB9IGZyb20gJ0BzdmVsdGVqcy9zaXRlLWtpdCc7XG5cblx0ZXhwb3J0IGxldCBzZWN0aW9ucztcblx0ZXhwb3J0IGxldCBzbHVnO1xuXHRleHBvcnQgbGV0IHNlbGVjdGVkO1xuXG5cdGZ1bmN0aW9uIG5hdmlnYXRlKGUpIHtcblx0XHRnb3RvKGB0dXRvcmlhbC8ke2UudGFyZ2V0LnZhbHVlfWApO1xuXHR9XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuXHRuYXYge1xuXHRcdGRpc3BsYXk6IGdyaWQ7XG5cdFx0Z3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiAyLjVlbSAxZnIgMi41ZW07XG5cdFx0Ym9yZGVyLWJvdHRvbTogMXB4IHNvbGlkIHJnYmEoMjU1LDI1NSwyNTUsMC4xKTtcblx0fVxuXG5cdGRpdiB7XG5cdFx0cG9zaXRpb246IHJlbGF0aXZlO1xuXHRcdHBhZGRpbmc6IDFlbSAwLjVlbTtcblx0XHRmb250LXdlaWdodDogMzAwO1xuXHRcdGZvbnQtc2l6ZTogdmFyKC0taDYpO1xuXHRcdGNvbG9yOiB3aGl0ZTtcblx0fVxuXG5cdGEge1xuXHRcdGRpc3BsYXk6IGJsb2NrO1xuXHRcdHBhZGRpbmc6IDAuN2VtIDA7XG5cdFx0dGV4dC1hbGlnbjogY2VudGVyO1xuXHRcdG9wYWNpdHk6IDAuNzU7XG5cdFx0Y29sb3I6IHdoaXRlO1xuXHR9XG5cblx0YTpob3ZlciB7XG5cdFx0b3BhY2l0eTogMTtcblx0fVxuXG5cdGEuZGlzYWJsZWQsIGEuZGlzYWJsZWQ6aG92ZXIsIGEuZGlzYWJsZWQ6YWN0aXZlIHtcblx0XHRjb2xvcjogd2hpdGU7XG5cdFx0b3BhY2l0eTogMC4zO1xuXHR9XG5cblx0c3BhbiB7XG5cdFx0d2hpdGUtc3BhY2U6IG5vd3JhcDtcblx0XHRwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgXHR0b3A6IDAuM2VtO1xuXHR9XG5cblx0c3Ryb25nIHsgb3BhY2l0eTogMC43IH1cblxuXHRzZWxlY3Qge1xuXHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHRsZWZ0OiAwO1xuXHRcdHRvcDogMDtcblx0XHR3aWR0aDogMTAwJTtcblx0XHRoZWlnaHQ6IDEwMCU7XG5cdFx0b3BhY2l0eTogMC4wMDAxO1xuXHRcdGN1cnNvcjogcG9pbnRlcjtcblx0XHQtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XG5cdH1cbjwvc3R5bGU+XG5cbjxuYXY+XG5cdDxhIHJlbD1cInByZWZldGNoXCIgY2xhc3M9XCJuby11bmRlcmxpbmVcIiBocmVmPVwidHV0b3JpYWwveyhzZWxlY3RlZC5wcmV2IHx8IHNlbGVjdGVkKS5zbHVnfVwiIGNsYXNzOmRpc2FibGVkPXshc2VsZWN0ZWQucHJldn0+XG5cdFx0PEljb24gbmFtZT1cImFycm93LWxlZnRcIiAvPlxuXHQ8L2E+XG5cblx0PGRpdj5cblx0XHQ8c3Bhbj5cblx0XHRcdDxzdHJvbmc+XG5cdFx0XHRcdDxzcGFuIHN0eWxlPVwicG9zaXRpb246IHJlbGF0aXZlOyB0b3A6IC0wLjFlbTsgbWFyZ2luOiAwIDAuNWVtIDAgMFwiPjxJY29uIG5hbWU9XCJtZW51XCIvPjwvc3Bhbj5cblx0XHRcdFx0e3NlbGVjdGVkLnNlY3Rpb24udGl0bGV9IC9cblx0XHRcdDwvc3Ryb25nPlxuXHRcdFx0e3NlbGVjdGVkLmNoYXB0ZXIudGl0bGV9XG5cdFx0PC9zcGFuPlxuXG5cdFx0PHNlbGVjdCB2YWx1ZT17c2x1Z30gb246Y2hhbmdlPXtuYXZpZ2F0ZX0+XG5cdFx0XHR7I2VhY2ggc2VjdGlvbnMgYXMgc2VjdGlvbiwgaX1cblx0XHRcdFx0PG9wdGdyb3VwIGxhYmVsPVwie2kgKyAxfS4ge3NlY3Rpb24udGl0bGV9XCI+XG5cdFx0XHRcdFx0eyNlYWNoIHNlY3Rpb24uY2hhcHRlcnMgYXMgY2hhcHRlciwgaX1cblx0XHRcdFx0XHRcdDxvcHRpb24gdmFsdWU9e2NoYXB0ZXIuc2x1Z30+e1N0cmluZy5mcm9tQ2hhckNvZGUoaSArIDk3KX0uIHtjaGFwdGVyLnRpdGxlfTwvb3B0aW9uPlxuXHRcdFx0XHRcdHsvZWFjaH1cblx0XHRcdFx0PC9vcHRncm91cD5cblx0XHRcdHsvZWFjaH1cblx0XHQ8L3NlbGVjdD5cblx0PC9kaXY+XG5cblx0PGEgcmVsPVwicHJlZmV0Y2hcIiBjbGFzcz1cIm5vLXVuZGVybGluZVwiIGhyZWY9XCJ0dXRvcmlhbC97KHNlbGVjdGVkLm5leHQgfHwgc2VsZWN0ZWQpLnNsdWd9XCIgY2xhc3M6ZGlzYWJsZWQ9eyFzZWxlY3RlZC5uZXh0fT5cblx0XHQ8SWNvbiBuYW1lPVwiYXJyb3ctcmlnaHRcIiAvPlxuXHQ8L2E+XG48L25hdj5cbiIsIjxzY3JpcHQgY29udGV4dD1cIm1vZHVsZVwiPlxuXHRleHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJlbG9hZCh7IHBhcmFtcyB9KSB7XG5cdFx0Y29uc3QgcmVzID0gYXdhaXQgdGhpcy5mZXRjaChgdHV0b3JpYWwvJHtwYXJhbXMuc2x1Z30uanNvbmApO1xuXG5cdFx0aWYgKCFyZXMub2spIHtcblx0XHRcdHJldHVybiB0aGlzLnJlZGlyZWN0KDMwMSwgYHR1dG9yaWFsL2Jhc2ljc2ApO1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRzbHVnOiBwYXJhbXMuc2x1Zyxcblx0XHRcdGNoYXB0ZXI6IGF3YWl0IHJlcy5qc29uKClcblx0XHR9O1xuXHR9XG48L3NjcmlwdD5cblxuPHNjcmlwdD5cblx0aW1wb3J0IFJlcGwgZnJvbSAnQHN2ZWx0ZWpzL3N2ZWx0ZS1yZXBsJztcblx0aW1wb3J0IHsgZ2V0Q29udGV4dCB9IGZyb20gJ3N2ZWx0ZSc7XG5cblx0aW1wb3J0IFNjcmVlblRvZ2dsZSBmcm9tICcuLi8uLi8uLi9jb21wb25lbnRzL1NjcmVlblRvZ2dsZS5zdmVsdGUnO1xuXHRpbXBvcnQgVGFibGVPZkNvbnRlbnRzIGZyb20gJy4vX1RhYmxlT2ZDb250ZW50cy5zdmVsdGUnO1xuXG5cdGltcG9ydCB7XG5cdFx0bWFwYm94X3NldHVwLCAvLyBuZWVkZWQgZm9yIGNvbnRleHQgQVBJIHR1dG9yaWFsXG5cdFx0cm9sbHVwVXJsLFxuXHRcdHN2ZWx0ZVVybFxuXHR9IGZyb20gJy4uLy4uLy4uL2NvbmZpZyc7XG5cblx0ZXhwb3J0IGxldCBzbHVnO1xuXHRleHBvcnQgbGV0IGNoYXB0ZXI7XG5cblx0Y29uc3QgeyBzZWN0aW9ucyB9ID0gZ2V0Q29udGV4dCgndHV0b3JpYWwnKTtcblxuXHRsZXQgcmVwbDtcblx0bGV0IHByZXY7XG5cdGxldCBzY3JvbGxhYmxlO1xuXHRjb25zdCBsb29rdXAgPSBuZXcgTWFwKCk7XG5cblx0bGV0IHdpZHRoID0gcHJvY2Vzcy5icm93c2VyID8gd2luZG93LmlubmVyV2lkdGggOiAxMDAwO1xuXHRsZXQgb2Zmc2V0ID0gMDtcblxuXHRzZWN0aW9ucy5mb3JFYWNoKHNlY3Rpb24gPT4ge1xuXHRcdHNlY3Rpb24uY2hhcHRlcnMuZm9yRWFjaChjaGFwdGVyID0+IHtcblx0XHRcdGNvbnN0IG9iaiA9IHtcblx0XHRcdFx0c2x1ZzogY2hhcHRlci5zbHVnLFxuXHRcdFx0XHRzZWN0aW9uLFxuXHRcdFx0XHRjaGFwdGVyLFxuXHRcdFx0XHRwcmV2XG5cdFx0XHR9O1xuXG5cdFx0XHRsb29rdXAuc2V0KGNoYXB0ZXIuc2x1Zywgb2JqKTtcblxuXHRcdFx0aWYgKHByb2Nlc3MuYnJvd3NlcikgeyAvLyBwZW5kaW5nIGh0dHBzOi8vZ2l0aHViLmNvbS9zdmVsdGVqcy9zdmVsdGUvaXNzdWVzLzIxMzVcblx0XHRcdFx0aWYgKHByZXYpIHByZXYubmV4dCA9IG9iajtcblx0XHRcdFx0cHJldiA9IG9iajtcblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG5cblx0Ly8gVE9ETyBpcyB0aGVyZSBhIG5vbi1oYWNreSB3YXkgdG8gdHJpZ2dlciBzY3JvbGwgd2hlbiBjaGFwdGVyIGNoYW5nZXM/XG5cdCQ6IGlmIChzY3JvbGxhYmxlKSBjaGFwdGVyLCBzY3JvbGxhYmxlLnNjcm9sbFRvKDAsIDApO1xuXG5cdC8vIFRPRE86IHRoaXMgd2lsbCBuZWVkIHRvIGJlIGNoYW5nZWQgdG8gdGhlIG1hc3RlciBicmFuY2gsIGFuZCBwcm9iYWJseSBzaG91bGQgYmUgZHluYW1pYyBpbnN0ZWFkIG9mIGluY2x1ZGVkXG5cdC8vICAgaGVyZSBzdGF0aWNhbGx5XG5cdGNvbnN0IHR1dG9yaWFsX3JlcG9fbGluayA9ICdodHRwczovL2dpdGh1Yi5jb20vc3ZlbHRlanMvc3ZlbHRlL3RyZWUvbWFzdGVyL3NpdGUvY29udGVudC90dXRvcmlhbCc7XG5cblx0JDogc2VsZWN0ZWQgPSBsb29rdXAuZ2V0KHNsdWcpO1xuXHQkOiBpbXByb3ZlX2xpbmsgPSBgJHt0dXRvcmlhbF9yZXBvX2xpbmt9LyR7c2VsZWN0ZWQuY2hhcHRlci5zZWN0aW9uX2Rpcn0vJHtzZWxlY3RlZC5jaGFwdGVyLmNoYXB0ZXJfZGlyfWA7XG5cblx0Y29uc3QgY2xvbmUgPSBmaWxlID0+ICh7XG5cdFx0bmFtZTogZmlsZS5uYW1lLFxuXHRcdHR5cGU6IGZpbGUudHlwZSxcblx0XHRzb3VyY2U6IGZpbGUuc291cmNlXG5cdH0pO1xuXG5cdCQ6IGlmIChyZXBsKSB7XG5cdFx0Y29tcGxldGVkID0gZmFsc2U7XG5cdFx0cmVwbC5zZXQoe1xuXHRcdFx0Y29tcG9uZW50czogY2hhcHRlci5hcHBfYS5tYXAoY2xvbmUpXG5cdFx0fSk7XG5cdH1cblxuXHQkOiBtb2JpbGUgPSB3aWR0aCA8IDc2ODtcblxuXHRmdW5jdGlvbiByZXNldCgpIHtcblx0XHRyZXBsLnVwZGF0ZSh7XG5cdFx0XHRjb21wb25lbnRzOiBjaGFwdGVyLmFwcF9hLm1hcChjbG9uZSlcblx0XHR9KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNvbXBsZXRlKCkge1xuXHRcdHJlcGwudXBkYXRlKHtcblx0XHRcdGNvbXBvbmVudHM6IGNoYXB0ZXIuYXBwX2IubWFwKGNsb25lKVxuXHRcdH0pO1xuXHR9XG5cblx0bGV0IGNvbXBsZXRlZCA9IGZhbHNlO1xuXG5cdGZ1bmN0aW9uIGhhbmRsZV9jaGFuZ2UoZXZlbnQpIHtcblx0XHRjb21wbGV0ZWQgPSBldmVudC5kZXRhaWwuY29tcG9uZW50cy5ldmVyeSgoZmlsZSwgaSkgPT4ge1xuXHRcdFx0Y29uc3QgZXhwZWN0ZWQgPSBjaGFwdGVyLmFwcF9iW2ldO1xuXHRcdFx0cmV0dXJuIGV4cGVjdGVkICYmIChcblx0XHRcdFx0ZmlsZS5uYW1lID09PSBleHBlY3RlZC5uYW1lICYmXG5cdFx0XHRcdGZpbGUudHlwZSA9PT0gZXhwZWN0ZWQudHlwZSAmJlxuXHRcdFx0XHRmaWxlLnNvdXJjZS50cmltKCkucmVwbGFjZSgvXFxzKyQvZ20sICcnKSA9PT0gZXhwZWN0ZWQuc291cmNlLnRyaW0oKS5yZXBsYWNlKC9cXHMrJC9nbSwgJycpXG5cdFx0XHQpO1xuXHRcdH0pO1xuXHR9XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuXHQudHV0b3JpYWwtb3V0ZXIge1xuXHRcdHBvc2l0aW9uOiByZWxhdGl2ZTtcblx0XHRoZWlnaHQ6IGNhbGMoMTAwdmggLSB2YXIoLS1uYXYtaCkpO1xuXHRcdG92ZXJmbG93OiBoaWRkZW47XG5cdFx0cGFkZGluZzogMCAwIDQycHggMDtcblx0XHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHR9XG5cblx0LnZpZXdwb3J0IHtcblx0XHRkaXNwbGF5OiBncmlkO1xuXHRcdHdpZHRoOiAzMDAlO1xuXHRcdGhlaWdodDogMTAwJTtcblx0XHRncmlkLXRlbXBsYXRlLWNvbHVtbnM6IDMzLjMzMyUgNjYuNjY2JTtcblx0XHR0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gLjNzO1xuXHRcdGdyaWQtYXV0by1yb3dzOiAxMDAlO1xuXHR9XG5cblx0Lm9mZnNldC0xIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTMzLjMzMyUsIDApOyB9XG5cdC5vZmZzZXQtMiB7IHRyYW5zZm9ybTogdHJhbnNsYXRlKC02Ni42NjYlLCAwKTsgfVxuXG5cdEBtZWRpYSAobWluLXdpZHRoOiA3NjhweCkge1xuXHRcdC50dXRvcmlhbC1vdXRlciB7IHBhZGRpbmc6IDAgfVxuXG5cdFx0LnZpZXdwb3J0IHtcblx0XHRcdHdpZHRoOiAxMDAlO1xuXHRcdFx0aGVpZ2h0OiAxMDAlO1xuXHRcdFx0ZGlzcGxheTogZ3JpZDtcblx0XHRcdGdyaWQtdGVtcGxhdGUtY29sdW1uczogbWlubWF4KDMzLjMzMyUsIHZhcigtLXNpZGViYXItbGFyZ2UtdykpIGF1dG87XG5cdFx0XHRncmlkLWF1dG8tcm93czogMTAwJTtcblx0XHRcdHRyYW5zaXRpb246IG5vbmU7XG5cdFx0fVxuXG5cdFx0Lm9mZnNldC0xLCAub2Zmc2V0LTIgeyB0cmFuc2Zvcm06IG5vbmU7IH1cblx0fVxuXG5cdC50dXRvcmlhbC10ZXh0IHtcblx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG5cdFx0aGVpZ2h0OiAxMDAlO1xuXHRcdGJvcmRlci1yaWdodDogMXB4IHNvbGlkIHZhcigtLXNlY29uZCk7XG5cdFx0YmFja2dyb3VuZC1jb2xvcjogdmFyKC0tc2Vjb25kKTtcblx0XHRjb2xvcjogdmFyKC0tc2lkZWJhci10ZXh0KTtcblx0fVxuXG5cdC5jaGFwdGVyLW1hcmt1cCB7XG5cdFx0cGFkZGluZzogMy4ycmVtIDRyZW07XG5cdFx0b3ZlcmZsb3c6IGF1dG87XG5cdFx0ZmxleDogMTtcblx0XHRoZWlnaHQ6IDA7XG5cdH1cblxuXHQuY2hhcHRlci1tYXJrdXAgOmdsb2JhbChoMikge1xuXHRcdG1hcmdpbjogNHJlbSAwIDEuNnJlbSAwO1xuXHRcdGZvbnQtc2l6ZTogdmFyKC0taDMpO1xuXHRcdGxpbmUtaGVpZ2h0OiAxO1xuXHRcdGZvbnQtd2VpZ2h0OiA0MDA7XG5cdFx0Y29sb3I6IHdoaXRlO1xuXHR9XG5cblx0LmNoYXB0ZXItbWFya3VwIDpnbG9iYWwoaDI6Zmlyc3QtY2hpbGQpIHtcblx0XHRtYXJnaW4tdG9wOiAuNHJlbTtcblx0fVxuXG5cdC5jaGFwdGVyLW1hcmt1cCA6Z2xvYmFsKGEpIHtcblx0XHRjb2xvcjogdmFyKC0tc2lkZWJhci10ZXh0KTtcblx0fVxuXG5cdC5jaGFwdGVyLW1hcmt1cCA6Z2xvYmFsKGE6aG92ZXIpIHtcblx0XHRjb2xvcjogd2hpdGU7XG5cdH1cblxuXG5cdC5jaGFwdGVyLW1hcmt1cCA6Z2xvYmFsKHVsKSB7XG5cdFx0cGFkZGluZzogMCAwIDAgMmVtO1xuXHR9XG5cblx0LmNoYXB0ZXItbWFya3VwIDpnbG9iYWwoYmxvY2txdW90ZSkge1xuXHRcdGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwwLDAsLjE3KTtcblx0XHRjb2xvcjogdmFyKC0tc2lkZWJhci10ZXh0KTtcblx0fVxuXG5cdC5jaGFwdGVyLW1hcmt1cDo6LXdlYmtpdC1zY3JvbGxiYXIge1xuXHRcdGJhY2tncm91bmQtY29sb3I6IHZhcigtLXNlY29uZCk7XG5cdFx0d2lkdGg6IDhweDtcblx0fVxuXG5cdC5jaGFwdGVyLW1hcmt1cDo6LXdlYmtpdC1zY3JvbGxiYXItdGh1bWIge1xuXHRcdGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LDI1NSwyNTUsLjcpO1xuXHRcdGJvcmRlci1yYWRpdXM6IDFlbTtcblx0XHRvdXRsaW5lOiAxcHggc29saWQgZ3JlZW47XG5cdH1cblxuXHQuY2hhcHRlci1tYXJrdXAgOmdsb2JhbChwKSA+IDpnbG9iYWwoY29kZSksXG5cdC5jaGFwdGVyLW1hcmt1cCA6Z2xvYmFsKHVsKSA6Z2xvYmFsKGNvZGUpIHtcblx0XHRjb2xvcjogdmFyKC0tc2lkZWJhci10ZXh0KTtcblx0XHRiYWNrZ3JvdW5kOiByZ2JhKDAsMCwwLC4xMik7XG5cdFx0cGFkZGluZzogLjJlbSAuNGVtIC4zZW07XG5cdFx0d2hpdGUtc3BhY2U6IG5vd3JhcDtcblx0XHRwb3NpdGlvbjogcmVsYXRpdmU7XG5cdFx0dG9wOiAtMC4xZW07XG5cdH1cblxuXHQuY29udHJvbHMge1xuXHRcdGJvcmRlci10b3A6IDFweCBzb2xpZCByZ2JhKDI1NSwyNTUsMjU1LC4xNSk7XG5cdFx0cGFkZGluZzogMWVtIDAgMCAwO1xuXHRcdGRpc3BsYXk6IGZsZXg7XG5cdH1cblxuXHQuc2hvdyB7XG5cdFx0YmFja2dyb3VuZDogcmdiYSgwLDAsMCwuNCk7XG5cdFx0cGFkZGluZzogLjNlbSAuN2VtO1xuXHRcdGJvcmRlci1yYWRpdXM6IHZhcigtLWJvcmRlci1yKTtcblx0XHR0b3A6IC4xZW07XG5cdFx0cG9zaXRpb246IHJlbGF0aXZlO1xuXHRcdGZvbnQtc2l6ZTogdmFyKC0taDUpO1xuXHRcdGZvbnQtd2VpZ2h0OiAzMDA7XG5cdH1cblxuXHQuc2hvdzpob3ZlciB7XG5cdFx0YmFja2dyb3VuZDogcmdiYSgwLDAsMCwuNjUpO1xuXHRcdGNvbG9yOiB3aGl0ZTtcblx0fVxuXG5cdGEubmV4dCB7XG5cdFx0cGFkZGluZy1yaWdodDogMS4yZW07XG5cdFx0YmFja2dyb3VuZDogbm8tcmVwZWF0IDEwMCUgNTAlIHVybCgvaWNvbnMvYXJyb3ctcmlnaHQuc3ZnKTtcblx0XHRiYWNrZ3JvdW5kLXNpemU6IDFlbSAxZW07XG5cdFx0bWFyZ2luLWxlZnQ6IGF1dG87XG5cdH1cblxuXHQuaW1wcm92ZS1jaGFwdGVyIHtcblx0XHRwYWRkaW5nOiAxZW0gMCAuNWVtIDA7XG5cdH1cblxuXHQuaW1wcm92ZS1jaGFwdGVyIGEge1xuXHRcdHBhZGRpbmc6IDAgLjFlbTtcblx0XHRmb250LXNpemU6IDE0cHg7XG5cdFx0dGV4dC1kZWNvcmF0aW9uOiBub25lO1xuXHRcdG9wYWNpdHk6IC4zO1xuXHRcdHBhZGRpbmctbGVmdDogMS4yZW07XG5cdFx0YmFja2dyb3VuZDogbm8tcmVwZWF0IDAgNTAlIHVybCgvaWNvbnMvZWRpdC5zdmcpO1xuXHRcdGJhY2tncm91bmQtc2l6ZTogMWVtIDFlbTtcblx0fVxuXG5cdC5pbXByb3ZlLWNoYXB0ZXIgYTpob3ZlciB7XG5cdFx0b3BhY2l0eTogMTtcblx0fVxuPC9zdHlsZT5cblxuPHN2ZWx0ZTpoZWFkPlxuXHQ8dGl0bGU+e3NlbGVjdGVkLnNlY3Rpb24udGl0bGV9IC8ge3NlbGVjdGVkLmNoYXB0ZXIudGl0bGV9IOKAoiBTdmVsdGUgVHV0b3JpYWw8L3RpdGxlPlxuXG5cdDxtZXRhIG5hbWU9XCJ0d2l0dGVyOnRpdGxlXCIgY29udGVudD1cIlN2ZWx0ZSB0dXRvcmlhbFwiPlxuXHQ8bWV0YSBuYW1lPVwidHdpdHRlcjpkZXNjcmlwdGlvblwiIGNvbnRlbnQ9XCJ7c2VsZWN0ZWQuc2VjdGlvbi50aXRsZX0gLyB7c2VsZWN0ZWQuY2hhcHRlci50aXRsZX1cIj5cblx0PG1ldGEgbmFtZT1cIkRlc2NyaXB0aW9uXCIgY29udGVudD1cIntzZWxlY3RlZC5zZWN0aW9uLnRpdGxlfSAvIHtzZWxlY3RlZC5jaGFwdGVyLnRpdGxlfVwiPlxuPC9zdmVsdGU6aGVhZD5cblxuPHN2ZWx0ZTp3aW5kb3cgYmluZDppbm5lcldpZHRoPXt3aWR0aH0vPlxuXG48ZGl2IGNsYXNzPVwidHV0b3JpYWwtb3V0ZXJcIj5cblx0PGRpdiBjbGFzcz1cInZpZXdwb3J0IG9mZnNldC17b2Zmc2V0fVwiPlxuXHRcdDxkaXYgY2xhc3M9XCJ0dXRvcmlhbC10ZXh0XCI+XG5cdFx0XHQ8ZGl2IGNsYXNzPVwidGFibGUtb2YtY29udGVudHNcIj5cblx0XHRcdFx0PFRhYmxlT2ZDb250ZW50cyB7c2VjdGlvbnN9IHtzbHVnfSB7c2VsZWN0ZWR9Lz5cblx0XHRcdDwvZGl2PlxuXG5cdFx0XHQ8ZGl2IGNsYXNzPVwiY2hhcHRlci1tYXJrdXBcIiBiaW5kOnRoaXM9e3Njcm9sbGFibGV9PlxuXHRcdFx0XHR7QGh0bWwgY2hhcHRlci5odG1sfVxuXG5cdFx0XHRcdDxkaXYgY2xhc3M9XCJjb250cm9sc1wiPlxuXHRcdFx0XHRcdHsjaWYgY2hhcHRlci5hcHBfYn1cblx0XHRcdFx0XHRcdDwhLS0gVE9ETyBkaXNhYmxlIHRoaXMgYnV0dG9uIHdoZW4gdGhlIGNvbnRlbnRzIG9mIHRoZSBSRVBMXG5cdFx0XHRcdFx0XHRcdG1hdGNoZXMgdGhlIGV4cGVjdGVkIGVuZCByZXN1bHQgLS0+XG5cdFx0XHRcdFx0XHQ8YnV0dG9uIGNsYXNzPVwic2hvd1wiIG9uOmNsaWNrPVwieygpID0+IGNvbXBsZXRlZCA/IHJlc2V0KCkgOiBjb21wbGV0ZSgpfVwiPlxuXHRcdFx0XHRcdFx0XHR7Y29tcGxldGVkID8gJ1Jlc2V0JyA6ICdTaG93IG1lJ31cblx0XHRcdFx0XHRcdDwvYnV0dG9uPlxuXHRcdFx0XHRcdHsvaWZ9XG5cblx0XHRcdFx0XHR7I2lmIHNlbGVjdGVkLm5leHR9XG5cdFx0XHRcdFx0XHQ8YSBjbGFzcz1cIm5leHRcIiBocmVmPVwidHV0b3JpYWwve3NlbGVjdGVkLm5leHQuc2x1Z31cIj5OZXh0PC9hPlxuXHRcdFx0XHRcdHsvaWZ9XG5cdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdDxkaXYgY2xhc3M9XCJpbXByb3ZlLWNoYXB0ZXJcIj5cblx0XHRcdFx0XHQ8YSBjbGFzcz1cIm5vLXVuZGVybGluZVwiIGhyZWY9e2ltcHJvdmVfbGlua30+RWRpdCB0aGlzIGNoYXB0ZXI8L2E+XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0PC9kaXY+XG5cdFx0PC9kaXY+XG5cblx0XHQ8ZGl2IGNsYXNzPVwidHV0b3JpYWwtcmVwbFwiPlxuXHRcdFx0PFJlcGxcblx0XHRcdFx0YmluZDp0aGlzPXtyZXBsfVxuXHRcdFx0XHR3b3JrZXJzVXJsPVwid29ya2Vyc1wiXG5cdFx0XHRcdHtzdmVsdGVVcmx9XG5cdFx0XHRcdHtyb2xsdXBVcmx9XG5cdFx0XHRcdG9yaWVudGF0aW9uPXttb2JpbGUgPyAnY29sdW1ucycgOiAncm93cyd9XG5cdFx0XHRcdGZpeGVkPXttb2JpbGV9XG5cdFx0XHRcdG9uOmNoYW5nZT17aGFuZGxlX2NoYW5nZX1cblx0XHRcdFx0aW5qZWN0ZWRKUz17bWFwYm94X3NldHVwfVxuXHRcdFx0XHRyZWxheGVkXG5cdFx0XHQvPlxuXHRcdDwvZGl2PlxuXHQ8L2Rpdj5cblxuXHR7I2lmIG1vYmlsZX1cblx0XHQ8U2NyZWVuVG9nZ2xlIGJpbmQ6b2Zmc2V0IGxhYmVscz17Wyd0dXRvcmlhbCcsICdpbnB1dCcsICdvdXRwdXQnXX0vPlxuXHR7L2lmfVxuPC9kaXY+XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt3QkFtRm9DLE1BQU0sQ0FBQyxZQUFZLEtBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyw4QkFBSSxPQUFPLENBQUMsS0FBSzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7NkNBQTNELE9BQU8sQ0FBQyxJQUFJOzs7Ozs7Ozs7Ozs7OzBEQUFrQyxPQUFPLENBQUMsS0FBSzs7Ozs4RUFBM0QsT0FBTyxDQUFDLElBQUk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt3QkFEckIsT0FBTyxDQUFDLFFBQVE7Ozs7c0NBQXJCOzs7Ozs7Ozt1Q0FBQTs7Ozs7Ozs7Ozt1Q0FBQTs7Ozs7Ozs7O2dFQURlLENBQUMsR0FBRyxDQUFDLGVBQUksT0FBTyxDQUFDLEtBQUs7Ozs7Ozs7dUNBQ3JDOzs7Ozs7O3VCQUFLLE9BQU8sQ0FBQyxRQUFROzs7cUNBQXJCOzs7Ozs7Ozs7Ozs7NkJBQUE7OztnQkFBQSxzQkFBQTs7O3dGQURlLENBQUMsR0FBRyxDQUFDLGVBQUksT0FBTyxDQUFDLEtBQUs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsrRUFQdkMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxLQUFLLGtDQUV2QixRQUFRLENBQUMsT0FBTyxDQUFDLEtBQUs7Ozs7Ozs7OztzQkFJaEIsUUFBUTs7OztvQ0FBYjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt1Q0FBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7dUNBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3NEQWRtRCxLQUFDLFFBQVEsQ0FBQyxJQUFJLFFBQUksUUFBUSxFQUFFLElBQUk7Z0NBQW1CLEtBQUMsUUFBUSxDQUFDLElBQUk7Ozs7Ozs7Ozs7Ozs7Ozs7O3NEQXdCakUs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
