import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, W as svg_element, k as claim_element, l as children, m as detach_dev, a2 as xlink_attr, p as add_location, o as attr_dev, q as insert_dev, v as append_dev, n as noop } from './index.121aa0ed.js';
import './index.ab7b6b80.js';
import './navigation.84703ebc.js';

/* node_modules\@sveltejs\site-kit\components\Icon.svelte generated by Svelte v3.12.0 */

const file = "node_modules\\@sveltejs\\site-kit\\components\\Icon.svelte";

function create_fragment(ctx) {
	var svg, use, use_xlink_href_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			use = svg_element("use");
			this.h();
		},

		l: function claim(nodes) {
			svg = claim_element(nodes, "svg", { class: true, width: true, height: true }, true);
			var svg_nodes = children(svg);

			use = claim_element(svg_nodes, "use", { "xlink:href": true }, true);
			var use_nodes = children(use);

			use_nodes.forEach(detach_dev);
			svg_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			xlink_attr(use, "xlink:href", use_xlink_href_value = "#" + ctx.name);
			add_location(use, file, 14, 1, 308);
			attr_dev(svg, "class", "icon svelte-5yec89");
			attr_dev(svg, "width", ctx.size);
			attr_dev(svg, "height", ctx.size);
			add_location(svg, file, 13, 0, 261);
		},

		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, use);
		},

		p: function update(changed, ctx) {
			if ((changed.name) && use_xlink_href_value !== (use_xlink_href_value = "#" + ctx.name)) {
				xlink_attr(use, "xlink:href", use_xlink_href_value);
			}

			if (changed.size) {
				attr_dev(svg, "width", ctx.size);
				attr_dev(svg, "height", ctx.size);
			}
		},

		i: noop,
		o: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(svg);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment.name, type: "component", source: "", ctx });
	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { name, size = 20 } = $$props;

	const writable_props = ['name', 'size'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Icon> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ('name' in $$props) $$invalidate('name', name = $$props.name);
		if ('size' in $$props) $$invalidate('size', size = $$props.size);
	};

	$$self.$capture_state = () => {
		return { name, size };
	};

	$$self.$inject_state = $$props => {
		if ('name' in $$props) $$invalidate('name', name = $$props.name);
		if ('size' in $$props) $$invalidate('size', size = $$props.size);
	};

	return { name, size };
}

class Icon extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, ["name", "size"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "Icon", options, id: create_fragment.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.name === undefined && !('name' in props)) {
			console.warn("<Icon> was created without expected prop 'name'");
		}
	}

	get name() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set name(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export { Icon as I };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguMGE5NzhmMTAuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9Ac3ZlbHRlanMvc2l0ZS1raXQvY29tcG9uZW50cy9JY29uLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8IS0tXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHRzdmcgaWNvblxuXHQtIGh0dHBzOi8vZ2l0aHViLmNvbS9qYWNvYm1pc2Noa2Evc3ZlbHRlLWZlYXRoZXItaWNvblxuXHQtIGh0dHBzOi8vZmVhdGhlcmljb25zLmNvbS9cbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4tLT5cblxuPHNjcmlwdD5cblx0ZXhwb3J0IGxldCBuYW1lO1xuXHRleHBvcnQgbGV0IHNpemUgPSAyMDtcbjwvc2NyaXB0PlxuXG48c3ZnIGNsYXNzPVwiaWNvblwiIHdpZHRoPXtzaXplfSBoZWlnaHQ9e3NpemV9PlxuXHQ8dXNlIHhsaW5rOmhyZWY9JyN7bmFtZX0nIC8+XG48L3N2Zz5cblxuPHN0eWxlPlxuXHQuaWNvbiB7XG5cdFx0cG9zaXRpb246IHJlbGF0aXZlO1xuXHRcdG92ZXJmbG93OiBoaWRkZW47XG5cdFx0dmVydGljYWwtYWxpZ246IG1pZGRsZTtcblx0XHQtby1vYmplY3QtZml0OiBjb250YWluO1xuXHRcdG9iamVjdC1maXQ6IGNvbnRhaW47XG5cdFx0LXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOiBjZW50ZXIgY2VudGVyO1xuXHRcdHRyYW5zZm9ybS1vcmlnaW46IGNlbnRlciBjZW50ZXI7XG5cdFx0c3Ryb2tlOiBjdXJyZW50Q29sb3I7XG5cdFx0c3Ryb2tlLXdpZHRoOiAyO1xuXHRcdHN0cm9rZS1saW5lY2FwOiByb3VuZDtcblx0XHRzdHJva2UtbGluZWpvaW46IHJvdW5kO1xuXHRcdGZpbGw6IG5vbmU7XG5cdH1cbjwvc3R5bGU+XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztrRUFjb0IsSUFBSTs7OzhCQURDLElBQUk7K0JBQVUsSUFBSTs7Ozs7Ozs7OztvRkFDdkIsSUFBSTs7Ozs7K0JBREMsSUFBSTtnQ0FBVSxJQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FKbkMsTUFBSSxJQUFJLEVBQ0osSUFBSSxHQUFHLGNBQUUsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7In0=
